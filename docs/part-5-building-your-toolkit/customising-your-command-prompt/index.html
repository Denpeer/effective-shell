<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Customising Your Command Prompt"><meta property="og:title" content="Customising Your Command Prompt"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://effective-shell.com/docs/part-5-building-your-toolkit/customising-your-command-prompt/"><title>Customising Your Command Prompt | Effective Shell</title><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.f8520695a602b532b093067e25561bfe6fa10ca8c25171b97142acf58fa8f13c.css integrity="sha256-+FIGlaYCtTKwkwZ+JVYb/m+hDKjCUXG5cUKs9Y+o8Tw="><script defer src=/en.search.min.901d4b22032222a6f8db08efa32b2ce89f2b7affb9b504a133dbe52ece751a89.js integrity="sha256-kB1LIgMiIqb42wjvoyss6J8rev+5tQShM9vlLs51Gok="></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-155335600-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><link rel=alternate type=application/rss+xml href=https://effective-shell.com/docs/part-5-building-your-toolkit/customising-your-command-prompt/index.xml title="Effective Shell"><script id=mcjs>!function(c,h,i,m,p){m=c.createElement(h),p=c.getElementsByTagName(h)[0],m.async=1,m.src=i,p.parentNode.insertBefore(m,p)}(document,"script","https://chimpstatic.com/mcjs-connected/js/users/eac1a082b6db34d40aaff2caf/a2aaca5a8358c2e12d3f43f1a.js");</script></head><body><input type=checkbox class=hidden id=menu-control><main class="flex container"><aside class="book-menu fixed"><nav><h2 class=book-brand><a href=https://effective-shell.com/><span>Effective Shell</span></a></h2><h2 class=book-subtitle><span>By Dave Kerr</span></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/docs/introduction/><strong>Introduction</strong></a></li><li><a href=/docs/getting-started/><strong>Getting Started</strong></a></li><li><a href=/docs/part-1-transitioning-to-the-shell/><strong>Part 1 - Transitioning to the Shell</strong></a><ul><li><a href=/docs/part-1-transitioning-to-the-shell/navigating-your-system/>Navigating Your System</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/managing-your-files/>Managing Your Files</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/clipboard-gymnastics/>Clipboard Gymnastics</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/getting-help/>Getting Help</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/the-renaissance-of-the-shell/>The Renaissance of the Shell</a></li></ul></li><li><a href=/docs/part-2-core-skills/><strong>Part 2 - Core Skills</strong></a><ul><li><a href=/docs/part-2-core-skills/thinking-in-pipelines/>Thinking in Pipelines</a></li><li><a href=/docs/part-2-core-skills/fly-on-the-command-line/>Fly on the Command Line</a></li><li><a href=/docs/part-2-core-skills/job-control/>Job Control</a></li><li><a href=/docs/part-2-core-skills/understanding-commands/>Understanding Commands</a></li><li><a href=/docs/part-2-core-skills/finding-files/>Finding Files</a></li><li><a href=/docs/part-2-core-skills/what-is-a-shell/>What is a Shell?</a></li></ul></li><li><a href=/docs/part-3-manipulating-text/><strong>Part 3 - Manipulating Text</strong></a><ul><li><a href=/docs/part-3-manipulating-text/regex-essentials/>Regex Essentials</a></li><li><a href=/docs/part-3-manipulating-text/get-to-grips-with-grep/>Get to Grips with Grep</a></li><li><a href=/docs/part-3-manipulating-text/slice-and-dice-text/>Slice and Dice Text</a></li><li><a href=/docs/part-3-manipulating-text/advanced-text-manipulation/>Advanced Text Manipulation with Sed</a></li><li><a href=/docs/part-3-manipulating-text/build-commands-on-the-fly/>Build Commands on the Fly with Xargs</a></li></ul></li><li><a href=/docs/part-4-shell-scripting/><strong>Part 4 - Shell Scripting</strong></a><ul><li><a href=/docs/part-4-shell-scripting/shell-script-essentials/>Shell Script Essentials</a></li><li><a href=/docs/part-4-shell-scripting/variables-reading-input-and-mathematics/>Variables, Reading Input, and Mathematics</a></li><li><a href=/docs/part-4-shell-scripting/mastering-conditional-logic/>Mastering Conditional Logic</a></li><li><a href=/docs/part-4-shell-scripting/loops-and-working-with-files-and-folders/>Loops and working with Files and Folders</a></li><li><a href=/docs/part-4-shell-scripting/functions-parameters-and-error-handling/>Functions, Parameters and Error Handling</a></li><li><a href=/docs/part-4-shell-scripting/useful-patterns-for-shell-scripts/>Useful Patterns for Shell Scripts</a></li></ul></li><li><a href=/docs/part-5-building-your-toolkit/><strong>Part 5 - Building Your Toolkit</strong></a><ul><li><a href=/docs/part-5-building-your-toolkit/configuring-the-shell/>Configuring the Shell</a></li><li><a href=/docs/part-5-building-your-toolkit/customising-your-command-prompt/ class=active>Customising Your Command Prompt</a></li><li><a href=/docs/part-5-building-your-toolkit/managing-your-dotfiles/>Managing Your Dotfiles</a></li><li><a href=/docs/part-5-building-your-toolkit/controlling-changes-with-git/>Controlling Changes with Git</a></li><li><a href=/docs/part-5-building-your-toolkit/managing-remote-git-repositories/>Managing Remote Git Repositories and Sharing Your Dotfiles</a></li></ul></li><li><a href=/docs/part-6-advanced-techniques/><strong>Part 6 - Advanced Techniques</strong></a><ul><li><a href=/docs/part-6-advanced-techniques/understanding-shell-expansion/>Understanding Shell Expansion</a></li></ul></li><li><a href=/docs/work-in-progress/><strong>Work in Progress</strong></a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class="flex align-center justify-between book-header"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Customising Your Command Prompt</strong></header><article class=markdown><h1 id=chapter-25---customising-your-command-prompt>Chapter 25 - Customising Your Command Prompt</h1><p>The shell has a large number of options available that you can use to customise the <em>command prompt</em> - the text shown in front of your cursor as you type commands. In this chapter we will look at how you can change the command prompt to show the information that you would like to see.</p><p>We will also create a script that allows us to set our own command prompt &lsquo;theme&rsquo; from a list that we can extend over time. This script will also handle the differences between Bash-like shells and Z-Shell for us, allowing us to have a consistent command prompt across different types of shells!</p><h1 id=the-command-prompt--index-->The Command Prompt</h1><p>The <em>command prompt</em> is the text that is shown to the left of your cursor to show that the shell is waiting for you to type a command. Each distribution comes with its own configuration for the command prompt, but the default is often similar to the one shown below:</p><pre><code>dwmkerr@effective-shell-ubuntu-20:~$
</code></pre><p>This is the prompt on an Ubuntu virtual machine I have set up. If you want to set up a free virtual machine yourself, you can follow the guide at <a href=/docs/work-in-progress/>Appendix - Setting Up a Linux Virtual Machine</a>.</p><p>Let's take a look at each of the components that make up the prompt:</p><ul><li><code>dwmkerr</code> - The first thing that is shown is the name of the current user</li><li><code>@</code> - Next we have an ampersand character that is used as a separator between the username field and the following field</li><li><code>effective-shell-ubuntu</code>: This is the <em>hostname</em> of the machine</li><li><code>:</code> - A colon separates the hostname from the next field</li><li><code>~</code> - Next we have the current working directory</li><li><code>$</code> - Finally we have the prompt itself, the <code>$</code> symbol shows we are a normal user, rather than a &lsquo;root&rsquo; user</li></ul><p>If we change directory, our prompt will be updated:</p><pre><code>dwmkerr@effective-shell-ubuntu-20:~$ cd effective-shell
dwmkerr@effective-shell-ubuntu-20:~/effective-shell$
</code></pre><p>If we change to the &lsquo;super&rsquo; user we can see that the username changes to <code>root</code> and the <code>$</code> dollar symbol changes to a <code>#</code> hash symbol:</p><pre><code>dwmkerr@effective-shell-ununtu-20:~/effective-shell$ sudo su
root@effective-shell-ununtu-20:/home/dwmkerr/effective-shell#
</code></pre><p>The <code>#</code> symbol is a useful reminder that we are the root user. It is important to be careful when running commands as the root user as we could easily break things by changing system files.</p><p>So out-of-the box on most systems our command prompt shows a number of useful fields. But we can actually customise this prompt to include almost any kind of information we would like to see. Let's take a look!</p><h1 id=customising-the-command-prompt>Customising the Command Prompt</h1><p>The structure of the command prompt is specified in the <code>PS1</code> shell variable. This stands for &lsquo;Prompt String 1&rsquo;. The shell uses this variable to write out the command prompt.</p><p>We can see the contents of this variable by using <code>echo</code> or <code>printf</code> to write it to the screen:</p><pre><code>dwmkerr@effective-shell-ubuntu-20:~/effective-shell$ echo $PS1
\[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$
</code></pre><p>This looks extremely complicated - but don't worry, by the time we've finished this chapter you'll be able to understand what this mess of special characters means!</p><p>The easiest way to see how these special prompt strings work is to start using them, so let's get started and customise our prompt.</p><h2 id=the-prompt-string>The Prompt String</h2><p>You can set your own prompt string by setting the <code>PS1</code> variable:</p><pre><code>dwmkerr@effective-shell-ubuntu-20:~/effective-shell$ PS1=&quot;---&gt; &quot;
---&gt;
</code></pre><p>The shell will use the contents of the <code>PS1</code> variable to display the prompt. We can use plan text as shown above, but there's also a lot more that we can do to customise this prompt!</p><h2 id=special-characters>Special Characters</h2><p>When the shell reads the <code>PS1</code> variable, it allows certain special characters to be specified. These characters can be used to customise how the prompt string looks.</p><p>The special characters that the shell uses are listed below:</p><table><thead><tr><th>Characters</th><th>Usage</th></tr></thead><tbody><tr><td><code>\a</code></td><td>The special &lsquo;beep&rsquo; character, that tells the shell to play a beep sound through the speakers.</td></tr><tr><td><code>\d</code></td><td>The date in &ldquo;Weekday Month Date&rdquo; format, for example: &lsquo;Tue May 26&rsquo;)</td></tr><tr><td><code>\D{format}</code></td><td>The date in a format specified by the <code>format</code> value.</td></tr><tr><td><code>\e</code></td><td>An ASCII escape character (033). This is used to print special characters.</td></tr><tr><td><code>\h</code></td><td>The hostname up to the first <code>.</code> dot.</td></tr><tr><td><code>\H</code></td><td>The hostname.</td></tr><tr><td><code>\j</code></td><td>The number of jobs currently managed by the shell.</td></tr><tr><td><code>\l</code></td><td>The basename of the shell's terminal device.</td></tr><tr><td><code>\n</code></td><td>A newline character.</td></tr><tr><td><code>\r</code></td><td>A carriage return character.</td></tr><tr><td><code>\s</code></td><td>The name of the shell, the basename of <code>$0</code>, for example: <code>-bash</code>.</td></tr><tr><td><code>\t</code></td><td>The current time in 24-hour HH:MM:SS format.</td></tr><tr><td><code>\T</code></td><td>The current time in 12-hour HH:MM:SS format.</td></tr><tr><td><code>\@</code></td><td>The current time in 12-hour am/pm format.</td></tr><tr><td><code>\A</code></td><td>The current time in 24-hour HH:MM format.</td></tr><tr><td><code>\u</code></td><td>The username of the current user.</td></tr><tr><td><code>\v</code></td><td>The version of bash, for example: &lsquo;5.0&rsquo;.</td></tr><tr><td><code>\V</code></td><td>The release of bash, with the patch level, for example: &lsquo;5.0.17&rsquo;.</td></tr><tr><td><code>\w</code></td><td>The current working directory, with <code>$HOME</code> abbreviated with a <code>~</code> tilde symbol.</td></tr><tr><td><code>\W</code></td><td>The current working directory name (rather than the entire path as is used for <code>\w</code>).</td></tr><tr><td><code>\!</code></td><td>The history number of this command.</td></tr><tr><td><code>\#</code></td><td>The command number of this command</td></tr><tr><td><code>\$</code></td><td>The <code>$</code> dollar symbol, unless we are a super-user, in which case the <code>#</code> hash symbol is used.</td></tr><tr><td><code>\nnn</code></td><td>The character corresponding to the octal number <code>nnn</code>, used to show special characters.</td></tr><tr><td><code>\\</code> | A <code>\</code> backslash character. |</td><td></td></tr><tr><td><code>\[</code></td><td>The &lsquo;start of non-printing characters&rsquo; sequence.</td></tr><tr><td><code>\[</code></td><td>The &lsquo;end of non-printing characters&rsquo; sequence.</td></tr></tbody></table><p>Some of these sequences are reasonably self-explanatory, some are a little more complex. Let's use some of them now to see how we can customise the prompt.</p><blockquote class="book-hint info"><p><strong>Z-Shell</strong>
The <code>zsh</code> shell uses different sequences. However, I suggest that you follow this chapter through to understand how Bash-like shells work and then you can apply the same techniques using Z-Shell. The Z-Shell documentation links are at the end of the chapter.</p><p>Later on in this chapter we will introduce a function to help set the prompt, this function automatically converts to the prompt into Z-Shell format if needed. So the techniques you learn here should still be able to be used in Z-Shell.</p></blockquote><p>To change the prompt, all we need to do is set the <code>PS1</code> variable. Let's start by changing the prompt so that it shows the date, time and the <code>$</code> or <code>#</code> prompt symbol:</p><pre><code>dwmkerr@effective-shell-ubuntu-20:~$ PS1='\d \@ \$ '
Sun Jun 06 12:43 PM $
</code></pre><p>In this example we've used the <code>\d</code> (current date), <code>\@</code> (current time in am/pm format) and <code>\$</code> (prompt) and a space for our prompt. Notice that once we set <code>PS1</code> in the shell, the prompt immediately changed.</p><p>How about if we want to show the number of jobs, then the command number, then the prompt? Easy!</p><pre><code>Sun Jun 06 04:43 AM $ PS1='[\j] (\#) \$ '
[0] (4) $ sleep 10 &amp;
[1] 27598
[1] (5) $ sleep 10 &amp;
[2] 27600
[2] (6) $ sleep 10 &amp;
[3] 27601
[3] (7) $
</code></pre><p>In this example we've used the <code>\j</code> (current job) sequence, and surrounded it with square brackets. Then we used <code>#</code> (command number), surrounded by parentheses, then the <code>\$</code> shell prompt. I also started some background jobs, that just run the <code>sleep</code> (<em>wait for a number of seconds</em>) command, so that we can see that the number of jobs is changing. If you need a refresher on jobs, check <a href=/docs/part-2-core-skills/job-control/>Chapter 9 -Job Control</a>.</p><p>Note that we are using single quotes when specifying the value of the <code>PS1</code>. If we didn't use single quotes, then the shell would see the dollar symbol and think that we were trying to use a variable. For a reminder on how quoting works, check <a href=/docs/part-4-shell-scripting/variables-reading-input-and-mathematics/>Chapter 19 - Variables, Reading Input, and Mathematics</a>.</p><p>If you are following along or trying this out in your own shell, you might have noticed that we don't have any colours for the new prompts we have set, everything is shown in white. To set the colour of the prompt we need to use some special characters.</p><h2 id=changing-the-colour-and-text-formatting>Changing the Colour and Text Formatting</h2><p>In the earlier part of this chapter we saw that the default prompt on systems like Ubuntu contains lots of special characters. For reference, here is the value of the <code>PS1</code> variable on a clean Ubuntu 20 installations:</p><pre><code>dwmkerr@effective-shell-ubuntu-20:~/effective-shell$ echo $PS1
\[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$
</code></pre><p>Some of these characters we might now be able to recognise, such as <code>\u</code> for the username and <code>\h</code> for the host. The characters that start with the sequence <code>\033</code> are <em>ANSI color codes</em>. ANSI stands for <em>American National Standards Institute</em>, an organisation that was set up to attempt to set common standards for computing platforms.</p><p>In the early days of Unix, each vendor developed their own special characters that could be used to control the visual formatting of output. These characters would vary from platform to platform, which made trying to create scripts or functionality that worked across multiple platforms complex. To deal with this, the ANSI organisation defined a common set of codes that could be printed to a terminal to control the visual style of the output.</p><p>To tell a terminal that we want to use a special sequence to control the formatting or output of text, we can use these <em>ANSI Escape Sequences</em>. First we write out the characters <code>\033</code> or <code>\e</code>. This is the sequence that represents the &lsquo;escape&rsquo; key. The first version is the &lsquo;escape&rsquo; key code written in &lsquo;octal&rsquo; format (octal is a format where numbers are written in base eight, rather than base ten). The second sequence is an alternative way of writing the &lsquo;escape&rsquo; key.</p><p>When a terminal sees the escape sequence, it knows that the <em>following</em> sequence is used to define the formatting. The table below shows some of the different formats that can be used:</p><table><thead><tr><th>Sequence</th><th>Meaning</th></tr></thead><tbody><tr><td><strong>Foreground Color</strong></td><td></td></tr><tr><td><code>\033[30m</code></td><td>Set foreground to &lsquo;black&rsquo;.</td></tr><tr><td><code>\033[31m</code></td><td>Set foreground to &lsquo;red&rsquo;.</td></tr><tr><td><code>\033[32m</code></td><td>Set foreground to &lsquo;green&rsquo;.</td></tr><tr><td><code>\033[33m</code></td><td>Set foreground to &lsquo;yellow&rsquo;.</td></tr><tr><td><code>\033[34m</code></td><td>Set foreground to &lsquo;blue&rsquo;.</td></tr><tr><td><code>\033[35m</code></td><td>Set foreground to &lsquo;magenta&rsquo;.</td></tr><tr><td><code>\033[36m</code></td><td>Set foreground to &lsquo;cyan&rsquo;.</td></tr><tr><td><code>\033[37m</code></td><td>Set foreground to &lsquo;white&rsquo; (normally light grey)</td></tr><tr><td><strong>Foreground Color (Bold)</strong></td><td></td></tr><tr><td><code>\033[1;30m</code></td><td>Set foreground to &lsquo;bright black&rsquo; (grey, or bold black)</td></tr><tr><td><code>\033[1;31m</code></td><td>Set foreground to &lsquo;bright red&rsquo; (or bold red).</td></tr><tr><td><code>\033[1;32m</code></td><td>Set foreground to &lsquo;bright green&rsquo; (or bold green).</td></tr><tr><td><code>\033[1;33m</code></td><td>Set foreground to &lsquo;bright yellow&rsquo; (or bold yellow).</td></tr><tr><td><code>\033[1;34m</code></td><td>Set foreground to &lsquo;bright blue&rsquo; (or bold blue).</td></tr><tr><td><code>\033[1;35m</code></td><td>Set foreground to &lsquo;bright purple&rsquo; (or bold purple).</td></tr><tr><td><code>\033[1;36m</code></td><td>Set foreground to &lsquo;bright cyan&rsquo; (or bold cyan).</td></tr><tr><td><code>\033[1;37m</code></td><td>Set foreground to &lsquo;bright white&rsquo; (or bold white).</td></tr><tr><td><strong>Background Color</strong></td><td></td></tr><tr><td><code>\033[0;40m</code></td><td>Set background to &lsquo;black&rsquo;.</td></tr><tr><td><code>\033[0;41m</code></td><td>Set background to &lsquo;red&rsquo;.</td></tr><tr><td><code>\033[0;42m</code></td><td>Set background to &lsquo;green&rsquo;.</td></tr><tr><td><code>\033[0;43m</code></td><td>Set background to &lsquo;brown&rsquo;.</td></tr><tr><td><code>\033[0;44m</code></td><td>Set background to &lsquo;blue&rsquo;.</td></tr><tr><td><code>\033[0;45m</code></td><td>Set background to &lsquo;purple&rsquo;.</td></tr><tr><td><code>\033[0;46m</code></td><td>Set background to &lsquo;cyan&rsquo;.</td></tr><tr><td><code>\033[0;47m</code></td><td>Set background to &lsquo;white&rsquo; (normally light grey).</td></tr><tr><td><strong>Reset Colors</strong></td><td></td></tr><tr><td><code>\033[0m</code></td><td>Reset the text colors.</td></tr></tbody></table><p>Notice that each sequence starts with the &lsquo;escape&rsquo; character, followed by <code>[</code> or <code>[1;</code>. <code>[</code> will use the &lsquo;normal&rsquo; colour, <code>[1;</code> will use the &lsquo;bright&rsquo; colour (how this is shown depends on your terminal emulator, in many modern emulators the text is shown in the same colour but is bold). You can also use <code>[0;</code> to clear any changes to the foreground or background before you set the new one. After this there are one of eight colours that can be used, specified by the characters in the range from <code>30m</code> to <code>37m</code>. The sequences in the range <code>40m</code> to <code>47m</code> set the background color. The sequence <code>0m</code> resets the colors.</p><p>With these codes we can print coloured text. When we write text that uses escape sequences, we need to tell the shell that our text needs to have these escape sequences processed properly. We can use the <code>printf</code> command or <code>echo -e</code> to do this. <code>printf</code> should be preferred as not all systems support the <code>-e</code> parameter for <code>echo</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>printf <span style=color:#e6db74>&#34;\033[31mRED\033[0m\n&#34;</span>
printf <span style=color:#e6db74>&#34;\033[1;31mLIGHT RED\033[0m\n&#34;</span>
printf <span style=color:#e6db74>&#34;\033[0;30m\033[42mBLACK ON GREEN\033[0m\n&#34;</span>
</code></pre></div><p>The output of these commands will be the text below:</p><pre><code>RED
LIGHT RED
BLACK ON GREEN
</code></pre><p>However, the colour of the foreground and background should change on each line. The exact formatting will change depending on the terminal emulator you use. Some terminal emulators use bold text for the &lsquo;bright&rsquo; colours.</p><p>With our new knowledge of how to use ANSI Escape Sequences to set the format of text, we can update our <code>PS1</code> variable to show a prompt in colour. As an example, the code below sets the prompt to show the username in blue and the name of the current working directory in green, followed by a white <code>$</code> prompt symbol, followed by the &lsquo;reset&rsquo; sequence so that the text we type afterwords does not have its colour changed:</p><pre><code>dwmkerr@effective-shell-ubuntu-20:~/effective-shell$ PS1='\033[34m\u \033[32m\W \033[37m\$ '
dwmkerr effective-shell $
</code></pre><p>The prompt above will be shown in color on modern terminals.</p><p>There is one snag to this. If you set your prompt in this way and press the &lsquo;up&rsquo; and &lsquo;down&rsquo; keys to cycle through previously entered commands, you might see that your shell prompt gets overwritten. The reason for this is that we need to tell the shell that colour and formatting sequences are &lsquo;non-printing&rsquo; characters - the sequences don't actually produce written text in the terminal.</p><p>To deal with this we need to surround each colour sequence with the special characters <code>\[</code> and <code>\]</code>. This tells the shell when a &lsquo;non-printing&rsquo; sequence starts and when it ends. To fix our <code>PS1</code> variable, we can use the value below:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>PS1<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;\[\033[34m\]\u \[\033[32m\]\W \[\033[37m\]\$ \[\033[0m\]&#39;</span>
</code></pre></div><p>Phew! This is a lot of work to go to just to format the colour of the prompt. Later in this chapter we'll build a script that will make it far easier to work with colours and text formatting!</p><h2 id=adding-data-to-the-command-prompt>Adding Data to the Command Prompt</h2><p>When we set the <code>PS1</code> variable, we are simply setting it to a string. This string could be anything, for example:</p><pre><code>dwmkerr@effective-shell-ubuntu-20:~$ PS1='-Ready?---&gt; '
-Ready?---&gt; 
</code></pre><p>We don't need to limit ourselves to the special sequences we've seen so far in this chapter - we can run any commands we like to build a command prompt. For example, we could use the use the <code>ls</code> (<em>list directory contents</em>) and <code>wc</code> (<em>count lines and works</em>) commands to count the number of files and folders in the current directory and show that in the prompt:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>PS1<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>ls -al | wc -l | tr -d <span style=color:#e6db74>&#39;[:space:]&#39;</span><span style=color:#66d9ef>)</span><span style=color:#e6db74> \\</span>$<span style=color:#e6db74> </span><span style=color:#e6db74>&#34;</span>
</code></pre></div><p>When I run this command, my prompt will look something like this:</p><pre><code>32 $
</code></pre><p>We have used the <code>$()</code> notation to run a sub-shell that lists the contents of the current directory and then pipes them to <code>wc -l</code>, which counts the number of lines. Finally we pipe the result into <code>tr -d '[:space:]</code> to remove the whitespace around the line count.</p><p>To use the <code>$()</code> notation, or any shell variable, we have to use double quotes in the string, otherwise the shell will write out those characters literally. And because we are using double quotes, we need an extra backslash before last <code>\$</code> character to escape it, so that the shell doesn't try to treat it as a variable.</p><p>However - there's a subtle bug in this <code>PS1</code> configuration! Let's see what happens when we change directories:</p><pre><code>32 $ cd effective-shell/
32 $ touch newfile-{1..10}
32 $ 
</code></pre><p>In the session above I changed to the <em>effective-shell</em> directory. But the count is still showing as <code>32</code>. This is suspicious. After creating ten new files with <code>touch newfile-{1..10}</code> the count still shows <code>32</code>.</p><p>The reason for this is that <code>32</code> was the number of files and folders in the current directory <em>at the time the <code>PS1</code> variable was set</em>. We changed the <code>PS1</code> variable once - what we really need to do is have the prompt count the files each time the prompt is shown.</p><p>Fortunately, there is a special syntax for this! We just put a <code>\</code> backslash character in front of the <code>$</code> dollar symbol for the sub-shell:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>PS1<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>\$(ls -al | wc -l | tr -d &#39;[:space:]&#39;) \\</span>$<span style=color:#e6db74> </span><span style=color:#e6db74>&#34;</span>
</code></pre></div><p>The backslash before the sub-shell tells the shell that it should evaluate the sub-shell <em>each time</em> the prompt is shown:</p><pre><code>32 $ touch newfile-{1..10}
42 $
</code></pre><p>This is where the real power of the <code>PS1</code> variable comes into play. Because we set it using the shell itself, we can run <em>any</em> commands that we find useful and integrate their output into our command prompt.</p><p>Let's see this in action by creating a script to make customising our prompt far easier and more intuitive!</p><h1 id=a-shell-script-to-customise-the-prompt>A Shell Script to Customise the Prompt</h1><p>We can write a script to make it much easier to customise our shell prompt. Rather than having to remember each of the colour sequences, we can store them in variables to make them easier to refer to. We can also run any commands that we'd like to run to allow us to show extra information.</p><p>There is a script in the Effective Shell samples at <em>~/effective-shell/scripts/set_ps1.sh</em> that we can use to set our <code>PS1</code> variable in a much more user-friendly way.</p><blockquote class="book-hint info"><p><strong>Downloading the Samples</strong></p><p>Run the following commands in your shell to download the samples:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>curl effective.sh | sh
</code></pre></div></blockquote><p>The <em>set_ps1.sh</em> script is quite long, so let's go through it bit-by-bit.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Keep track of the original PS1 value.</span>
_original_ps1<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>PS1<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>

set_ps1<span style=color:#f92672>(</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#75715e># Foreground colours.</span>
    local fg_black<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>tput setaf 0<span style=color:#66d9ef>)</span>     <span style=color:#75715e># \033[30m</span>
    local fg_red<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>tput setaf 1<span style=color:#66d9ef>)</span>       <span style=color:#75715e># \033[31m</span>
    local fg_green<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>tput setaf 2<span style=color:#66d9ef>)</span>     <span style=color:#75715e># \033[32m</span>
    local fg_yellow<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>tput setaf 3<span style=color:#66d9ef>)</span>    <span style=color:#75715e># \033[33m</span>
    local fg_blue<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>tput setaf 4<span style=color:#66d9ef>)</span>      <span style=color:#75715e># \033[34m</span>
    local fg_magenta<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>tput setaf 5<span style=color:#66d9ef>)</span>   <span style=color:#75715e># \033[35m</span>
    local fg_cyan<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>tput setaf 6<span style=color:#66d9ef>)</span>      <span style=color:#75715e># \033[36m</span>
    local fg_white<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>tput setaf 7<span style=color:#66d9ef>)</span>     <span style=color:#75715e># \033[37m</span>

    <span style=color:#75715e># Background colours.</span>
    local bg_black<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>tput setab 0<span style=color:#66d9ef>)</span>     <span style=color:#75715e># \033[40m</span>
    local bg_red<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>tput setab 1<span style=color:#66d9ef>)</span>       <span style=color:#75715e># \033[41m</span>
    local bg_green<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>tput setab 2<span style=color:#66d9ef>)</span>     <span style=color:#75715e># \033[42m</span>
    local bg_yellow<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>tput setab 3<span style=color:#66d9ef>)</span>    <span style=color:#75715e># \033[43m</span>
    local bg_blue<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>tput setab 4<span style=color:#66d9ef>)</span>      <span style=color:#75715e># \033[44m</span>
    local bg_magenta<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>tput setab 5<span style=color:#66d9ef>)</span>   <span style=color:#75715e># \033[45m</span>
    local bg_cyan<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>tput setab 6<span style=color:#66d9ef>)</span>      <span style=color:#75715e># \033[46m</span>
    local bg_white<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>tput setab 7<span style=color:#66d9ef>)</span>     <span style=color:#75715e># \033[47m</span>
</code></pre></div><p>First, we store the current value of <code>PS1</code> in a variable named <code>_original_ps1</code>. This is so that later on if we have changed the <code>PS1</code> variable, we can change it back to what it was set to originally. The <code>_</code> underscore in the variable name is a convention that indicates that this variable is used internally in the script.</p><p>Next, we define a function called <code>set_ps1</code>. Then we use the <code>tput</code> command (<em>query terminfo database</em>) to get the exact escape sequences for the foreground and background colours. For easy reference the escape sequences are shown to the right of each command as a comment.</p><p>Next, we get the escape sequences for some of the other formatting options, such as &lsquo;bold&rsquo; (which will be &lsquo;bright&rsquo; on some terminals):</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>    <span style=color:#75715e># Text styles and reset. Note that on some terminals &#39;bold&#39; will produce</span>
    <span style=color:#75715e># light colours for bright colours, on others it will actually show the text</span>
    <span style=color:#75715e># in bold.</span>
    local bold<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>tput bold<span style=color:#66d9ef>)</span>            <span style=color:#75715e># \033[1m</span>
    local dim<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>tput dim<span style=color:#66d9ef>)</span>              <span style=color:#75715e># \033[2m</span>
    local start_underline<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>tput smul<span style=color:#66d9ef>)</span> <span style=color:#75715e># \033[4m</span>
    local stop_underline<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>tput mmul<span style=color:#66d9ef>)</span>  <span style=color:#75715e># \033[24m</span>
    local reset<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>tput sgr0<span style=color:#66d9ef>)</span>           <span style=color:#75715e># \033[0m</span>
</code></pre></div><p>You might recall the <code>tput</code> command from the section &lsquo;colourising output&rsquo; in <a href=/docs/part-4-shell-scripting/useful-patterns-for-shell-scripts/>Chapter 23 - Useful Patterns for Shell Scripts</a>.</p><p>After this we use a <code>case</code> statement to set the <code>PS1</code> variable based on the value of the first parameter that was provided to the function:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>    <span style=color:#75715e># Depending on the name of the theme provided, set the prompt.</span>
    <span style=color:#66d9ef>case</span> $1 in
        debian<span style=color:#f92672>)</span>
            <span style=color:#75715e># Debian/Ubuntu style:</span>
            <span style=color:#75715e>#   \u@\h - username@host (bold/green)</span>
            <span style=color:#75715e>#   \w - working directory (bold/blue)</span>
            <span style=color:#75715e>#   \$ - prompt (# if root, otherwise $) (bold/white)</span>
            PS1<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>\[</span><span style=color:#e6db74>${</span>bold<span style=color:#e6db74>}</span><span style=color:#e6db74>${</span>fg_green<span style=color:#e6db74>}</span><span style=color:#e6db74>\]\u@\h:\[</span><span style=color:#e6db74>${</span>fg_blue<span style=color:#e6db74>}</span><span style=color:#e6db74>\]\w\[</span><span style=color:#e6db74>${</span>fg_white<span style=color:#e6db74>}</span><span style=color:#e6db74>\]\\</span>$<span style=color:#e6db74>\[</span><span style=color:#e6db74>${</span>reset<span style=color:#e6db74>}</span><span style=color:#e6db74>\] </span><span style=color:#e6db74>&#34;</span>
        ;;

        datetime<span style=color:#f92672>)</span>
            <span style=color:#75715e># A style that shows the date and time:</span>
            <span style=color:#75715e>#   \D{%Y-%m-%d} - the year/month/date (in white)</span>
            <span style=color:#75715e>#   \@ - the time (in green)</span>
            <span style=color:#75715e>#   \$ - prompt (# if root, otherwise $) (bold/white)</span>
            PS1<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>\[</span><span style=color:#e6db74>${</span>fg_white<span style=color:#e6db74>}</span><span style=color:#e6db74>\]\D{%Y-%m-%d} \[</span><span style=color:#e6db74>${</span>bold<span style=color:#e6db74>}</span><span style=color:#e6db74>${</span>fg_green<span style=color:#e6db74>}</span><span style=color:#e6db74>\]\@\[</span><span style=color:#e6db74>${</span>fg_white<span style=color:#e6db74>}</span><span style=color:#e6db74>\] \\</span>$<span style=color:#e6db74>\[</span><span style=color:#e6db74>${</span>reset<span style=color:#e6db74>}</span><span style=color:#e6db74>\] </span><span style=color:#e6db74>&#34;</span>
        ;;

        <span style=color:#75715e># Add your own themes here!</span>

        *<span style=color:#f92672>)</span>
            <span style=color:#75715e># Restore PS1 to its original value.</span>
            PS1<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>_original_ps1<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
        ;; 
    <span style=color:#66d9ef>esac</span>

    <span style=color:#75715e># If we are in Z-Shell convert the PS1 to use Z-Shell format.</span>
    <span style=color:#f92672>[</span> -n <span style=color:#e6db74>&#34;</span>$ZSH_VERSION<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span> <span style=color:#f92672>&amp;&amp;</span> PS1<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>_to_zsh <span style=color:#e6db74>&#34;</span>$PS1<span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>)</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>In this code we check the first parameter of the function <code>$1</code>. If it matches the string <code>debian</code> we set the <code>PS1</code> variable to a format that is similar to what is used by Debian Linux distributions. If it matches the string <code>datetime</code> we set <code>PS1</code> to a prompt that shows the current date and time. If any other value is used, we reset the <code>PS1</code> variable back to its original value.</p><p>Before we complete the function, we check to see if <code>ZSH_VERSION</code> is set - this is to check whether we are in a <code>zsh</code> shell. If we are, then we use the <code>_to_zsh</code> function to convert the <code>PS1</code> string into the format used by Z-Shell.</p><p>Finally, we use the <code>}</code> to complete the definition of the function.</p><blockquote class="book-hint info"><p><strong>Z-Shell</strong></p><p>The <code>zsh</code> shell differs considerably from Bash and Bash-like shells in how it handles the <code>PS1</code> variable. There is no need for the <code>\[</code> or <code>\]</code> sequences, there are built in color variables such as <code>$fg[red]</code> for &lsquo;red&rsquo; and the special sequences are different (for example, rather than <code>\u</code> for username, Z-Shell uses <code>%n</code>).</p><p>The <code>set_ps1</code> function in the samples converts the <code>PS1</code> string to Z-Shell format if it is running in Z-Shell. However, this conversion is not perfect as some of the sequences shown in this chapter do not have an equivalent in Z-Shell. If you want to customise a Z-Shell prompt you can check the manual page <code>man zshmisc</code> and search for <code>PROMPT\ SEQUENCES</code>.</p></blockquote><p>Notice how much easier it is to specify the values for the <code>PS1</code> string when we have the colours and formatting defined in variables! We still need to wrap the formatting characters with <code>\[</code> and <code>\]</code> to make sure that the shell knows how long the command prompt is, but this is <em>far</em> easier to read than the samples we saw before where we provide the ANSI Escape Sequences.</p><p>To use this script, we can simply <code>source</code> it into our current session and then change the prompt by calling the <code>set_ps1</code> function:</p><pre><code>$ 
dwmkerr@effective-shell-ubuntu-20:~$ source ~/effective-shell/scripts/set_ps1.sh
dwmkerr@effective-shell-ubuntu-20:~$ set_ps1 datetime
2021-06-06 04:10 PM $ set_ps1 debian
dwmkerr@effective-shell-ubuntu-20:~$ 
</code></pre><p>This script has a placeholder in the <code>case</code> statement for you to add your own &lsquo;themes&rsquo; that you want to be able to use in your shell.</p><p>For example, one &lsquo;theme&rsquo; I often use is below:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>git<span style=color:#f92672>)</span>
    <span style=color:#75715e># A style that shows some git information.</span>

    <span style=color:#75715e># Build a string that shows:</span>
    <span style=color:#75715e># - The branch (underlined if &#39;main&#39;) in green</span>
    <span style=color:#75715e># - A red exclamation if there are any local changes not committed</span>
    <span style=color:#75715e># - An indicator of the number of stashed items, if any.</span>
    _git_info<span style=color:#f92672>(</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#75715e># Git details.</span>
        local git_branch_name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>git branch --show-current<span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span>
        local git_any_local_changes<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>git status --porcelain<span style=color:#f92672>=</span>v1 2&gt;/dev/null<span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span>
        local git_stash_count<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>git rev-list --walk-reflogs --count <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>            refs/stash -- 2&gt;/dev/null<span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span> <span style=color:#75715e># Ignore error when no stashes</span>
        local git_info<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span>
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>git_branch_name<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;main&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
            git_info<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>bold<span style=color:#e6db74>}</span><span style=color:#e6db74>${</span>fg_green<span style=color:#e6db74>}</span><span style=color:#e6db74>${</span>start_underline<span style=color:#e6db74>}</span><span style=color:#e6db74>${</span>git_branch_name<span style=color:#e6db74>}</span><span style=color:#e6db74>${</span>reset<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
        <span style=color:#66d9ef>else</span>
            git_info<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>bold<span style=color:#e6db74>}</span><span style=color:#e6db74>${</span>fg_green<span style=color:#e6db74>}</span><span style=color:#e6db74>${</span>git_branch_name<span style=color:#e6db74>}</span><span style=color:#e6db74>${</span>reset<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
        <span style=color:#66d9ef>fi</span>
        <span style=color:#66d9ef>if</span> ! <span style=color:#f92672>[</span> -z <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>git_any_local_changes<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
            <span style=color:#75715e># Note that we have to be careful to put the exclamation mark</span>
            <span style=color:#75715e># in single quotes so that it is not expanded to the last command!</span>
            git_info<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>git_info<span style=color:#e6db74>}</span><span style=color:#e6db74> </span><span style=color:#e6db74>${</span>bold<span style=color:#e6db74>}</span><span style=color:#e6db74>${</span>fg_red<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>&#39;!&#39;</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>reset<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
        <span style=color:#66d9ef>fi</span>
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>git_stash_count<span style=color:#66d9ef>:-</span>0<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> -gt <span style=color:#ae81ff>0</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
            git_info<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>git_info<span style=color:#e6db74>}</span><span style=color:#e6db74> </span><span style=color:#e6db74>${</span>bold<span style=color:#e6db74>}</span><span style=color:#e6db74>${</span>fg_yellow<span style=color:#e6db74>}</span><span style=color:#e6db74>${</span>git_stash_count<span style=color:#e6db74>}</span><span style=color:#e6db74> in stash</span><span style=color:#e6db74>${</span>reset<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
        <span style=color:#66d9ef>fi</span>
        printf <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>git_info<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
    <span style=color:#f92672>}</span>

    <span style=color:#75715e># Now show a Debian style prompt with the git info above it.</span>
    PS1<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>\$(_git_info)\n\\[</span><span style=color:#e6db74>${</span>bold<span style=color:#e6db74>}</span><span style=color:#e6db74>${</span>fg_green<span style=color:#e6db74>}</span><span style=color:#e6db74>\]\u@\h:\[</span><span style=color:#e6db74>${</span>fg_blue<span style=color:#e6db74>}</span><span style=color:#e6db74>\]\w\[</span><span style=color:#e6db74>${</span>fg_white<span style=color:#e6db74>}</span><span style=color:#e6db74>\]\\</span>$<span style=color:#e6db74>\[</span><span style=color:#e6db74>${</span>reset<span style=color:#e6db74>}</span><span style=color:#e6db74>\] </span><span style=color:#e6db74>&#34;</span>
;;
</code></pre></div><p>Don't worry if you are not familiar with &lsquo;git&rsquo;, we will see it in a couple of chapters. The important thing is that this snippet shows that you can add almost any kind of information that you might find useful to your command prompt. When I run <code>set_ps1 git</code>, my prompt looks like this:</p><pre><code>feat/chapter-26-customise-your-command-prompt ! 3 in stash
dwmkerr@effective-shell-ubuntu-20:~/repos/github/dwmkerr/effective-shell$
</code></pre><p>My prompt is now spread across two lines - the first shows me the branch I am on, a red exclamation point if I have made changes but not saved them, and the number of items I have in my &lsquo;stash&rsquo;. The second line shows the standard Debian prompt.</p><p>The code shown above has been slightly simplified to make it more readable, you can see the exact version in the samples.</p><p>You can use the <em>~/effective-shell/scripts/set_ps1.sh</em> file to build your own &lsquo;themes&rsquo; and easily change between them in the shell.</p><p>If you want to always <code>source</code> this file into your shell on startup, just add the following like to <em>~/.bashrc</em>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>source <span style=color:#e6db74>&#34;~/effective-shell/scripts/set_ps1.sh&#34;</span>
</code></pre></div><p>You could also set the default <code>PS1</code> variable immediately after sourcing the script if you like:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Source the set_ps1 function and set our &#39;theme&#39; to Debian.</span>
source <span style=color:#e6db74>&#34;~/effective-shell/scripts/set_ps1.sh&#34;</span>
set_ps1 <span style=color:#e6db74>&#34;debian&#34;</span>
</code></pre></div><p>In the next chapter we will look at some sensible ways we can organise files like the <em>set_ps1.sh</em> script and the <em>~/.bashrc</em> file so that we can easily manage our customisations and share them across different machines.</p><h1 id=additional-prompt-configuration>Additional Prompt Configuration</h1><p>There are some other variables that you might want to use to configure your prompt:</p><table><thead><tr><th>Variable</th><th>Description</th></tr></thead><tbody><tr><td><code>PS2</code></td><td>This is shown when performing &lsquo;continuation&rsquo; and is normally set to <code>></code>.</td></tr><tr><td><code>PS3</code></td><td>This is shown when the <code>select</code> command is used and is normally not set, so the default <code>#?</code> is used.</td></tr><tr><td><code>PS4</code></td><td>This is shown when tracing with <code>set -x</code> and is normally set to <code>+</code>.</td></tr><tr><td><code>PROMPT_DIRTRIM</code></td><td>This can be set to limit the number of directories shown with using <code>\w</code> or <code>\W</code> in your prompt.</td></tr><tr><td><code>PROMPT_COMMAND</code></td><td>This can be set to limit the number of directories shown with using <code>\w</code> or <code>\W</code> in your prompt.</td></tr></tbody></table><p>Let's take a look at how each one can be used.</p><p><strong>PS2</strong></p><p>If we have a long line of text in the shell, we can start a &lsquo;continuation' by entering the backlash symbol:</p><pre><code>$ echo &quot;This is a really really \
&gt; long \
&gt; long line of text&quot;
This is a really really long long line of text
</code></pre><p>The <code>></code> symbol is shown when we press &lsquo;enter&rsquo; after entering a <code>\</code> backslash symbol. This symbol is used to remind us that we are not entering a new command, we are just continuing the current command on a new line. You can change the text shown by setting <code>PS2</code>.</p><p><strong>PS3</strong></p><p><code>PS3</code> allows you to specify the prompt used by the <code>select</code> command:</p><pre><code>$ PS3=&quot;Your choice? : &quot;
$ select fruit in Apples Pears; do echo &quot;$fruit&quot;; done
1) Apples
2) Pears
Your choice? :
</code></pre><p>The <code>PS3</code> variable is not set by default. If it is not set, then the <code>select</code> statement uses <code>#?</code> for the prompt.</p><p><strong>PS4</strong></p><p>When you enable &lsquo;tracing&rsquo; by setting the <code>-x</code> option, each traced line starts with a <code>+</code> symbol:</p><pre><code>$ set -x
$ echo &quot;The date is $(date)&quot;
++ date
+ echo 'The date is Sun 06 Jun 2021 08:49:07 AM UTC'
The date is Sun 06 Jun 2021 08:49:07 AM UTC
</code></pre><p>You can change this symbol by setting the <code>PS4</code> option.</p><p><strong>PROMPT_DIRTRIM</strong></p><p>If you set a value in the <code>PROMPT_DIRTRIM</code> variable, the shell will not show the entire contents of the working directory when you use the special <code>\w</code> sequence in a prompt variable. Instead, it will limit the number of directories shown to the value in <code>PROPMT_DIRTRIM</code> and use an &lsquo;ellipses&rsquo; for the rest (and ellipses is written as three dots).</p><p>For example, if I was in the folder <em>~/effective-shell/logs/apm-logs</em> and had <code>PROMPT_DIRTRIM</code> set to <code>2</code>, then on Debian my command prompt would look like this:</p><pre><code>dwmkerr@effective-shell-ubuntu-20:~/.../logs/apm-logs$
</code></pre><p>Note that only the last two parts of the path to the folder are shown.</p><p><strong>PROMPT_COMMAND</strong></p><p>The <code>PROMPT_COMMAND</code> variable can be used to specify a command or set of commands to run before the prompt is shown.</p><p>A common use for the <code>PROMPT_COMMAND</code> is to save and reload the shell command history before each command is run:</p><pre><code>PROMPT_COMMAND=&quot;history -a; history -c; history -r; $PROMPT_COMMAND&quot;
</code></pre><p>In this example, we used the <code>history</code> (<em>display or manipulate history list</em>) command three times. First with <code>-a</code> to append the lines from the current session to the history file, then <code>-c</code> to clear the shell history in the session, then <code>-r</code> to reload it.</p><p>For many shells the history of commands is only updated when the shell is closed, this change means that even if the shell is terminated unexpectedly, each command we have executed will still have been written to the history.</p><h1 id=z-shell-and-oh-my-zsh>Z-Shell and Oh-My-Zsh</h1><p>Z-Shell does not use the same sequences to format the prompt-string variables. However, the <em>set_ps1.sh</em> script included in the Effective Shell samples will convert the Bash-style <code>PS1</code> variable into Z-Shell formatted prompt strings automatically.</p><p>For Z-Shell users, you might also consider the very popular &ldquo;Oh-My-Zsh&rdquo; project. This is a collection of themes and plugins that add many more aliases, functions, autocompletions and more to the shell. One of the most popular features of &ldquo;Oh-My-Zsh&rdquo; is its large collection of themes that customise how the prompt looks.</p><p>However, just like with most things in computing, I would strongly recommend that you learn how the fundamentals work as they are described in this chapter before using &ldquo;Oh-My-Zsh&rdquo; themes. This will help you understand how things like &ldquo;Oh-My-Zsh&rdquo; actually work under the hood.</p><p>You might also realise that you don't need to install an additional package to get the styling you want. For example, my own shell prompt includes information on Git, the working directory (trimmed to only show up to three entries), but only requires a few lines of of setup and works consistently in Bash-like shells <em>and</em> Z-Shell.</p><p>Enjoy playing around with the prompt customisation! It can be a lot of fun and the options are almost limitless!</p><h1 id=summary>Summary</h1><p>In this chapter we looked at how you can customise the command prompt with the <code>PS1</code> variable, the shell's special sequences for useful information like <code>\u</code> for the current user, and how to configure the visual formatting of the prompt. We also looked at a script that makes configuring the command prompt a little easier to manage.</p><p>We've now seen quite a few ways to configure the shell, in the next chapter we'll look at some sensible practices that you can use to organise your shell configuration files.</p><p>To find all of the information on how to control the command prompt in the manual, run <code>man bash</code> and search for <code>^PROMPTING</code>. For Z-Shell, run <code>man zshmisc</code> and search for <code>PROMPT\ SEQUENCES</code>.</p></article><div class="book-footer justify-between"><div><a class="flex align-center" href=https://github.com/dwmkerr/effective-shell/commit/e17a05b83de3b31512abb58f097c8766ca334fe6 title="Last modified by Dave Kerr | Feb 2, 2022" target=_blank><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>Feb 2, 2022</span></a></div><div><a class="flex align-center" href=https://github.com/dwmkerr/effective-shell/edit/master/website/content/docs/part-5-building-your-toolkit/customising-your-command-prompt/_index.md target=_blank><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"effective-shell"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><p>Copyright &copy; <script>document.write(new Date().getFullYear())</script>, Dave Kerr</p></div><aside class="book-toc levels-3 fixed"><nav id=TableOfContents><ul><li><a href=#chapter-25---customising-your-command-prompt>Chapter 25 - Customising Your Command Prompt</a></li><li><a href=#the-command-prompt--index-->The Command Prompt</a></li><li><a href=#customising-the-command-prompt>Customising the Command Prompt</a><ul><li><a href=#the-prompt-string>The Prompt String</a></li><li><a href=#special-characters>Special Characters</a></li><li><a href=#changing-the-colour-and-text-formatting>Changing the Colour and Text Formatting</a></li><li><a href=#adding-data-to-the-command-prompt>Adding Data to the Command Prompt</a></li></ul></li><li><a href=#a-shell-script-to-customise-the-prompt>A Shell Script to Customise the Prompt</a></li><li><a href=#additional-prompt-configuration>Additional Prompt Configuration</a></li><li><a href=#z-shell-and-oh-my-zsh>Z-Shell and Oh-My-Zsh</a></li><li><a href=#summary>Summary</a></li></ul></nav></aside></main></body></html>