<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Managing Remote Git Repositories and Sharing Your Dotfiles"><meta property="og:title" content="Managing Remote Git Repositories and Sharing Your Dotfiles"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://effective-shell.com/docs/part-5-building-your-toolkit/managing-remote-git-repositories/"><title>Managing Remote Git Repositories and Sharing Your Dotfiles | Effective Shell</title><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.f8520695a602b532b093067e25561bfe6fa10ca8c25171b97142acf58fa8f13c.css integrity="sha256-+FIGlaYCtTKwkwZ+JVYb/m+hDKjCUXG5cUKs9Y+o8Tw="><script defer src=/en.search.min.901d4b22032222a6f8db08efa32b2ce89f2b7affb9b504a133dbe52ece751a89.js integrity="sha256-kB1LIgMiIqb42wjvoyss6J8rev+5tQShM9vlLs51Gok="></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-155335600-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><link rel=alternate type=application/rss+xml href=https://effective-shell.com/docs/part-5-building-your-toolkit/managing-remote-git-repositories/index.xml title="Effective Shell"><script id=mcjs>!function(c,h,i,m,p){m=c.createElement(h),p=c.getElementsByTagName(h)[0],m.async=1,m.src=i,p.parentNode.insertBefore(m,p)}(document,"script","https://chimpstatic.com/mcjs-connected/js/users/eac1a082b6db34d40aaff2caf/a2aaca5a8358c2e12d3f43f1a.js");</script></head><body><input type=checkbox class=hidden id=menu-control><main class="flex container"><aside class="book-menu fixed"><nav><h2 class=book-brand><a href=https://effective-shell.com/><span>Effective Shell</span></a></h2><h2 class=book-subtitle><span>By Dave Kerr</span></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/docs/introduction/><strong>Introduction</strong></a></li><li><a href=/docs/getting-started/><strong>Getting Started</strong></a></li><li><a href=/docs/part-1-transitioning-to-the-shell/><strong>Part 1 - Transitioning to the Shell</strong></a><ul><li><a href=/docs/part-1-transitioning-to-the-shell/navigating-your-system/>Navigating Your System</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/managing-your-files/>Managing Your Files</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/clipboard-gymnastics/>Clipboard Gymnastics</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/getting-help/>Getting Help</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/the-renaissance-of-the-shell/>The Renaissance of the Shell</a></li></ul></li><li><a href=/docs/part-2-core-skills/><strong>Part 2 - Core Skills</strong></a><ul><li><a href=/docs/part-2-core-skills/thinking-in-pipelines/>Thinking in Pipelines</a></li><li><a href=/docs/part-2-core-skills/fly-on-the-command-line/>Fly on the Command Line</a></li><li><a href=/docs/part-2-core-skills/job-control/>Job Control</a></li><li><a href=/docs/part-2-core-skills/understanding-commands/>Understanding Commands</a></li><li><a href=/docs/part-2-core-skills/finding-files/>Finding Files</a></li><li><a href=/docs/part-2-core-skills/what-is-a-shell/>What is a Shell?</a></li></ul></li><li><a href=/docs/part-3-manipulating-text/><strong>Part 3 - Manipulating Text</strong></a><ul><li><a href=/docs/part-3-manipulating-text/regex-essentials/>Regex Essentials</a></li><li><a href=/docs/part-3-manipulating-text/get-to-grips-with-grep/>Get to Grips with Grep</a></li><li><a href=/docs/part-3-manipulating-text/slice-and-dice-text/>Slice and Dice Text</a></li><li><a href=/docs/part-3-manipulating-text/advanced-text-manipulation/>Advanced Text Manipulation with Sed</a></li><li><a href=/docs/part-3-manipulating-text/build-commands-on-the-fly/>Build Commands on the Fly with Xargs</a></li></ul></li><li><a href=/docs/part-4-shell-scripting/><strong>Part 4 - Shell Scripting</strong></a><ul><li><a href=/docs/part-4-shell-scripting/shell-script-essentials/>Shell Script Essentials</a></li><li><a href=/docs/part-4-shell-scripting/variables-reading-input-and-mathematics/>Variables, Reading Input, and Mathematics</a></li><li><a href=/docs/part-4-shell-scripting/mastering-conditional-logic/>Mastering Conditional Logic</a></li><li><a href=/docs/part-4-shell-scripting/loops-and-working-with-files-and-folders/>Loops and working with Files and Folders</a></li><li><a href=/docs/part-4-shell-scripting/functions-parameters-and-error-handling/>Functions, Parameters and Error Handling</a></li><li><a href=/docs/part-4-shell-scripting/useful-patterns-for-shell-scripts/>Useful Patterns for Shell Scripts</a></li></ul></li><li><a href=/docs/part-5-building-your-toolkit/><strong>Part 5 - Building Your Toolkit</strong></a><ul><li><a href=/docs/part-5-building-your-toolkit/configuring-the-shell/>Configuring the Shell</a></li><li><a href=/docs/part-5-building-your-toolkit/customising-your-command-prompt/>Customising Your Command Prompt</a></li><li><a href=/docs/part-5-building-your-toolkit/managing-your-dotfiles/>Managing Your Dotfiles</a></li><li><a href=/docs/part-5-building-your-toolkit/controlling-changes-with-git/>Controlling Changes with Git</a></li><li><a href=/docs/part-5-building-your-toolkit/managing-remote-git-repositories/ class=active>Managing Remote Git Repositories and Sharing Your Dotfiles</a></li></ul></li><li><a href=/docs/part-6-advanced-techniques/><strong>Part 6 - Advanced Techniques</strong></a><ul><li><a href=/docs/part-6-advanced-techniques/understanding-shell-expansion/>Understanding Shell Expansion</a></li></ul></li><li><a href=/docs/work-in-progress/><strong>Work in Progress</strong></a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class="flex align-center justify-between book-header"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Managing Remote Git Repositories and Sharing Your Dotfiles</strong></header><article class=markdown><h1 id=chapter-28---managing-remote-git-repositories-and-sharing-your-dotfiles>Chapter 28 - Managing Remote Git Repositories and Sharing Your Dotfiles</h1><p>In this chapter we'll take a look at how to take a local Git repository, like the one created in the previous chapter, and upload it to a remote repository.</p><p>We'll use the popular &ldquo;GitHub&rdquo; site to host our repository. We'll see how we can manage remote changes and use GitHub to share our dotfiles, so that we can quickly setup any machine with our personal configuration.</p><p>If you want to follow along with the code, copy the version of the &lsquo;dotfiles&rsquo; folder from the previous chapter to your home directory:</p><pre><code>cp -r ~/effective-shell/repositories/chapter-27-dotfiles ~/dotfiles
</code></pre><p>This folder contains the Git repository with the exact set of changes made in Chapter 27.</p><blockquote class="book-hint info"><p><strong>Downloading the Samples</strong></p><p>Run the following command in your shell to download the samples:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>curl effective.sh | sh
</code></pre></div></blockquote><h1 id=git-remotes>Git Remotes</h1><p>So far all of the changes we have made are stored in a <em>local</em> Git repository. The repository's files are stored on your local machine in a folder named <em>.git</em> in the location where you initialised the repository. A <em>remote</em> is a repository that is on another machine.</p><p>You can push and pull your changes to and from a remote repository as a way to back-up your repository. You can share this remote with other people so that they can collaborate on it, or download it to other machines you work on.</p><p>There are a number of services you can use that allow you to host public repositories (which can be seen by anyone) and private repositories (which have more restricted access).</p><p>To see how remotes work I will show how to create a repository using the popular <em>GitHub</em> service. GitHub is free for individuals and is an extremely popular Git provider and online collaboration platform.</p><p>To create a remote, you will first need to sign-up for a GitHub account. When you have done that you will be offered the option to create a repository:</p><p><img src=./images/github-what-do-you-want-to-do-first.png alt="Screenshot of the GitHub &ldquo;What do you want to do first&rdquo; page showing the &ldquo;Create a repository&rdquo; option"></p><p>Choose the &lsquo;Create a repository&rsquo; option. You will then be asked to provide a name for your repository. I'm going to use this repository to host my dotfiles, so I have chosen &ldquo;dotfiles&rdquo;:</p><p><img src=./images/github-create-new-repository.png alt="Screenshot of the GitHub Create Repository page"></p><p>If you don't want members of the public to be able to see your repository, choose the &lsquo;private&rsquo; option.</p><p>If you already have a local repository then <em>don't</em> check any of the boxes under &ldquo;Initialise this repository with&rdquo; - we want to create an empty repository which we will then &lsquo;push&rsquo; our changes to.</p><p>Once you have chosen the &ldquo;Create Repository&rdquo; option you will be shown some commands that you can use to configure your local repository to point to this newly created remote repository:</p><p><img src=./images/github-repository-setup.png alt="Screenshot of the repository setup page"></p><p>We already have a repository, so we will follow the instructions in the section &ldquo;&mldr;or push an existing repository from the command line&rdquo;. Copy the commands (there is a button that copies the command text to the clipboard) and run them in your shell, from the <em>~/dotfiles</em> folder:</p><pre><code>$ git remote add origin https://github.com/dwmkerr-effective-shell/dotfiles.git
$ git branch -M main
$ git push -u origin main

Username for 'https://github.com': dwmkerr+effective-shell@gmail.com
Password for 'https://dwmkerr+effective-shell@gmail.com@github.com':
Enumerating objects: 39, done.
Counting objects: 100% (39/39), done.
Delta compression using up to 16 threads
Compressing objects: 100% (36/36), done.
Writing objects: 100% (39/39), 12.83 KiB | 1.83 MiB/s, done.
Total 39 (delta 7), reused 0 (delta 0), pack-reused 0
remote: Resolving deltas: 100% (7/7), done.
To https://github.com/dwmkerr-effective-shell/dotfiles.git
 * [new branch]      main -&gt; main
Branch 'main' set up to track remote branch 'main' from 'origin'.
</code></pre><p>When you run the third command (the one that starts with <code>git push</code>) you will be asked for your username and password. Once you enter them your local changes will be &lsquo;pushed&rsquo; to the remote repository.</p><blockquote class="book-hint warning"><p><strong>Avoid Using Passwords</strong></p><p>To keep this example simple I have authenticated with a username and password. However, I would strongly recommend that as soon as possible you set up an SSH key to authenticate with GitHub. SSH keys are far more secure than usernames and passwords.</p><p>GitHub have an excellent guide on how to setup SSH keys at:</p><p><a href=https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh>https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh</a></p><p>I also describe how to setup SSH keys in the chapter <a href=/docs/work-in-progress/>The Secure Shell</a>.</p></blockquote><p>Let's look at each command in detail.</p><ul><li><code>git remote add origin https://github.com/dwmkerr-effective-shell/dotfiles.git</code> first we tell Git that we would like to add a new &lsquo;remote&rsquo; called <em>origin</em> and we provide its address. The remote in this case is the repository we created in GitHub.</li><li><code>git branch -M main</code> now we rename our current branch to <em>main</em> - because our current branch is already called <em>main</em> this shows no output as nothing has changed.</li><li><code>git push -u origin main</code> finally, we &lsquo;push&rsquo; our <em>main</em> branch to the <em>remote</em> named <em>origin</em>. The <code>-u</code> flag is used to track changes - we'll see what this means shortly.</li></ul><p>At this stage if you refresh your browser you'll see your <em>dotfiles</em> repository, with all of our changes we've made so far!</p><p><img src=./images/github-dotfiles-initial-view.png alt="Screenshot showing the initial view of the Dotfiles repository"></p><p>Each of the files and folders we have created is shown, we can view any of the files, look at the commit history, see the log messages and more.</p><p>Before you make too many changes, we'll cover three important commands you need to be aware of when working with remotes - <code>git push</code>, <code>git fetch</code> and <code>git pull</code>.</p><h2 id=the-git-push-command-and-remotes>The Git Push Command and Remotes</h2><p>We've already used the <code>git push</code> command once. This command pushes the changes we have made locally to a remote. It is a common convention to call the primary remote that you work with <em>origin</em> - but you can use any name you want. You can also have multiple remotes. For example, you could sign up with <em>GitLab</em>, another Git services provider, create a repository with their service and add that as a remote and call it <em>gitlab</em>.</p><p>You can show your remotes with the <code>git remote</code> (<em>managed remote repositories</em>) command. If we run the command with the <code>-v</code> (<em>verbose</em>) parameter each remote will be shown, along with the address used when we push changes, as well as the address used when we &lsquo;fetch&rsquo; changes (which we'll look at next):</p><pre><code>$ git remote -v
origin  https://github.com/dwmkerr-effective-shell/dotfiles.git (fetch)
origin  https://github.com/dwmkerr-effective-shell/dotfiles.git (push)
</code></pre><p>The command we used to push our changes was:</p><pre><code>$ git push -u origin main
</code></pre><p>The <code>-u</code> (<em>set upstream</em>) option tells Git that we want to associate our local <em>main</em> branch with the remote <em>main</em> branch. This means that we don't need to specify the remote name for each subsequent <code>git push</code> command - Git knows that our &lsquo;upstream&rsquo; branch that we push to is called <em>main</em> and is in the <em>origin</em> remote.</p><h2 id=the-git-fetch-command>The Git Fetch Command</h2><p>The <code>git fetch</code> (<em>get remote changes</em>) command downloads all of the information about the changes that have been made to the remote.</p><p>This command does <em>not</em> download the actual changes to your working tree! All it does is download the information about the changes. To see what I mean, let's run the fetch command:</p><pre><code>$ git fetch
</code></pre><p>There will be no output - the remote has not changed. Let's make a change to the remote so we can see how fetch works. Open the repository in the GitHub website. There's a message saying that we should add a &lsquo;README&rsquo; file:</p><p><img src=./images/github-dotfiles-initial-view.png alt="Screenshot showing the &lsquo;create readme&rsquo; file instructions"></p><p>Press the &ldquo;Add a README&rdquo; button and add a description of your project. By convention, the file named <code>README.md</code> in a repository is shown on the home page of the project online and typically should include instructions on how to use the repository. This is a plain text file, you can use a plain text styling language called &ldquo;Markdown&rdquo; to show headings, bullets, code samples and so on (search for &ldquo;GitHub Flavored Markdown&rdquo; to find out about the syntax):</p><p><img src=./images/github-add-readme-contents.png alt="Screenshot of the README.md file content"></p><p>Once you are happy with the content (you can choose &lsquo;Preview&rsquo; to see how it will look) scroll down to the &ldquo;Commit&rdquo; button. Provide a commit message:</p><p><img src=./images/github-readme-commit.png alt="Screenshot of the GitHub README commit page"></p><p>Once you have pressed &ldquo;Commit New File&rdquo; you will be taken back to the repository page. The contents of the <em>README.md</em> file will be shown:</p><p><img src=./images/github-dotfiles-repository-with-readme.png alt="Screenshot of the dotfiles repository homepage"></p><p>We have now created a commit on the <em>origin</em> remote. Now when we run <code>git fetch</code> we will see that the remote has changed:</p><pre><code>$ git fetch
remote: Enumerating objects: 4, done.
remote: Counting objects: 100% (4/4), done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
Unpacking objects: 100% (3/3), 962 bytes | 240.00 KiB/s, done.
From https://github.com/dwmkerr-effective-shell/dotfiles
   2532277..4a28994  main       -&gt; origin/main
</code></pre><p>When we run <code>git fetch</code>, Git looks at the <em>upstream</em> associated with the current branch and checks to see if there are any changes. The information about any changes is downloaded - but the changes themselves are not yet downloaded. If you run <code>git log</code> you will <em>not</em> see the new commit that includes the <em>README.md</em> file - we have not checked out this commit yet.</p><p>At the moment, our repository looks like this:</p><p><img src=./images/git-local-and-upstream-main-branch.png alt="Diagram of our local main and upstream main branch"></p><ul><li>The local branch HEAD is exactly where it was before we ran <code>git fetch</code></li><li>Because we have run <code>git fetch</code>, Git knows that our <em>upstream</em> has changed - in fact it even told us what the changes are, the message includes the text <code>2532277..4a28994 main -> origin/main</code> which means &lsquo;new commits from <code>2532277</code> to <code>4a28994</code> have been fetched for <code>main</code> which tracks <code>origin/main</code></li></ul><p>To actually download this (and any other) new commit we will need to run the <code>git pull</code> command.</p><h2 id=the-git-pull-command>The Git Pull Command</h2><p>The <code>git pull</code> (<em>download from remote</em>) command integrates the changes from a remote into the current branch. Because we've already told Git what the &lsquo;upstream&rsquo; for the <em>main</em> branch is, we can just run the <code>git pull</code> command to move to the latest commit:</p><pre><code>$ git pull
Updating 2532277..4a28994
Fast-forward
 README.md | 13 +++++++++++++
 1 file changed, 13 insertions(+)
 create mode 100644 README.md
</code></pre><p>The <code>git pull</code> command tells us what commit we have moved from and to, and gives a summary of the files that have changed. We can see that a file named <code>README</code> has been created - if you look at your local files you'll see <em>README.md</em> is now present:</p><pre><code>$ ls
README.md  install.sh  shell.d  shell.sh
</code></pre><p>Finally, if we run <code>git log --graph --oneline</code> we can see that our <em>HEAD</em> is at the tip of the <code>main</code> branch, and that this is also the tip of the <code>origin</code> remote's <em>main</em> branch:</p><pre><code>$ git log --graph --oneline
* 4a28994 (HEAD -&gt; main, origin/main) add a simple 'README' file
*   2532277 Merge branch 'glog_alias'
|\
| * a8cbb15 (glog_alias) add the 'glog' alias
* | 31548e4 add the 'glog' alias
|/
*   138b404 Merge branch 'more_aliases'
|\
| * a51ae1a (more_aliases) add a file to store 'zsh' aliases
| * 63ea74f add a file to store 'bash' aliases
* | a95bd90 add the 'gm' alias for 'git merge'
|/
* b9ae0ad (aliases) add alias 'gcm' for 'git checkout main'
* f61369d (more_changes) add alias 'gs' for 'git status'
* d7e1bb9 add the 'shell.d' folder
* 01e7a10 add the 'install' and 'shell' scripts
</code></pre><p>Congratulations - you have now created a local repository, staged and unstaged changes to and from the index, created commits, created branches, handled merging and merge conflicts and even learnt how to setup a remote and push and pull changes from it!</p><p>You can pull any branch into your current branch - just provide the name of a remote and the name of a branch:</p><pre><code>git pull &lt;remote_name&gt; &lt;branch_name&gt;
</code></pre><p>If you don't provide any parameters to <code>git pull</code> it will pull from the &lsquo;upstream&rsquo; branch. But you can also use Git pull to merge other branches into your current branch.</p><h1 id=sharing-your-dotfiles>Sharing Your Dotfiles</h1><p>If you have been following through with these examples, you will now have a &lsquo;dotfiles&rsquo; repository available on your GitHub account. You can make this repository public and allow people to copy your code or propose changes.</p><p>If you want to clone your &lsquo;dotfiles&rsquo; repository onto another machine, you can do so with this one-line command:</p><pre><code>git clone git://github.com/&lt;your_user_name&gt;/dotfiles.git
</code></pre><p>The <code>git clone</code> (<em>download a repository</em>) command downloads the repository into the current folder. If your repository is private you will have to authenticate to be able to do this, but if your repository is public then you (or anyone else) can download your dotfiles.</p><p>Hosting your dotfiles on GitHub is a very convenient way of making your dotfiles accessible anywhere. With a single command you can download them to any machine, and then run the <em>install.sh</em> script from the dotfiles folder to setup the shell startup files.</p><p>If you search online for &lsquo;dotfiles&rsquo;, you will find many articles and users who have shared their dotfiles online, you can look over these for inspiration!</p><h1 id=forking-and-pull-requests>Forking and Pull Requests</h1><p>Forking and Pull Requests are features offered by popular Git hosting services like GitHub, BitBucket and GitLab. They are not actually Git features, but have become so widely used that you are likely to come across the terminology when working with online Git repositories.</p><p>A <em>fork</em> is a copy of a Git repository. Typically you will fork a repository if you want to take a copy of someone else's code and work on it yourself.</p><p>I have created a simple dotfiles repository on GitHub that you can use as a starting point for your own dotfile configuration. Let's use this to see how forking works.</p><p>First, we open up the GitHub project that we'd like to fork, which in this case is at <a href=https://github.com/effective-shell/dotfiles>www.github.com/effective-shell/dotfiles</a>. Notice that there is a &lsquo;Fork&rsquo; option on the top-right of the screen:</p><p><img src=./images/effective-shell-dotfiles-showing-fork.png alt="Screenshot of the effective-shell/dotfiles repository with the fork option shown"></p><p>Choose the &lsquo;fork&rsquo; option and GitHub will create a copy of the repository in your own account. You can now clone this repository, make changes and work on it as if it was your own. The original repository is tracked by GitHub, meaning that you can update from it at any time.</p><p>If you have made changes to a fork, you can then open a <em>Pull Request</em>. A pull request is a request to merge a set of changes from one branch into another, or from one fork into the original repository. So if you were to improve upon the dotfiles that you forked, and wanted to share your changes back, you could open a pull request to do so.</p><p>Typically when a pull request is opened, the project maintainer will then review the changes, make suggestions or discuss the proposal, and then either merge the pull request or reject it. In the screenshot below I am opening a pull request from my clone of the dorfile repository to the original dotfiles repository, this pull requests adds an uninstall script to the repository. A maintainer of the target repository will then review the changes:</p><p><img src=./images/github-open-pull-request.png alt="Screenshot of a pull request being opened"></p><p>This model of forking and pull requests is really just a nice user interface on top of the underlying capabilities Git has to track remotes and manage branches. Services like GitHub offer functionality to discuss changes, run arbitrary pipelines project maintainers might create to test the code and so on.</p><p>GitHub has become a remarkably popular site for people to collaborate on projects together. At the time of writing the <code>microsoft/vscode</code> repository, which is the popular Visual Studio Code open-source editor, has had contributions from more than 19,000 individual contributors!</p><h1 id=a-script-to-open-a-pull-request>A Script to Open a Pull Request</h1><p>When you push a branch to a remote on GitHub, GitLab, BitBucket and a number of other Git services providers, a message is shown in the command prompt with a link to open a Pull Request:</p><pre><code>$ git push -u origin fix/fix-shell-configuration
...
remote:
remote: Create a pull request for 'fix/fix-shell-configuration' on GitHub by visiting:
remote:      https://github.com/dwmkerr/dotfiles/pull/new/fix/fix-shell-configuration
...
</code></pre><p>We can write a shell function that runs the <code>git push</code> command, reads its output, and then if it finds a web address, open it in a browser. In fact, the dotfiles repository at <a href=https://github.com/effective-shell/dotfiles>github.com/effective-shell/dotfiles</a> has exactly this function - just run the command <code>gpr</code> to open a pull request!</p><p>This function is actually quite straightforward - the code for it is below (with some of the comments and code to colour the output removed for legibility):</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>gpr<span style=color:#f92672>(</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#75715e># Get the current branch name, or use &#39;HEAD&#39; if we cannot get it.</span>
    branch<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>git symbolic-ref -q HEAD<span style=color:#66d9ef>)</span>
    branch<span style=color:#f92672>=</span><span style=color:#e6db74>${</span>branch##refs/heads/<span style=color:#e6db74>}</span>
    branch<span style=color:#f92672>=</span><span style=color:#e6db74>${</span>branch<span style=color:#66d9ef>:-</span>HEAD<span style=color:#e6db74>}</span>

    <span style=color:#75715e># Pushing take a little while, so let the user know we&#39;re working.</span>
    printf <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Opening pull request for </span><span style=color:#e6db74>${</span>branch<span style=color:#e6db74>}</span><span style=color:#e6db74>...\n</span><span style=color:#e6db74>&#34;</span>

    <span style=color:#75715e># Push to origin, grabbing the output but then echoing it back.</span>
    push_output<span style=color:#f92672>=</span><span style=color:#e6db74>`</span>git push origin -u <span style=color:#e6db74>${</span>branch<span style=color:#e6db74>}</span> 2&gt;&amp;1<span style=color:#e6db74>`</span>
    printf <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>\n</span><span style=color:#e6db74>${</span>push_output<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>

    <span style=color:#75715e># If there&#39;s anything which starts with http, it&#39;s a good guess it&#39;ll be a</span>
    <span style=color:#75715e># link to GitHub/GitLab/Whatever. So open the first link found.</span>
    link<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>echo <span style=color:#e6db74>${</span>push_output<span style=color:#e6db74>}</span> | grep -o <span style=color:#e6db74>&#39;http.*&#39;</span> | head -n1 | sed -e <span style=color:#e6db74>&#39;s/[[:space:]]*$//&#39;</span><span style=color:#66d9ef>)</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>${</span>link<span style=color:#e6db74>}</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
        printf <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>\nOpening: </span><span style=color:#e6db74>${</span>GREEN<span style=color:#e6db74>}</span><span style=color:#e6db74>${</span>link<span style=color:#e6db74>}</span><span style=color:#e6db74>${</span>RESET<span style=color:#e6db74>}</span><span style=color:#e6db74>...</span><span style=color:#e6db74>&#34;</span>
        python -mwebbrowser <span style=color:#e6db74>${</span>link<span style=color:#e6db74>}</span>
    <span style=color:#66d9ef>fi</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>This snippet first gets the name of the current branch, or <code>HEAD</code> if we cannot work the name out. When then run the <code>git push origin</code> command, and record the output of the command into a variable.</p><p>Once the push command has completed, we write its output to the screen, and search for the first hyperlink, using <code>grep</code> and <code>sed</code>, then use <code>python</code> to open the link in a browser.</p><p>I use the <code>gpr</code> function many times per day and it has been a real time-saver!</p><h1 id=showing-git-information-in-the-command-prompt>Showing Git Information in the Command Prompt</h1><p>In <a href=/docs/part-5-building-your-toolkit/customising-your-command-prompt/>Chapter 26 - Customising Your Command Prompt</a> we saw how to customise the command prompt by setting the <code>PS1</code> variable. As you start using Git more you might find it convenient to show some information about the repository in your prompt.</p><p>As an example, while I am writing this chapter, my command prompt looks like this:</p><pre><code>github/dwmkerr/effective-shell feat/managing-git-remotes ! 1 in stash
$
</code></pre><p>This is easier to see in the screenshot below as it shows the colour:</p><p><img src=./images/ps1-with-git-information.png alt="Screenshot showing my PS1 line in with Git information in colour"></p><p>I spread my prompt over two lines and leave the prompt indicator as the only thing on the line where I type. This means my cursor does not become too indented. My command prompt shows the following information:</p><table><thead><tr><th>Content</th><th>Description</th></tr></thead><tbody><tr><td><code>github/dwmkerr/effective-shell</code></td><td>My current folder, and up to two parent folders.</td></tr><tr><td><code>feat/managing-git-remotes</code></td><td>My current Git branch, if I am in a Git repository.</td></tr><tr><td><code>!</code></td><td>A red exclamation mark is shown if I have uncommitted changes.</td></tr><tr><td><code>1 in stash</code></td><td>If I have anything in my Git stash, a message is shown in amber.</td></tr></tbody></table><p>You can try out this style of command prompt by calling the <code>set_ps1</code> function:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>source ~/dotfiles/shell.d/set_ps1.sh
set_ps1 dwmkerr
</code></pre></div><p>If you want to change back to your previous prompt, just run <code>set_ps1</code> again without any parameters.</p><p>If you are interested in showing Git information in your command prompt you can take a look at the <code>set_ps1.sh</code> file to see the full details. We'll take a look at a snippet as it is interesting to see how to get this Git information.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>_git_info<span style=color:#f92672>(</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#75715e># Don&#39;t write anything if we&#39;re not in a folder tracked by git.</span>
    <span style=color:#66d9ef>if</span> ! <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>git rev-parse --is-inside-work-tree 2&gt;/dev/null<span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>=</span><span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;true&#34;</span> <span style=color:#f92672>]</span>
    <span style=color:#66d9ef>then</span>
        <span style=color:#66d9ef>return</span>
    <span style=color:#66d9ef>fi</span>

    <span style=color:#75715e># Get the branch name, changes, and number of stashes.</span>
    local git_branch_name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>git branch --show-current<span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span>
    local git_any_local_changes<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>git status --porcelain<span style=color:#f92672>=</span>v1 2&gt;/dev/null<span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span>
    local git_stash_count<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>git rev-list --walk-reflogs --count <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>        refs/stash -- 2&gt;/dev/null<span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span> <span style=color:#75715e># Ignore error when no stashes</span>
    local git_info<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>git_branch_name<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;main&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
        git_info<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>fg_green<span style=color:#e6db74>}</span><span style=color:#e6db74>${</span>start_underline<span style=color:#e6db74>}</span><span style=color:#e6db74>${</span>git_branch_name<span style=color:#e6db74>}</span><span style=color:#e6db74>${</span>reset<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
    <span style=color:#66d9ef>else</span>
        git_info<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>fg_green<span style=color:#e6db74>}</span><span style=color:#e6db74>${</span>git_branch_name<span style=color:#e6db74>}</span><span style=color:#e6db74>${</span>reset<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
    <span style=color:#66d9ef>fi</span>
    <span style=color:#66d9ef>if</span> ! <span style=color:#f92672>[</span> -z <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>git_any_local_changes<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
        <span style=color:#75715e># Note that we have to be careful to put the exclamation mark</span>
        <span style=color:#75715e># in single quotes so that it is not expanded to the last command!</span>
        git_info<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>git_info<span style=color:#e6db74>}</span><span style=color:#e6db74> </span><span style=color:#e6db74>${</span>fg_red<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>&#39;!&#39;</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>reset<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
    <span style=color:#66d9ef>fi</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>git_stash_count<span style=color:#66d9ef>:-</span>0<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> -gt <span style=color:#ae81ff>0</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
        git_info<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>git_info<span style=color:#e6db74>}</span><span style=color:#e6db74> </span><span style=color:#e6db74>${</span>fg_yellow<span style=color:#e6db74>}</span><span style=color:#e6db74>${</span>git_stash_count<span style=color:#e6db74>}</span><span style=color:#e6db74> in stash</span><span style=color:#e6db74>${</span>reset<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
    <span style=color:#66d9ef>fi</span>
    printf <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>git_info<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>This script does the following:</p><ul><li>The <code>git rev-parse</code> is used to check whether we are in a folder that is part of a Git working tree. If we are not in a Git working tree, we don't show anything.</li><li>Get the current branch name with <code>git branch --show-current</code>).</li><li>Check to see if there are any changes by looking at <code>git status</code>. The <code>--porcelain=v1</code> line ensures that the status is machine-readable (this is easier to work with when scripting).</li><li>Check the number of &lsquo;stash&rsquo; revisions. Don't worry about stashes for now or the <code>git rev-list</code> command - these are more advanced features.</li></ul><p>The rest of the script is formatting only - underlining the branch name if it is the <em>main</em> branch, showing the exclamation mark if we have changes and so on.</p><p>You can take the script as a starting point for your own customisations for the command prompt if you will be using Git a lot!</p><h1 id=scratching-the-surface>Scratching the Surface</h1><p>We have only seen the absolute basics of Git in this chapter. Git is an amazingly powerful tool, I cannot recommend enough that you take the time to really learn how the commands work.</p><p>Many users will use a graphical tool to work with Git - this is perfectly fine if it works for you. But to be an <em>effective shell</em> user you should really spend the time getting familiar with the core Git commands using the command-line.</p><p>Git can sometimes seem overwhelming to people and has a reputation for being complex. This is somewhat unfair - version control of files is itself an inherently complex topic. No matter what tool you use, there will always be the challenges of managing changes across environments, dealing with conflicts, integrating work and so on. The basic Git functionality is <em>incredibly</em> good at making 99% of this work simple and straightforward, and Git gives you the tools to make the other 1% at least manageable.</p><p>Spend some time getting familiar with the core Git commands that we have introduced in this chapter. As you find yourself becoming more familiar, here are the next set of topics I would recommend learning about:</p><ul><li>The <code>gitignore</code> file: this special file can be used to tell Git not to track changes for certain files.</li><li>The <code>.gitconfig</code> file: this is Git's own dotfile and can be used to fine-tune Git configuration.</li><li>Tags: these are labels you can add to commits, which are ideal for tracking releases for projects or other metadata.</li><li>Diffs: knowing how to use <code>git diff</code> to see changes between branches, commits, the index and working tree and more will certainly help you as you use Git more.</li><li>Stashes: If you want to save your changes, but they are currently not ready to be committed (perhaps because they are only partially complete), you can use the <code>git stash</code> command to store working tree changes. This lets you store the changes away, then checkout other branches, then restore the changes later when you are ready.</li><li>Git Clean: The <code>git clean</code> command is very useful to help you remove unneeded files from your working tree.</li><li>Interactive Staging: You can interactively stage files, parts of files (called &lsquo;hunks&rsquo;) or even individual lines directly from the shell, this can be invaluable when making sure that exactly the right changes are going into the index.</li><li>Patch staging or checkout: I probably use the <code>git add -p</code> command to &lsquo;patch&rsquo; changes dozens of times a day, this is my preferred mechanism of reviewing my changes as I stage them.</li><li>Merge Strategies: Understanding how &lsquo;squashing&rsquo; works (and its drawbacks) can be very useful when working with branches. Merge strategies are a useful topic to go deeper on.</li><li>Rebasing: Rebasing can be used as a merge strategy but can also help in other scenarios, I would definitely recommend learning about rebasing if you have multiple people working on a repository, it can save a lot of trouble when integrating complex changes.</li><li>Commit and Tag signing: Great for security sensitive users, you can use special keys to &lsquo;sign&rsquo; your commits and improve the security of your repositories.</li><li><a href=https://guides.github.com/introduction/flow/>GitHub Flow</a>: A common workflow used with GitHub projects.</li></ul><p>There are numerous articles and online books on Git - I also recommend the excellent book &ldquo;Pro Git&rdquo; by Scott Chacon and Ben Straub.</p><h1 id=an-overview-of-the-git-commands>An Overview of the Git Commands</h1><p>Before we finish the chapter, let's do a quick review of the key commands for working with Git. You can refer to the illustration below:</p><p><img src=./images/git-commands-summary.png alt="Diagram showing a summary of the key commands"></p><p>As a reminder, the core concepts are:</p><table><thead><tr><th>Concept</th><th>Description</th></tr></thead><tbody><tr><td>The Working Tree</td><td>The folder you are working in and tracking change to.</td></tr><tr><td>The Index</td><td>The &lsquo;staging&rsquo; area for building commits.</td></tr><tr><td>The Repository</td><td>The full set of all commits, branches and metadata.</td></tr><tr><td>A Fork</td><td>A copy of an entire repository, including its history and all branches.</td></tr><tr><td>A Pull Request</td><td>A proposal to merge one branch into another, or a branch in a fork to the upstream.</td></tr><tr><td><code>git init</code></td><td>Creates a local repository.</td></tr><tr><td><code>git clone</code></td><td>Downloads a remote repository.</td></tr><tr><td><code>git add</code></td><td>Stage a change from the working tree to the index.</td></tr><tr><td><code>git reset</code></td><td>Unstage a change from the index.</td></tr><tr><td><code>git commit</code></td><td>Create a new commit.</td></tr><tr><td><code>git checkout -b</code></td><td>Create a new branch.</td></tr><tr><td><code>git merge</code></td><td>Merge a branch into the current branch.</td></tr><tr><td><code>git checkout</code></td><td>Move the current HEAD to a new branch or commit.</td></tr><tr><td><code>git push</code></td><td>Push changes to an upstream branch.</td></tr><tr><td><code>git fetch</code></td><td>Retrieve information about changes to a remote.</td></tr><tr><td><code>git pull</code></td><td>Download and merge changes from a remote.</td></tr></tbody></table><h1 id=summary>Summary</h1><p>In this chapter we learned how to use GitHub to host a remote repository, how to push, fetch and pull changes, and how remotes work. We also looked at pull requests, forks, how to show Git information on the command line, and some of the more advanced topics that you might want to explore as you use Git more.</p><p>Although we've only scratched the surface of what Git can do, you should now have the tools to work with repositories, share content like your dotfiles, collaborate with others and manage your own changes.</p><p>In the next part of the book we will look at some advanced techniques that can help you as a shell user.</p></article><div class="book-footer justify-between"><div><a class="flex align-center" href=https://github.com/dwmkerr/effective-shell/commit/f5b1f3130544dfd22ca3334634a3464c80be86c5 title="Last modified by Dave Kerr | Jan 15, 2022" target=_blank><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>Jan 15, 2022</span></a></div><div><a class="flex align-center" href=https://github.com/dwmkerr/effective-shell/edit/master/website/content/docs/part-5-building-your-toolkit/managing-remote-git-repositories/_index.md target=_blank><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"effective-shell"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><p>Copyright &copy; <script>document.write(new Date().getFullYear())</script>, Dave Kerr</p></div><aside class="book-toc levels-3 fixed"><nav id=TableOfContents><ul><li><a href=#chapter-28---managing-remote-git-repositories-and-sharing-your-dotfiles>Chapter 28 - Managing Remote Git Repositories and Sharing Your Dotfiles</a></li><li><a href=#git-remotes>Git Remotes</a><ul><li><a href=#the-git-push-command-and-remotes>The Git Push Command and Remotes</a></li><li><a href=#the-git-fetch-command>The Git Fetch Command</a></li><li><a href=#the-git-pull-command>The Git Pull Command</a></li></ul></li><li><a href=#sharing-your-dotfiles>Sharing Your Dotfiles</a></li><li><a href=#forking-and-pull-requests>Forking and Pull Requests</a></li><li><a href=#a-script-to-open-a-pull-request>A Script to Open a Pull Request</a></li><li><a href=#showing-git-information-in-the-command-prompt>Showing Git Information in the Command Prompt</a></li><li><a href=#scratching-the-surface>Scratching the Surface</a></li><li><a href=#an-overview-of-the-git-commands>An Overview of the Git Commands</a></li><li><a href=#summary>Summary</a></li></ul></nav></aside></main></body></html>