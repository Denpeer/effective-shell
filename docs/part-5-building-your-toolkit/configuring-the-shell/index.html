<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Configuring the Shell"><meta property="og:title" content="Configuring the Shell"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://effective-shell.com/docs/part-5-building-your-toolkit/configuring-the-shell/"><title>Configuring the Shell | Effective Shell</title><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.f8520695a602b532b093067e25561bfe6fa10ca8c25171b97142acf58fa8f13c.css integrity="sha256-+FIGlaYCtTKwkwZ+JVYb/m+hDKjCUXG5cUKs9Y+o8Tw="><script defer src=/en.search.min.901d4b22032222a6f8db08efa32b2ce89f2b7affb9b504a133dbe52ece751a89.js integrity="sha256-kB1LIgMiIqb42wjvoyss6J8rev+5tQShM9vlLs51Gok="></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-155335600-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><link rel=alternate type=application/rss+xml href=https://effective-shell.com/docs/part-5-building-your-toolkit/configuring-the-shell/index.xml title="Effective Shell"><script id=mcjs>!function(c,h,i,m,p){m=c.createElement(h),p=c.getElementsByTagName(h)[0],m.async=1,m.src=i,p.parentNode.insertBefore(m,p)}(document,"script","https://chimpstatic.com/mcjs-connected/js/users/eac1a082b6db34d40aaff2caf/a2aaca5a8358c2e12d3f43f1a.js");</script></head><body><input type=checkbox class=hidden id=menu-control><main class="flex container"><aside class="book-menu fixed"><nav><h2 class=book-brand><a href=https://effective-shell.com/><span>Effective Shell</span></a></h2><h2 class=book-subtitle><span>By Dave Kerr</span></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/docs/introduction/><strong>Introduction</strong></a></li><li><a href=/docs/getting-started/><strong>Getting Started</strong></a></li><li><a href=/docs/part-1-transitioning-to-the-shell/><strong>Part 1 - Transitioning to the Shell</strong></a><ul><li><a href=/docs/part-1-transitioning-to-the-shell/navigating-your-system/>Navigating Your System</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/managing-your-files/>Managing Your Files</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/clipboard-gymnastics/>Clipboard Gymnastics</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/getting-help/>Getting Help</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/the-renaissance-of-the-shell/>The Renaissance of the Shell</a></li></ul></li><li><a href=/docs/part-2-core-skills/><strong>Part 2 - Core Skills</strong></a><ul><li><a href=/docs/part-2-core-skills/thinking-in-pipelines/>Thinking in Pipelines</a></li><li><a href=/docs/part-2-core-skills/fly-on-the-command-line/>Fly on the Command Line</a></li><li><a href=/docs/part-2-core-skills/job-control/>Job Control</a></li><li><a href=/docs/part-2-core-skills/understanding-commands/>Understanding Commands</a></li><li><a href=/docs/part-2-core-skills/finding-files/>Finding Files</a></li><li><a href=/docs/part-2-core-skills/what-is-a-shell/>What is a Shell?</a></li></ul></li><li><a href=/docs/part-3-manipulating-text/><strong>Part 3 - Manipulating Text</strong></a><ul><li><a href=/docs/part-3-manipulating-text/regex-essentials/>Regex Essentials</a></li><li><a href=/docs/part-3-manipulating-text/get-to-grips-with-grep/>Get to Grips with Grep</a></li><li><a href=/docs/part-3-manipulating-text/slice-and-dice-text/>Slice and Dice Text</a></li><li><a href=/docs/part-3-manipulating-text/advanced-text-manipulation/>Advanced Text Manipulation with Sed</a></li><li><a href=/docs/part-3-manipulating-text/build-commands-on-the-fly/>Build Commands on the Fly with Xargs</a></li></ul></li><li><a href=/docs/part-4-shell-scripting/><strong>Part 4 - Shell Scripting</strong></a><ul><li><a href=/docs/part-4-shell-scripting/shell-script-essentials/>Shell Script Essentials</a></li><li><a href=/docs/part-4-shell-scripting/variables-reading-input-and-mathematics/>Variables, Reading Input, and Mathematics</a></li><li><a href=/docs/part-4-shell-scripting/mastering-conditional-logic/>Mastering Conditional Logic</a></li><li><a href=/docs/part-4-shell-scripting/loops-and-working-with-files-and-folders/>Loops and working with Files and Folders</a></li><li><a href=/docs/part-4-shell-scripting/functions-parameters-and-error-handling/>Functions, Parameters and Error Handling</a></li><li><a href=/docs/part-4-shell-scripting/useful-patterns-for-shell-scripts/>Useful Patterns for Shell Scripts</a></li></ul></li><li><a href=/docs/part-5-building-your-toolkit/><strong>Part 5 - Building Your Toolkit</strong></a><ul><li><a href=/docs/part-5-building-your-toolkit/configuring-the-shell/ class=active>Configuring the Shell</a></li><li><a href=/docs/part-5-building-your-toolkit/customising-your-command-prompt/>Customising Your Command Prompt</a></li><li><a href=/docs/part-5-building-your-toolkit/managing-your-dotfiles/>Managing Your Dotfiles</a></li><li><a href=/docs/part-5-building-your-toolkit/controlling-changes-with-git/>Controlling Changes with Git</a></li><li><a href=/docs/part-5-building-your-toolkit/managing-remote-git-repositories/>Managing Remote Git Repositories and Sharing Your Dotfiles</a></li></ul></li><li><a href=/docs/part-6-advanced-techniques/><strong>Part 6 - Advanced Techniques</strong></a><ul><li><a href=/docs/part-6-advanced-techniques/understanding-shell-expansion/>Understanding Shell Expansion</a></li></ul></li><li><a href=/docs/work-in-progress/><strong>Work in Progress</strong></a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class="flex align-center justify-between book-header"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Configuring the Shell</strong></header><article class=markdown><h1 id=chapter-24---configuring-the-shell>Chapter 24 - Configuring the Shell</h1><p>There are a number of different ways to configure your shell. In this chapter we'll take a look at the different configuration files for the shell and how they work, and how you can change your shell configuration with options.</p><h1 id=the-shell-configuration-file>The Shell Configuration File</h1><p>There are a number of different files that the shell uses for configuration, and we're going to see all of them in this chapter. However, the file we will use most often is the <em>~/.bashrc</em> file.</p><p>When you log into a machine using the shell, or start a shell program in a terminal emulator like the Gnome Terminal or Konsole, you are running an <em>interactive shell</em>. An interactive shell is one that is connected to your keyboard and screen.</p><p>When an interactive shell starts, one of the operations it performs is to run all of the commands in the file <em>~/.bashrc</em>. This is one of the &lsquo;shell startup&rsquo; files.</p><p>The &lsquo;RC&rsquo; in the file name stands for &lsquo;run commands&rsquo; (sometimes people will also refer to this as &lsquo;run configuration&rsquo;). This is a convention from the early days of Unix. Many tools on Unix and Linux have files that end in &lsquo;rc&rsquo; that are loaded when a program starts up. For example, the <em>~/.vimrc</em> run commands file is loaded by the <code>vim</code> program when it starts.</p><p>The <em>~/.bashrc</em> file is in your home directory - this means that it is your personal Bash configuration file. There is also a file that is normally at <em>/etc/bash.bashrc</em> that is used to configure Bash for all users.</p><p>Again - this is a common convention for Unix and Linux systems - there is a &lsquo;global&rsquo; configuration file that is used for all users, as well as a &lsquo;user&rsquo; configuration file in the user's home directory that the user can edit to personalise things for themselves.</p><blockquote class="book-hint info"><strong>Z-Shell</strong>
The <code>zsh</code> shell uses a <em>~/.zshrc</em> file for per-user configuration and <em>/etc/zsh/zshrc</em> for global configuration. The paths are different but the concepts are the same. Other shells may use different paths as well - you should be able to find the paths in their manual pages.</blockquote><h2 id=the-default-configuration-file>The Default Configuration File</h2><p>Let's take a look at some of the commands that are in the <em>~/.bashrc</em> on a clean Ubuntu 20 installation (if you want to know how to set up a free Ubuntu 20 machine check <a href=/docs/work-in-progress/>Appendix - Setting Up a Linux Virtual Machine</a>.</p><p>I've omitted parts of the file in the snippet below, we'll focus on some of the most interesting areas.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># If not running interactively, don&#39;t do anything</span>
<span style=color:#66d9ef>case</span> $- in
    *i*<span style=color:#f92672>)</span> ;;
      *<span style=color:#f92672>)</span> <span style=color:#66d9ef>return</span>;;
<span style=color:#66d9ef>esac</span>

<span style=color:#75715e># don&#39;t put duplicate lines or lines starting with space in the history.</span>
<span style=color:#75715e># See bash(1) for more options</span>
HISTCONTROL<span style=color:#f92672>=</span>ignoreboth

<span style=color:#75715e># append to the history file, don&#39;t overwrite it</span>
shopt -s histappend

<span style=color:#75715e># for setting history length see HISTSIZE and HISTFILESIZE in bash(1)</span>
HISTSIZE<span style=color:#f92672>=</span><span style=color:#ae81ff>1000</span>
HISTFILESIZE<span style=color:#f92672>=</span><span style=color:#ae81ff>2000</span>

<span style=color:#75715e># ...</span>

<span style=color:#75715e># some more ls aliases</span>
alias ll<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;ls -alF&#39;</span>
alias la<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;ls -A&#39;</span>
alias l<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;ls -CF&#39;</span>

<span style=color:#75715e># ...</span>
</code></pre></div><p>It's very important to understand that this file is <em>sourced</em> by the shell - so we have to use <code>return</code> if we want to stop processing it. If we used <code>exit</code> instead then the shell would close, which is definitely not what we want! If you need a reminder on sourcing, check <a href=/docs/part-4-shell-scripting/shell-script-essentials/>Chapter 18 - Shell Script Essentials</a>.</p><p>The next section of the file sets up some of the configuration for the history features of the shell. Some variables are set, such as <code>HISTSIZE</code> (the number of commands to store in the history), we also set some options using the <code>shopt</code> (<em>set shell option</em> flag).</p><p>Later on, we can see that some aliases are defined, for user convenience. For example, the <code>la</code> alias is a shorthand for <code>ls -A</code>, which can save a few keystrokes.</p><p>This exactly the sort of configuration that makes sense to keep in the <em>~/.bashrc</em> file. Users can modify this to suit their preferences.</p><p>Now let's look at some of the common features you might configure in the <em>~/.bashrc</em> file.</p><h2 id=common-shell-configurations>Common Shell Configurations</h2><p>You can add any commands you like to the <em>~/.bashrc</em> file, these commands will be run when the shell starts up.</p><p>Let's see a few examples of what you might add to your <em>~/.bashrc</em>.</p><h3 id=aliases>Aliases</h3><p>If you find yourself typing the same series of keystrokes again and again, you might want to add some aliases to your configuration file:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Start a web server</span>
alias serve<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;python3 -m SimpleHTTPServer 3000&#34;</span>

<span style=color:#75715e># Open vim without loading the vimrc.</span>
alias vimnilla<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;vi -u NONE&#39;</span>

<span style=color:#75715e># Shortcut for &#39;kubectl&#39;, saves a lot of time!</span>
alias k<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;kubectl&#39;</span>

<span style=color:#75715e># Quickly go to my GitHub repositories.</span>
alias gocode<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;cd ~/repos/github/dwmkerr&#39;</span>
</code></pre></div><p>If you are not familiar with aliases, check <a href=/docs/part-2-core-skills/understanding-commands/>Chapter 10 - Understanding Commands</a>.</p><h3 id=functions>Functions</h3><p>If you have more complex operations that you regularly perform, you could add them to your <em>~/.bashrc</em> as a function:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Restart the shell.</span>
restart-shell<span style=color:#f92672>(</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
  exec -l $SHELL
<span style=color:#f92672>}</span>

<span style=color:#75715e># Make a directory (don&#39;t fail if it exists) and move into it in one line.</span>
<span style=color:#66d9ef>function</span> mkd <span style=color:#f92672>{</span>
  mkdir -p -- <span style=color:#e6db74>&#34;</span>$1<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>&amp;&amp;</span> cd -P -- <span style=color:#e6db74>&#34;</span>$1<span style=color:#e6db74>&#34;</span>;
<span style=color:#f92672>}</span>

<span style=color:#75715e># Cut, but in reverse, e.g:</span>
<span style=color:#75715e># $ echo &#34;One;Two;Three;Four;Five&#34; | revcut -d&#39;;&#39; -f2</span>
<span style=color:#75715e># -&gt; Four</span>
<span style=color:#66d9ef>function</span> revcut <span style=color:#f92672>{</span>
  rev | cut <span style=color:#e6db74>&#34;</span>$@<span style=color:#e6db74>&#34;</span> | rev
<span style=color:#f92672>}</span>
</code></pre></div><p>You can find out more about functions in <a href=/docs/part-4-shell-scripting/functions-parameters-and-error-handling/>Chapter 22 - Functions, Parameters and Error Handling</a>.</p><h3 id=shell-options>Shell Options</h3><p>The <em>~/.bashrc</em> file is the ideal place to configure shell options to suit your preferences:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># If we enter a directory name on its own, assume we want to &#39;cd&#39; into it.</span>
shopt -s autocd
</code></pre></div><p>In this example we use the <code>shopt</code> (<em>set shell option</em>) command to set the <code>autocd</code> option. This option allows you to enter the name of a directory as if it was a command, when you press &lsquo;enter&rsquo; the shell will <code>cd</code> into the directory.</p><p>You can set an option using the <code>-s</code> (<em>set option</em>) flag and unset an option with the <code>-u</code> (<em>unset option</em>) flag.</p><p>You can list the options available to set by running <code>shopt -p</code>, or searching the <code>man bash</code> page for <code>shopt</code>. Some of the most useful options are:</p><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td><code>autocd</code></td><td>Enter a directory name as a command and the shell will <code>cd</code> to it.</td></tr><tr><td><code>cdable_vars</code></td><td>Allows you to <code>cd</code> into a variable, such as <code>repos=~/repos; cd repos</code></td></tr><tr><td><code>cdspell</code></td><td>The shell will try to fix typos to the <code>cd</code> command.</td></tr><tr><td><code>checkjobs</code></td><td>Show the status of stopped and running jobs before exiting the shell.</td></tr><tr><td><code>cmdhist</code></td><td>Save multi-line commands in the shell history as single entries, rather than an entry per line.</td></tr><tr><td><code>dirspell</code></td><td>Try to correct typos when auto-completing directory names.</td></tr><tr><td><code>globstar</code></td><td>Support recurive globbing such as <code>**/*.py</code> to find files in subdirectories.</td></tr><tr><td><code>histappend</code></td><td>Append to the history file when the shell exists, rather than overwriting it.</td></tr></tbody></table><p>As well as the options that can be set using the <code>shopt</code> command, there are also many variables that are used to configure the shell. We've seen some of these variables already, such as the <code>EDITOR</code> variable that defines what text editor to use and the <code>PAGER</code> variable that defines what pager program to use.</p><h3 id=changing-the-command-prompt>Changing the Command Prompt</h3><p>The command prompt is the information that is shown to the left of the caret in the shell where you enter commands. It will often look something like this:</p><pre><code>dwmkerr@ip-172-31-28-144:~/effective-shell$
</code></pre><p>This command prompt in this example is made up of the following parts:</p><ul><li><code>ubuntu</code> - the name of the current user</li><li><code>ip-172-31-28-144</code> - the hostname of the machine</li><li><code>~/effective-shell</code> - the current directory</li><li><code>$</code> - an indicator showing that we are using Bash (this will be <code>#</code> if we are a super user)</li></ul><p>The structure and format of the command prompt can be configured using the <code>PS1</code> variable. This is a large enough topic that the whole of the next chapter is dedicated to customising the command prompt.</p><h3 id=source-files>Source Files</h3><p>Another common pattern for the <em>~/.bashrc</em> file is to simply <code>source</code> another file.</p><p>For example, you might want to create a set of common functions that you keep in a file called <em>shell-functions.sh</em>. You could source this file as part of your shell configuration:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Load my common shell functions.</span>
source ~/shell-functions.sh
</code></pre></div><p>In fact, a lot of the shell startup files do exactly this. For example, in the default <em>~/.bashrc</em> file on Ubuntu 20, you will see these lines:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -f ~/.bash_aliases <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
    . ~/.bash_aliases
<span style=color:#66d9ef>fi</span>
</code></pre></div><p>This line uses the <code>-f</code> test to see whether a file named <em>~/.bash_aliases</em> exists. If it does, it is loaded (using <em>dot sourcing</em> as the notation).</p><p>There are lots of different ways to manage your shell configuration. This can range from the simple, such as adding an alias to the <em>~/.bashrc</em> file, to the complex, such as sourcing the contents of an entire directory, or configuring a shell dynamically based on what tools are installed on a system.</p><h3 id=configure-your-system>Configure Your System</h3><p>You might have particular commands you want to ensure are run when you start a shell. For example, let's say that you want to always have a folder named <em>~/today</em> that links to a temporary folder which is updated daily.</p><p>To do this, you could add the following commands to the <em>~/.bashrc</em> file:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Get today&#39;s date in the format YYYY-MM-DD.</span>
today<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>date +<span style=color:#e6db74>&#34;%Y-%m-%d&#34;</span><span style=color:#66d9ef>)</span>

<span style=color:#75715e># Create the path to today&#39;s temp folder and then make sure the folder exists.</span>
temp_path<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>/tmp/</span><span style=color:#e6db74>${</span>today<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
mkdir -p <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>temp_path<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>

<span style=color:#75715e># Now that we&#39;ve created the folder, make a symlink to it in our homedir.</span>
ln -sf <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>temp_path<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>HOME<span style=color:#e6db74>}</span><span style=color:#e6db74>/today</span><span style=color:#e6db74>&#34;</span> 
</code></pre></div><p>If I add this code to my <em>~/.bashrc</em> file then whenever I start a new shell, a folder will be created with today's date in the <em>/tmp/</em> directory, and a link will be created to this folder at <em>~/today</em>. This provides a convenient way to have a temporary working folder for the day. You can then go back and refer to old temporary folders if you need to.</p><h3 id=configuration-tips>Configuration Tips</h3><p>There are a few things that you should pay attention to when working with startup files.</p><p><strong>Do not print output</strong></p><p>It is considered bad practice to print output during startup of the shell. Avoid running commands like <code>echo</code> or <code>printf</code>. If you call commands that write to <em>stdout</em> then silence the output by piping it to <em>/dev/null</em>.</p><p><strong>Do not run long operations</strong></p><p>You might have written a cool scripts that pulls down information on stocks or weather from a website, ready to show in your shell. But avoid running anything in a startup file that can take a lot of time. Every time you start your shell you'll have a delay while the command runs and this can really slow you down!</p><p><strong>Be careful not to break things</strong></p><p>Don't run so many commands that you might cause errors or failures on startup. This can make your shell difficult to use or slow to start up. If your startup logic is failing it can be hard to debug, so try not to make it too complex!</p><p><strong>Clean up after yourself!</strong></p><p>Remember, any variables you set will be set for all shells that read the startup file. If there are variables that you only need during the processing of the file, consider using the <code>unset</code> command to unset the variable at the end of startup.</p><p><strong>Expect commands to be run multiple times</strong></p><p>Write your startup files with the assumption that they will be run multiple times. If you start a new shell from your current shell, your configuration file will be loaded again. Your configuration should not cause errors if it is run multiple times!</p><h1 id=shell-startup>Shell Startup</h1><p>In most cases you will only need to work with the <em>~/.bashrc</em> file to configure your shell. However, the shell actually uses a number of different configuration files (which are called &lsquo;startup files&rsquo;) depending on how the shell is being used.</p><p>You may have seen references to files such as <em>/etc/profile</em>, <em>~/.bash_profile</em>, <em>~/.bash_logout</em> and more. The different files that are used can be quite confusing. For the rest of this chapter we're going to go into the details of exactly how the shell uses these different files.</p><h1 id=different-types-of-shells>Different Types of Shells</h1><p>For us to be able to understand how shells are configured, we need to understand the different types of shells that can run. This does not mean different shell programs, such as <code>bash</code>, <code>zsh</code> or <code>dash</code>, but instead the differences between <em>interactive</em> and <em>non-interactive</em> shells, as well a <em>login</em> shells.</p><p>A lot of people get confused by how the shell is configured because they don't fully understand what these different types of shells are. So let's introduce each one, what it is and how it is used.</p><h2 id=interactive-shells>Interactive Shells</h2><p>An _interactive shell_ is any shell that has its input, output and error standard streams connected to a terminal. This sounds complicated, but it really just means that an interactive shell is one that you interact with via the keyboard and display!</p><p>When we type commands into our shell, we're using an interactive shell.</p><h2 id=non-interactive-shells>Non-Interactive Shells</h2><p>Any shell that does not have its standard input, output and error streams attached to a terminal is generally called a _non-interactive shell_.</p><p>The most common example we've seen so far for non interactive shells are the shells that run shell scripts! Let's run the <em>showpstree.sh</em> script from the samples to show the process tree for the current process. This script shows the process tree for the shell process it is running in and looks like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># GNU pstree; use the long form (-l) show the command line (-a) and the</span>
<span style=color:#75715e># details for a specific process (-s).</span>
pstree -a -s $$
</code></pre></div><p>Here's the output when we run this script:</p><pre><code>~$ ./effective-shell/scripts/showpstree.sh
systemd
  └─sshd
      └─sshd
          └─sshd
              └─bash
                  └─sh ./effective-shell/scripts/showpstree.sh
                      └─pstree -a -s 1675
</code></pre><p>The output will look different depending on what system you are using, but the key section to focus on are the final three processes:</p><ul><li><code>pstree -a -s 1675</code> - this is just the <code>pstree</code> (<em>show process tree</em>) command that is run in the <em>showpstree.sh</em> script</li><li><code>sh ./effective-shell/scripts/showpstree.sh</code> - this is a <em>non-interactive shell</em> that is running our shell script</li><li><code>bash</code> - this is the <em>interactive shell</em> that we used to invoke our shell script</li></ul><p>When you run a shell script, it runs in a <em>non-interactive</em> shell. This is really important to remember! Shell scripts are run in non-interactive shells. This means that anything you define in <em>~/.bashrc</em> will not be loaded, so don't try and use aliases or other customisations that you have made.</p><p>In fact, on many distributions you will see the following lines in the default <em>~/.bashrc</em>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># If not running interactively, don&#39;t do anything</span>
<span style=color:#66d9ef>case</span> $- in
    *i*<span style=color:#f92672>)</span> ;;
      *<span style=color:#f92672>)</span> <span style=color:#66d9ef>return</span>;;
<span style=color:#66d9ef>esac</span>
</code></pre></div><p>The first section of the script checks the current shell parameters (which are stored in the special <code>$-</code> variable) to see whether the <code>i</code> (<em>interactive</em>) parameter is present. If it is not present, the <code>return</code> command runs. This check for the shell parameters ensures that even if a non-interactive shell does load the run commands file for some reason, it stops reading it right away.</p><p>If you need a refresher on how the <code>case</code> statement works, check <a href=/docs/part-4-shell-scripting/mastering-conditional-logic/>Chapter 20 - Mastering Conditional Logic</a>.</p><p>Another way to show a non-interactive shell in action is to simply invoke the shell program with a specified command from the command like:</p><pre><code>$ sh -c &quot;echo $((5 + 5))&quot;
10
</code></pre><p>In this example we started the <code>sh</code> (<em>shell</em>) program and provided a command via the <code>-c</code> (<em>command</em>) flag. This starts a non-interactive shell.</p><p>Why do non-interactive shells not load the configuration file? There are two reasons. The first is that it doesn't make sense for scripts to rely on user-level customisations. If one user has an alias and refers to it in a script, then the script will not run for another user unless they have the same alias. The second reason is for performance - when using a shell to run a script the shell can start much more quickly if it doesn't need to load configuration or customisations.</p><h2 id=login-shells>Login Shells</h2><p>When you login to a computer with a shell, entering credentials such as a username and password, then you are using a _login shell_. A login shell will normally run some initial setup of your environment and provide the bare minimum configuration required to work with the system. For example, most shells set up the <code>$PATH</code> variable as part of the initialisation of the login shell.</p><p>For systems that don't have a graphical interface, any shell you create will be a child of the login shell, so will inherit the login shell's configuration. For graphical interfaces to systems, such as KDE or Gnome, when you log in with the graphical interface, the desktop manager normally configures the environment using the same configuration as is used for a login shell. The desktop manager process will therefore have variables like the <code>$PATH</code> set up just as if you had logged in at the command line.</p><p>When you <code>ssh</code> onto a remote machine, you will be running a login shell. In most cases, when you switch users with commands like <code>su</code> (<em>set user</em>), you will start a login shell as well<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><p>The key thing to remember about login shells is that they are normally run once, when you start working with a computer, and all of the other shells you then run will be children of the login shell.</p><p>You can see whether your shell is a login shell by examining the <code>$0</code> variable. This variable holds the parameters that were provided to start the shell. By convention, if the parameter starts with a <code>-</code> dash symbol, you can assume that you are in a login shell.</p><p>Let's see an example of this in action by logging into a virtual machine (if you would like to set up your own Linux virtual machine you can follow the guide in <a href=/docs/work-in-progress/>Appendix - Setting Up a Linux Virtual Machine</a>:</p><pre><code>$ ssh effective-shell-ubuntu-20
Welcome to Ubuntu 20.04.2 LTS (GNU/Linux 5.4.0-1045-aws x86_64)
...
To run a command as administrator (user &quot;root&quot;), use &quot;sudo &lt;command&gt;&quot;.
See &quot;man sudo_root&quot; for details.

~$ echo &quot;$0&quot;
-bash
</code></pre><p>Here we can see that the parameter that the shell was started with was <code>-bash</code>. This starts with a <code>-</code> dash symbol, indicating that it is a login shell.</p><p>Login shells are <em>normally</em> interactive shells, but it is possible to run a non-interactive login shell (it's just quite an unusual thing to do).</p><p>In the early days of Unix, executing any commands could be time consuming. The login shell would perform the most essential configuration only once when a user logs in and all subsequent shell processes could start more quickly as they would inherit the login configuration and then load the user specific configuration.</p><h1 id=shell-startup-files>Shell Startup Files</h1><p>When the shell starts, it reads a set of <em>startup files</em>. These files are shell scripts that are <em>sourced</em> by the shell. A script that is sourced is loaded into the <em>current</em> shell process, rather than running in a new shell process.</p><p>For many people, the various different files that are loaded can cause confusion. But as long as you understand the different types of shells that exist, it is actually quite straightforward to understand the process.</p><p>When a <em>login</em> shell starts, the following steps are taken:</p><ul><li>The shell attempts to load the <em>profile file</em></li><li>The <em>profile file</em> will normally load the <em>run commands</em> file</li></ul><p>When an <em>interactive</em> shell starts, the following steps are taken:</p><ul><li>The shell attempts to load the <em>run commands</em> file</li></ul><p>When a <em>non-interactive</em> shell starts, it doesn't load any configuration files, unless one has been specified in the <code>BASH_ENV</code> variable.</p><p>Let's take a look at these files in detail.</p><h2 id=the-shell-profile-file--index-->The Shell Profile File</h2><p>When a login shell is started, the shell loads and executes commands from the _/etc/profile_ file.</p><p>The profile file contains the most essential configuration that is required. It is often used to set things like the <code>$PATH</code> environment variable, which will sometimes have different values depending on the operating system you are using.</p><p>The shell will then attempt to read each of the following files. If the shell finds one that is readable, it reads it and executes its commands, and then does not attempt to read the others:</p><ul><li>_~/.bash_profile_</li><li>_~/.bash_login_</li><li>_~/.profile_</li></ul><p>There are very few circumstances in which you should change any of theses files. It is based to think of the profile files as essential operating system specific configuration that is needed to have a functional login shell.</p><p>When a login shell closes, it will run any commands in the <em>~/.bash_logout</em> file. However, users might terminate the shell process forcibly, which means that you cannot be sure this file will always be sourced as the shell exits.</p><p>The configuration that the startup files perform varies from distribution to distribution, but in general they will do at least the following:</p><ul><li>Set the <code>$PATH</code> variable to include the appropriate folders for tools for your distribution</li><li>Set the shell prompt, the characters that are shown to the user to show they need to enter input (such as <code>~$</code> when we are in the home folder, or <code>~#</code> if we are in the home folder as a super user)</li><li>Set up auto-completion (the feature that allows you to press &lsquo;tab&rsquo; to see suggestions when entering commands)</li><li>Load the <em>run commands</em> file - we'll look at this file next</li></ul><p>The key thing to remember about the profile files is that you normally don't need to change them and they normally load the <em>run command</em> file for you.</p><h2 id=the-shell-run-commands-file--index-->The Shell Run Commands File</h2><p>When an interactive non-login shell is started, the shell loads and executes the commands from the <em>/etc/bash.bashrc</em> file and then the <em>~/.bashrc</em> file (if they exist).</p><p>It is also convention that you can have two <code>rc</code> files - one that is for <em>all</em> users (in this case, <em>/etc/bash.bashrc</em>) and one that is user specific (in this case, <em>~/.bashrc</em>).</p><p>The <em>~/.bashrc</em> file is where you can put your own commands to configure the shell to suit how you want to use it. This is the file we spent the first half of the chapter looking at in detail.</p><h2 id=startup-files-for-non-interactive-shells>Startup Files for Non-Interactive Shells</h2><p>If you need to load a startup file for a non-interactive shell, you can set the <code>BASH_ENV</code> variable to the path of the file that you want to load. In general you should be very careful when doing this, as shell commands or shell scripts should be written so that they can operate without a startup file being loaded.</p><h2 id=login-shells-and-desktop-managers>Login Shells and Desktop Managers</h2><p>Before the advent of the graphical user interface, almost all shell processes would be children of a login shell, as you had to use a login shell to access the system.</p><p>For modern systems that use a desktop environment such as Gnome or KDE, the desktop manager process normally loads the <code>/etc/profile</code> file. This means that when you open a terminal program use as the Gnome Terminal or Konsole, the shell is a child of a process which has loaded the profile. Even if you don't use a login shell to access a system, you can normally be sure that the profile will have been loaded by the desktop manager.</p><p>Different distributions and operating systems may handle this in slightly different ways. For example, on MacOS when you run the Terminal program it actually starts a login shell<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>. Again, this means that you can be sure that the profile has been loaded (which in turn will load the RC files).</p><h1 id=changing-your-shell>Changing Your Shell</h1><p>You can see the shell that is currently set as the default shell for a user by checking the <em>/etc/passwd</em> file. Here's how I could see what shell is used when the <code>dwmkerr</code> user logs in:</p><pre><code>$ grep 'dwmkerr' /etc/passwd
dwmkerr:x:1001:1001:Dave Kerr,,,:/home/dwmkerr:/bin/bash
</code></pre><p>The <em>/etc/passwd</em> file keeps track of the local user accounts on the system. The final item on a line is the shell that is used for the user. When a user logs in, their shell is set in the <code>SHELL</code> environment variable, we can write this value out with the <code>echo</code> command:</p><pre><code>$ echo &quot;My shell is: $SHELL&quot;
My shell is: /bin/bash
</code></pre><p>There are a few ways that you can change your shell. However, before you change your shell, you need to make sure that the shell you want to use is listed in the &lsquo;available shells&rsquo; file. This file is kept at <em>/etc/shells</em>:</p><pre><code>$ cat /etc/shells
# /etc/shells: valid login shells
/bin/sh
/bin/bash
/usr/bin/bash
/bin/rbash
/usr/bin/rbash
/bin/dash
/usr/bin/dash
/usr/bin/tmux
</code></pre><p>If the shell you want to use is <em>not</em> listed in <em>/etc/shells</em> you will need to add it to the list.</p><p>Once you have installed the shell you want to use and added it to the <em>/etc/shells</em> list you can run the <code>chsh</code> (<em>change shell</em>) command to change the shell for a given user:</p><pre><code>$ chsh -s /bin/sh dwmkerr
</code></pre><p>The <code>-s</code> (<em>shell</em>) parameter is used to specify the shell path. After this we provide the name of the user we are changing the shell for. On many systems users are allowed to change their own shell as long as it is in the <em>/etc/shells</em> list. To change the shell for <em>another</em> user, or to use a shell that is <em>not</em> in the <em>/etc/shells</em> list the <code>chsh</code> command will need to be run as a super-user.</p><p>You can also change the shell for a user by editing the <em>/etc/passwd</em> file.</p><p>Changing your shell is an advanced topic - if you prefer to use another shell you could also simply start the shell from your login shell, for example by running <code>sh</code> from your Bash shell session.</p><p>As an end-to-end example, here's how you would install <code>zsh</code> and set it for the current user on a Debian based system:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Elevate privileges to super-user.</span>
sudo su

<span style=color:#75715e># Update the apt databases and install &#39;zsh&#39;.</span>
apt update -y
apt install zsh

<span style=color:#75715e># Add &#39;zsh&#39; to the list of shell.</span>
echo <span style=color:#e6db74>&#34;/bin/zsh&#34;</span> &gt;&gt; /etc/shells

<span style=color:#75715e># Return to normal user mode.</span>
exit

<span style=color:#75715e># Change the current user&#39;s shell to &#39;zsh&#39;.</span>
chsh -s <span style=color:#e6db74>&#34;/bin/zsh&#34;</span> $USER
</code></pre></div><p>Be careful when changing your shell - if you get this wrong then you may inadvertently lock yourself out of your account, if logging in trys to start a shell that is not properly configured. Always test that the new shell works before you set it!</p><h1 id=summary>Summary</h1><p>In this chapter we saw how to customise shell configuration with the <em>~/.bashrc</em> file. We also looked in detail at the differences between login and non-login shells, interactive and non-interactive shells, and how these different shells load startup files.</p><p>You can find all of the detail on how the shell starts up in the <code>man bash</code> page, just search for <code>^INVOCATION</code>.</p><p>In the next chapter we will look at how you can set up your command prompt to suit your preferences.</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>There are three excellent discussions on login and non-login shells and interactive shells <a href=https://askubuntu.com/questions/247738/why-is-etc-profile-not-invoked-for-non-login-shells>here</a>, <a href=https://askubuntu.com/questions/155865/what-are-login-and-non-login-shells>here</a> and <a href=https://unix.stackexchange.com/questions/38175/difference-between-login-shell-and-non-login-shell>here</a>. <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>There is a very good discussion on this topic at <a href=https://unix.stackexchange.com/questions/119627/why-are-interactive-shells-on-osx-login-shells-by-default>https://unix.stackexchange.com/questions/119627/why-are-interactive-shells-on-osx-login-shells-by-default</a>. <a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></article><div class="book-footer justify-between"><div><a class="flex align-center" href=https://github.com/dwmkerr/effective-shell/commit/40621f68971a4602d6c72ee737b9cf0542819904 title="Last modified by Dave Kerr | Jan 18, 2022" target=_blank><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>Jan 18, 2022</span></a></div><div><a class="flex align-center" href=https://github.com/dwmkerr/effective-shell/edit/master/website/content/docs/part-5-building-your-toolkit/configuring-the-shell/_index.md target=_blank><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"effective-shell"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><p>Copyright &copy; <script>document.write(new Date().getFullYear())</script>, Dave Kerr</p></div><aside class="book-toc levels-3 fixed"><nav id=TableOfContents><ul><li><a href=#chapter-24---configuring-the-shell>Chapter 24 - Configuring the Shell</a></li><li><a href=#the-shell-configuration-file>The Shell Configuration File</a><ul><li><a href=#the-default-configuration-file>The Default Configuration File</a></li><li><a href=#common-shell-configurations>Common Shell Configurations</a><ul><li><a href=#aliases>Aliases</a></li><li><a href=#functions>Functions</a></li><li><a href=#shell-options>Shell Options</a></li><li><a href=#changing-the-command-prompt>Changing the Command Prompt</a></li><li><a href=#source-files>Source Files</a></li><li><a href=#configure-your-system>Configure Your System</a></li><li><a href=#configuration-tips>Configuration Tips</a></li></ul></li></ul></li><li><a href=#shell-startup>Shell Startup</a></li><li><a href=#different-types-of-shells>Different Types of Shells</a><ul><li><a href=#interactive-shells>Interactive Shells</a></li><li><a href=#non-interactive-shells>Non-Interactive Shells</a></li><li><a href=#login-shells>Login Shells</a></li></ul></li><li><a href=#shell-startup-files>Shell Startup Files</a><ul><li><a href=#the-shell-profile-file--index-->The Shell Profile File</a></li><li><a href=#the-shell-run-commands-file--index-->The Shell Run Commands File</a></li><li><a href=#startup-files-for-non-interactive-shells>Startup Files for Non-Interactive Shells</a></li><li><a href=#login-shells-and-desktop-managers>Login Shells and Desktop Managers</a></li></ul></li><li><a href=#changing-your-shell>Changing Your Shell</a></li><li><a href=#summary>Summary</a></li></ul></nav></aside></main></body></html>