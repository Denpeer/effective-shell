<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Managing your Dotfiles"><meta property="og:title" content="Managing your Dotfiles"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://effective-shell.com/docs/part-5-building-your-toolkit/managing-your-dotfiles/"><title>Managing your Dotfiles | Effective Shell</title><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.f8520695a602b532b093067e25561bfe6fa10ca8c25171b97142acf58fa8f13c.css integrity="sha256-+FIGlaYCtTKwkwZ+JVYb/m+hDKjCUXG5cUKs9Y+o8Tw="><script defer src=/en.search.min.901d4b22032222a6f8db08efa32b2ce89f2b7affb9b504a133dbe52ece751a89.js integrity="sha256-kB1LIgMiIqb42wjvoyss6J8rev+5tQShM9vlLs51Gok="></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-155335600-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><link rel=alternate type=application/rss+xml href=https://effective-shell.com/docs/part-5-building-your-toolkit/managing-your-dotfiles/index.xml title="Effective Shell"><script id=mcjs>!function(c,h,i,m,p){m=c.createElement(h),p=c.getElementsByTagName(h)[0],m.async=1,m.src=i,p.parentNode.insertBefore(m,p)}(document,"script","https://chimpstatic.com/mcjs-connected/js/users/eac1a082b6db34d40aaff2caf/a2aaca5a8358c2e12d3f43f1a.js");</script></head><body><input type=checkbox class=hidden id=menu-control><main class="flex container"><aside class="book-menu fixed"><nav><h2 class=book-brand><a href=https://effective-shell.com/><span>Effective Shell</span></a></h2><h2 class=book-subtitle><span>By Dave Kerr</span></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/docs/introduction/><strong>Introduction</strong></a></li><li><a href=/docs/getting-started/><strong>Getting Started</strong></a></li><li><a href=/docs/part-1-transitioning-to-the-shell/><strong>Part 1 - Transitioning to the Shell</strong></a><ul><li><a href=/docs/part-1-transitioning-to-the-shell/navigating-your-system/>Navigating Your System</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/managing-your-files/>Managing Your Files</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/clipboard-gymnastics/>Clipboard Gymnastics</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/getting-help/>Getting Help</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/the-renaissance-of-the-shell/>The Renaissance of the Shell</a></li></ul></li><li><a href=/docs/part-2-core-skills/><strong>Part 2 - Core Skills</strong></a><ul><li><a href=/docs/part-2-core-skills/thinking-in-pipelines/>Thinking in Pipelines</a></li><li><a href=/docs/part-2-core-skills/fly-on-the-command-line/>Fly on the Command Line</a></li><li><a href=/docs/part-2-core-skills/job-control/>Job Control</a></li><li><a href=/docs/part-2-core-skills/understanding-commands/>Understanding Commands</a></li><li><a href=/docs/part-2-core-skills/finding-files/>Finding Files</a></li><li><a href=/docs/part-2-core-skills/what-is-a-shell/>What is a Shell?</a></li></ul></li><li><a href=/docs/part-3-manipulating-text/><strong>Part 3 - Manipulating Text</strong></a><ul><li><a href=/docs/part-3-manipulating-text/regex-essentials/>Regex Essentials</a></li><li><a href=/docs/part-3-manipulating-text/get-to-grips-with-grep/>Get to Grips with Grep</a></li><li><a href=/docs/part-3-manipulating-text/slice-and-dice-text/>Slice and Dice Text</a></li><li><a href=/docs/part-3-manipulating-text/advanced-text-manipulation/>Advanced Text Manipulation with Sed</a></li><li><a href=/docs/part-3-manipulating-text/build-commands-on-the-fly/>Build Commands on the Fly with Xargs</a></li></ul></li><li><a href=/docs/part-4-shell-scripting/><strong>Part 4 - Shell Scripting</strong></a><ul><li><a href=/docs/part-4-shell-scripting/shell-script-essentials/>Shell Script Essentials</a></li><li><a href=/docs/part-4-shell-scripting/variables-reading-input-and-mathematics/>Variables, Reading Input, and Mathematics</a></li><li><a href=/docs/part-4-shell-scripting/mastering-conditional-logic/>Mastering Conditional Logic</a></li><li><a href=/docs/part-4-shell-scripting/loops-and-working-with-files-and-folders/>Loops and working with Files and Folders</a></li><li><a href=/docs/part-4-shell-scripting/functions-parameters-and-error-handling/>Functions, Parameters and Error Handling</a></li><li><a href=/docs/part-4-shell-scripting/useful-patterns-for-shell-scripts/>Useful Patterns for Shell Scripts</a></li></ul></li><li><a href=/docs/part-5-building-your-toolkit/><strong>Part 5 - Building Your Toolkit</strong></a><ul><li><a href=/docs/part-5-building-your-toolkit/configuring-the-shell/>Configuring the Shell</a></li><li><a href=/docs/part-5-building-your-toolkit/customising-your-command-prompt/>Customising Your Command Prompt</a></li><li><a href=/docs/part-5-building-your-toolkit/managing-your-dotfiles/ class=active>Managing Your Dotfiles</a></li><li><a href=/docs/part-5-building-your-toolkit/controlling-changes-with-git/>Controlling Changes with Git</a></li><li><a href=/docs/part-5-building-your-toolkit/managing-remote-git-repositories/>Managing Remote Git Repositories and Sharing Your Dotfiles</a></li></ul></li><li><a href=/docs/part-6-advanced-techniques/><strong>Part 6 - Advanced Techniques</strong></a><ul><li><a href=/docs/part-6-advanced-techniques/understanding-shell-expansion/>Understanding Shell Expansion</a></li></ul></li><li><a href=/docs/work-in-progress/><strong>Work in Progress</strong></a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class="flex align-center justify-between book-header"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Managing your Dotfiles</strong></header><article class=markdown><h1 id=chapter-26---managing-your-dotfiles>Chapter 26 - Managing Your Dotfiles</h1><p>As you build up more and more customisations for your shell and environment, it becomes important to find a way to manage these changes and files effectively.</p><p>Configuration files are often called &lsquo;dotfiles&rsquo;. In this chapter we'll see how to manage your configuration - and &lsquo;dotfiles&rsquo; - in a way that allows you to easily manage changes over time and build up a library of scripts and features for your preferred shell. We'll also look at how we can use your &lsquo;dotfiles&rsquo; across different shells.</p><blockquote class="book-hint info"><p><strong>Z-Shell</strong></p><p>We will start by discussing Bash configuration in this chapter. However, we'll quickly switch to creating configuration that works across many shells - including Z-Shell! So if you are a Z-Shell user don't worry, all of this material will be applicable to your environment as well.</p></blockquote><p>In this chapter we will be creating some files and folders, if you just want to see the results, install the samples. You can then find them in the <em>~/effective-shell/dotfiles</em> folder.</p><blockquote class="book-hint info"><p><strong>Downloading the Samples</strong></p><p>Run the following command in your shell to download the samples:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>curl effective.sh | sh
</code></pre></div></blockquote><h1 id=dotfiles>Dotfiles</h1><p>Any file or folder on your system that starts with a <code>.</code> dot symbol is a &lsquo;dotfile&rsquo;. On many systems dotfiles are hidden by default. This means that they will not show up if you run commands like <code>ls</code>, unless you provide flags such as <code>-a</code> (<em>show all files and folders</em>) flag. In desktop environments such as Gnome, KDE and MacOS X dotfiles are also hidden by default.</p><p>Dotfiles are often used &lsquo;behind the scenes&rsquo; as configuration files or system files. This is why they are hidden by default - &lsquo;normal&rsquo; users shouldn't have to worry about them or their contents.</p><p>You will mostly see dotfiles in your <code>HOME</code> directory. They have a dot to mark them as hidden to distinguish them from your personal files and folders. When there are configuration files that are <em>outside</em> your home directory, the dot is normally not used, because it is clear from the folder that the file is in that the file is in that it is a configuration file.</p><p>As an example, a user's personal Bash configuration is stored in <em>~/.bashrc</em>, but the global Bash configuration applied to <em>all</em> users is stored in <em>/etc/bash.bashrc</em>. The second configuration file does not need a dot in front of it - the <em>/etc</em> folder is where configuration is kept so there is no need to differentiate it from other files like a user's personal files.</p><p>Nowadays, when a user say &ldquo;my dotfiles&rdquo;, they typically mean their <em>configuration</em> files that are kept in their home directory. In a sense, your dotfiles are a bit like your personal settings for your computer. On a desktop environment your settings might be things like your theme or wallpaper. For a shell user, you settings will be files like <em>~/.bashrc</em> for your shell configuration, <em>~/.ssh/config</em> for your SSH configuration and so on.</p><p>You will likely change the dotfiles over time to suit your preferences. Let's take a look at some sensible ways to organise and structure your dotfiles so that you can easily see what is your personal configuration, rather than what is the default configuration provided by the system, and easily manage these configurations.</p><h1 id=the-default-shell-dotfile>The Default Shell Dotfile</h1><p>On many platforms the default <em>~/.bashrc</em> file will contain a number of customisations out-of-the-box.</p><p>Let's take a look at the <em>~/.bashrc</em> file that comes with Ubuntu 20 as an example. We'll take a look at a few snippets. If you look at your own machine's <em>~/.bashrc</em> file the contents may be different as it will vary from distribution to distribution:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># don&#39;t put duplicate lines or lines starting with space in the history.</span>
<span style=color:#75715e># See bash(1) for more options</span>
HISTCONTROL<span style=color:#f92672>=</span>ignoreboth

<span style=color:#75715e># append to the history file, don&#39;t overwrite it</span>
shopt -s histappend

<span style=color:#75715e># for setting history length see HISTSIZE and HISTFILESIZE in bash(1)</span>
HISTSIZE<span style=color:#f92672>=</span><span style=color:#ae81ff>1000</span>
HISTFILESIZE<span style=color:#f92672>=</span><span style=color:#ae81ff>2000</span>
</code></pre></div><p>Here we have a number of options that relate to the shell history - making it slightly larger than the default, appending to the history file rather than over-writing it and so on.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># If set, the pattern &#34;**&#34; used in a pathname expansion context will</span>
<span style=color:#75715e># match all files and zero or more directories and subdirectories.</span>
<span style=color:#75715e>#shopt -s globstar</span>
</code></pre></div><p>The <code>shopt -s globstar</code> command has been commented out, so that users can quickly remove the comment symbol to enable pathname expansion across subdirectories.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># set a fancy prompt (non-color, unless we know we &#34;want&#34; color)</span>
<span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;</span>$TERM<span style=color:#e6db74>&#34;</span> in
    xterm-color|*-256color<span style=color:#f92672>)</span> color_prompt<span style=color:#f92672>=</span>yes;;
<span style=color:#66d9ef>esac</span>

<span style=color:#75715e># uncomment for a colored prompt, if the terminal has the capability; turned</span>
<span style=color:#75715e># off by default to not distract the user: the focus in a terminal window</span>
<span style=color:#75715e># should be on the output of commands, not on the prompt</span>
<span style=color:#75715e>#force_color_prompt=yes</span>

<span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -n <span style=color:#e6db74>&#34;</span>$force_color_prompt<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -x /usr/bin/tput <span style=color:#f92672>]</span> <span style=color:#f92672>&amp;&amp;</span> tput setaf <span style=color:#ae81ff>1</span> &gt;&amp;/dev/null; <span style=color:#66d9ef>then</span>
	<span style=color:#75715e># We have color support; assume it&#39;s compliant with Ecma-48</span>
	<span style=color:#75715e># (ISO/IEC-6429). (Lack of such support is extremely rare, and such</span>
	<span style=color:#75715e># a case would tend to support setf rather than setaf.)</span>
	color_prompt<span style=color:#f92672>=</span>yes
    <span style=color:#66d9ef>else</span>
	color_prompt<span style=color:#f92672>=</span>
    <span style=color:#66d9ef>fi</span>
<span style=color:#66d9ef>fi</span>

<span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;</span>$color_prompt<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>=</span> yes <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
    PS1<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ &#39;</span>
<span style=color:#66d9ef>else</span>
    PS1<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;${debian_chroot:+($debian_chroot)}\u@\h:\w\$ &#39;</span>
<span style=color:#66d9ef>fi</span>
unset color_prompt force_color_prompt
</code></pre></div><p>This rather complex looking code determines whether the shell supports colour, and if so, updates the command prompt appropriately<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># enable color support of ls and also add handy aliases</span>
<span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -x /usr/bin/dircolors <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
    test -r ~/.dircolors <span style=color:#f92672>&amp;&amp;</span> eval <span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>dircolors -b ~/.dircolors<span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>||</span> eval <span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>dircolors -b<span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span>
    alias ls<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;ls --color=auto&#39;</span>
    <span style=color:#75715e>#alias dir=&#39;dir --color=auto&#39;</span>
    <span style=color:#75715e>#alias vdir=&#39;vdir --color=auto&#39;</span>

    alias grep<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;grep --color=auto&#39;</span>
    alias fgrep<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;fgrep --color=auto&#39;</span>
    alias egrep<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;egrep --color=auto&#39;</span>
<span style=color:#66d9ef>fi</span>
</code></pre></div><p>If the shell supports colour, then <em>aliases</em> are used so that common commands like <code>ls</code> will show their output in colour.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># some more ls aliases</span>
alias ll<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;ls -alF&#39;</span>
alias la<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;ls -A&#39;</span>
alias l<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;ls -CF&#39;</span>

<span style=color:#75715e># Add an &#34;alert&#34; alias for long running commands.  Use like so:</span>
<span style=color:#75715e>#   sleep 10; alert</span>
alias alert<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;notify-send --urgency=low -i &#34;$([ $? = 0 ] &amp;&amp; echo terminal || echo error)&#34; &#34;$(history|tail -n1|sed -e &#39;</span><span style=color:#ae81ff>\&#39;</span><span style=color:#e6db74>&#39;s/^\s*[0-9]\+\s*//;s/[;&amp;|]\s*alert$//&#39;</span><span style=color:#ae81ff>\&#39;</span><span style=color:#e6db74>&#39;)&#34;&#39;</span>

<span style=color:#75715e># Alias definitions.</span>
<span style=color:#75715e># You may want to put all your additions into a separate file like</span>
<span style=color:#75715e># ~/.bash_aliases, instead of adding them here directly.</span>
<span style=color:#75715e># See /usr/share/doc/bash-doc/examples in the bash-doc package.</span>

<span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -f ~/.bash_aliases <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
    . ~/.bash_aliases
<span style=color:#66d9ef>fi</span>
</code></pre></div><p>More aliases are added as shortcuts for useful commands. We also are sourcing the <em>~/.bash_aliases</em> file if it exists.</p><p>There will likely be a number of other configuration commands that are set in the file, such as setting up the &lsquo;auto-completion&rsquo; feature of Bash.</p><p>We could add our own customisations to this file, and many people will do so. However it might be better to keep our changes in our own configuration file. This allows us to differentiate between the &lsquo;out-of-the-box&rsquo; configuration and our own personal changes. Let's see how to do that.</p><h1 id=creating-a-dotfiles-folder>Creating a Dotfiles Folder</h1><p>If we keep our shell customisations in our own dotfile, then it is much easier for us to see what are our personal configuration settings rather than the system-provided configuration settings. Also, if we keep these settings in a separate file, it becomes easier to then share this file across different machines. All we need to do is copy it to each machine where we want it, and <code>source</code> it from the <em>~/.bashrc</em> file.</p><p>The other great thing about keeping your shell configuration in its own file is that you can then use it for <em>different</em> shells if you want to. Or you can check in the file to see what the type of shell is and then load a configuration specifically for that shell.</p><p>It is entirely possible (and quite likely) that you will over time build up a collection of many dotfiles - some might be used for the shell, such as a file to set your favourite aliases or functions and some may be for other tools.</p><p>To keep things organised I'm going to show a technique to manage your dotfiles that I have found useful. You will see this technique, and many similar techniques, used by many people and demonstrated in blogs and so on. As I walk through the process feel free to customise or adapt it to suit your preferences!</p><p>First, let's start by creating a sensible location for all of our per-user personal configuration files, a folder called <em>~/dotfiles</em>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>mkdir ~/dotfiles
</code></pre></div><p>Keeping our dotfiles in a single folder will make it easier for us to later on package them up and share them, track changes to them, update them, and so on.</p><h1 id=creating-a-shell-dotfile>Creating a Shell Dotfile</h1><p>Rather than changing the system-provided <em>~/.bashrc</em> file to contain all of our customisations, let's create our own shell configuration file in the dotfiles folder:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>touch ~/dotfiles/shell.sh
</code></pre></div><p>You can call this file whatever you like, it really comes down to preferences. But here are a few points about the name I have suggested:</p><ul><li>I have not put a dot in front of the name! This is because <em>within</em> the <em>~/dotfiles</em> folder I don't actually want this file to be hidden - if I am looking in the <em>~/dotfiles</em> folder I want to see this file</li><li>I have not used the <em>name</em> of a shell program in this file - this is because I will make this file work with <em>any</em> shell that I regularly use - so whether I am using <code>zsh</code>, <code>bash</code> or <code>sh</code>, this file should still be able to be loaded</li><li>I have put <em>.sh</em> at the end of the file name - this is not really needed or even common in the world of Linux or Unix, but does make it immediately clear to the reader (or any program that opens the file) that it is a shell script</li></ul><p>Now let's edit the <em>~/dotfiles/shell.sh</em> file to add some configuration that might be useful for our shell:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Note: there is no shebang in this script. This script sets my preferred shell</span>
<span style=color:#75715e># configuration and should be able to be sourced from any Bash-like shell or</span>
<span style=color:#75715e># from Z shell.</span>

<span style=color:#75715e># If we are not running interactively do not continue loading this file.</span>
<span style=color:#66d9ef>case</span> $- in
    *i*<span style=color:#f92672>)</span> ;;
      *<span style=color:#f92672>)</span> <span style=color:#66d9ef>return</span>;;
<span style=color:#66d9ef>esac</span>
</code></pre></div><p>We'll start the file with a comment that clearly explains why this file does not have a <em>shebang</em> and that it should be able to be sourced from any Bash-like shell or Z-Shell. Then we perform a quick check on the parameters that the shell was started with (which are available in the special <code>$-</code> parameter) to see if the <code>i</code> (<em>interactive</em>) parameter is set. If the interactive parameter is <em>not</em> set then we call <code>return</code> to stop loading the script.</p><p>This is standard for shell configuration files - we only change shell configuration when running interactively (otherwise things like aliases that we add could cause shell scripts and other processes that run non-interactively to have unexpected behaviour).</p><p>Next, let's set our preferred editor:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Set our editor. Some tools use &#39;VISUAL&#39;, some use &#39;EDITOR&#39;.</span>
VISUAL<span style=color:#f92672>=</span>nano
EDITOR<span style=color:#f92672>=</span>nano
</code></pre></div><p>There are two variables are are used by the shell and command line programs to run an editor. The first, and original, variable was <code>EDITOR</code>. This was originally often a <em>line mode</em> editor - i.e. a text editor that doesn't take up the whole screen. This was useful in the days of printed output, before screens were used. The <code>VISUAL</code> variable was used to specify the editor that could be used for &lsquo;full screen&rsquo; terminal editing. Some programs use <code>EDITOR</code> and some use <code>VISUAL</code> so it is best to set both.</p><p>I have used the <code>nano</code> editor in this example as it available on many distributions and is a little easier than <code>vi</code> or <code>emacs</code>, but you can use whatever you like. For my personal dotfiles I use <code>vi</code>.</p><p>At this stage you can start to go a bit over the top - for example here's an alternative way to set the editor:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Set our preferred editor to the first available editor in the array below.</span>
preferred_editors<span style=color:#f92672>=</span><span style=color:#f92672>(</span>nano vi<span style=color:#f92672>)</span>
<span style=color:#66d9ef>for</span> editor in <span style=color:#e6db74>${</span>preferred_editors[@]<span style=color:#e6db74>}</span>; <span style=color:#66d9ef>do</span>
    <span style=color:#66d9ef>if</span> command -v <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>editor<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> &gt;/dev/null 2&gt;&amp;1; <span style=color:#66d9ef>then</span>
        <span style=color:#75715e># Note that &#39;VISUAL&#39; can be a full screen terminal editor. On legacy</span>
        <span style=color:#75715e># systems &#39;EDITOR&#39; was normally a line mode editor but there is</span>
        <span style=color:#75715e># generally no need to differentiate any more.</span>
        VISUAL<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>command -v <span style=color:#e6db74>${</span>editor<span style=color:#e6db74>}</span><span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span>
        EDITOR<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>VISUAL<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
        break
    <span style=color:#66d9ef>fi</span>
<span style=color:#66d9ef>done</span>
unset editor preferred_editors
</code></pre></div><p>In this method we specify an array of editors, go through each one, check to see if it exists<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>, and if it does set it, otherwise we look for the next in the list. This is completely over the top and unnecessary! But the great thing about your dotfiles is - they're yours! If you want to do this, that's absolutely fine. If you want to check to see if Sublime Text is installed and use that, or Visual Studio Code, then that's not a problem - it's your personal configuration so do what works for you!</p><p>You'll notice that in the <em>~/effective-shell/dotfiles/shell.sh</em> folder I <code>unset</code> every shell variable after I use it. This is just to clean up after myself and try to leave the environment as pristine as possible after sourcing the file.</p><p>Another useful option to set is <code>stty -ixon</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Allow us to use Ctrl+S to perform forward search, by disabling the start and</span>
<span style=color:#75715e># stop output control signals, which are not needed on modern systems.</span>
stty -ixon
</code></pre></div><p>This command tells the terminal driver that we don't need to control transmission with the Ctrl+Q and Ctrl+S commands, meaning we can instead use Ctrl+S to perform a forward search.</p><p>Now let's set some sensible settings for working with folders:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Set a shell option but don&#39;t fail if it doesn&#39;t exist!</span>
safe_set<span style=color:#f92672>(</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span> shopt -s <span style=color:#e6db74>&#34;</span>$1<span style=color:#e6db74>&#34;</span> &gt;/dev/null 2&gt;&amp;<span style=color:#ae81ff>1</span> <span style=color:#f92672>||</span> true; <span style=color:#f92672>}</span>

<span style=color:#75715e># Set some options to make working with folders a little easier. Note that we</span>
<span style=color:#75715e># send all output to &#39;/dev/null&#39; as startup files should not write to the</span>
<span style=color:#75715e># terminal and older shells might not have these options.</span>
safe_set autocd         <span style=color:#75715e># Enter a folder name to &#39;cd&#39; to it.</span>
safe_set cdspell        <span style=color:#75715e># Fix minor spelling issues with &#39;cd&#39;.</span>
safe_set dirspell       <span style=color:#75715e># Fix minor spelling issues for commands.</span>
safe_set cdable_vars    <span style=color:#75715e># Allow &#39;cd varname&#39; to switch directory.</span>

<span style=color:#75715e># Uncomment the below if you want to be able to &#39;cd&#39; into directories that are</span>
<span style=color:#75715e># not just relative to the current location. For example, if the below was</span>
<span style=color:#75715e># uncommented we could &#39;cd my_project&#39; from anywhere if &#39;my_project&#39; is in</span>
<span style=color:#75715e># the &#39;repos&#39; folder.</span>
<span style=color:#75715e># CDPATH=&#34;~:~/repos&#34;</span>
</code></pre></div><p>If we run this script on an older shell, some of these options might not be present. This is why we have created a <code>safe_set</code> function that won't fail if the <code>shopt</code> function fails and will pipe any output to <em>/dev/null</em>. You can use these settings or remove them, it's really up to you. Each one is described below:</p><table><thead><tr><th>Setting</th><th>Description</th></tr></thead><tbody><tr><td><code>autocd</code></td><td>Allows you to simply type a directory name or path and press enter to <code>cd</code> to it.</td></tr><tr><td><code>cdspell</code></td><td>When running commands like <code>cd dirname</code>, have the shell fix minor typos.</td></tr><tr><td><code>dirspell</code></td><td>When running commands like <code>cat dirname/test</code>, have the shell fix minor typos.</td></tr><tr><td><code>cdable_vars</code></td><td>If you create a var like <code>repos="$HOME/repos</code>, then <code>cd repos</code> to move into it.</td></tr></tbody></table><p>I have also left a comment on how you can use the <code>CDPATH</code> shell variable to allow you to <code>cd</code> into relative folders outside of your current path. This option you should be a little careful with as it can be a bit misleading - but you might find it useful.</p><p>Finally, let's set some common shell history options:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Configure the history to make it large and support multi-line commands.</span>
safe_set histappend                  <span style=color:#75715e># Don&#39;t overwrite the history file, append.</span>
safe_set cmdhist                     <span style=color:#75715e># Multi-line commands are one entry only.</span>
PROMPT_COMMAND<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;history -a&#39;</span>          <span style=color:#75715e># Before we prompt, save the history.</span>
HISTSIZE<span style=color:#f92672>=</span><span style=color:#ae81ff>10000</span>                       <span style=color:#75715e># A large number of commands per session.</span>
HISTFILESIZE<span style=color:#f92672>=</span><span style=color:#ae81ff>100000</span>                  <span style=color:#75715e># A huge number of commands in the file.</span>
<span style=color:#75715e># HISTCONTROL=&#34;ignorespace:ignoredup&#34; # Ignore starting with space or duplicates?</span>
<span style=color:#75715e># export HISTIGNORE=&#34;ls:history&#34;     # Any commands we want to not record?</span>
<span style=color:#75715e># HISTTIMEFORMAT=&#39;%F %T &#39;            # Do we want a timestamp for commands?</span>
</code></pre></div><p>These shell options and variables can be used to fine-tune how the history works. Here's a description of each one:</p><table><thead><tr><th>Setting</th><th>Description</th></tr></thead><tbody><tr><td><code>shopt -s histappend</code></td><td>When we write to the history file, append entries, don't overwrite the old file.</td></tr><tr><td><code>shopt -s cmdhist</code></td><td>If we have a multi-line command, record it as one entry, not one per line.</td></tr><tr><td><code>PROMPT_COMMAND</code></td><td>Before we show the <code>PS1</code> prompt, update the history file.</td></tr><tr><td><code>HISTSIZE</code></td><td>Store up to 10000 items in the history for the current session.</td></tr><tr><td><code>HISTFILESIZE</code></td><td>Store up to 100000 items in the history file for all sessions.</td></tr><tr><td><code>HISTCONTROL</code></td><td>Uncomment to ignore commands that start with a space, or ignore duplicated commands.</td></tr><tr><td><code>HISTIGNORE</code></td><td>Uncomment to not record certain commands in the history.</td></tr><tr><td><code>HISTTIMEFORMAT</code></td><td>Uncomment to keep a date and time next to each command in the history file.</td></tr></tbody></table><p>At this stage we got a sensible set of basic options for our shell, that should work in Bash, or Bash-like shells, as well as Z-Shell.</p><p>Now let's look at how we could test this file, before we actually source it.</p><h1 id=testing-the-shell-dotfile>Testing the Shell Dotfile</h1><p>Before we <code>source</code> the shell dotfile during shell startup, we should test that it runs without errors. Fortunately, there's a really easy way to do this!</p><p>From your shell, just run the command below:</p><pre><code>$ sh -iex ~/dotfiles/shell.sh
+ case $- in
+ EDITOR=vi
+ VISUAL=vi
+ safe_set autocd
+ shopt -s autocd
...
</code></pre><p>What we have done is run a shell program, in this case the <code>sh</code> program, and passed the following flags:</p><ul><li><code>i</code> - this makes the shell interactive - our script only runs in interactive shells so we need this to test it!</li><li><code>e</code> - this causes the shell to exit if a command fails</li><li><code>x</code> - this sets the tracing output</li></ul><p>By running this script in a shell this way we can see <em>exactly</em> what is being run, and if there is an error we will see the tracing stop at the point that the error occurs. You could perform exactly the same test with other shells, such as <code>bash</code> or <code>zsh</code>.</p><p>This is a great way to verify that the script works as expected, before we actually commit to sourcing it as part of our shell start up.</p><h1 id=sourcing-the-shell-dotfile>Sourcing the Shell Dotfile</h1><p>Now that we have a working shell dotfile, we can source it as part of our shell startup.</p><p>Rather than having our shell startup file know about our <em>~/dotfiles</em> folder, we will create a symlink to th shell script from our home directory:</p><p>Finally, we can create a symlink in our home directory that points to our <em>~/dotfiles/shell.sh</em> file and we are good to go!</p><pre><code>$ ln -sf &quot;$HOME/dotfiles/shell.sh&quot; &quot;$HOME/.shell.sh&quot;
</code></pre><p>Note that in this example we used the <code>ln -sf</code> command to create a symlink, the <code>-s</code> flag ensures we create a normal symlink (rather than a &lsquo;hard&rsquo; link) and the <code>-f</code> flag forces the creation of the link by overwriting any link that already exists.</p><p>Now all we need to do is add the following lines to our <em>~/.bashrc</em> (or for Z-Shell, <em>~/.zshrc</em> file):</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Source our shell configuration if it exists.</span>
<span style=color:#f92672>[</span> -r ~/.shell.sh <span style=color:#f92672>]</span> <span style=color:#f92672>&amp;&amp;</span> source ~/.shell.sh
</code></pre></div><p>This command uses the <code>-r</code> (<em>does file exist and is it readable</em>) test to check whether we have a <em>~/.shell.sh</em> file and if it exists, sources it.</p><p>We're going to make a couple more changes and then bring this all together by creating one final script that sets performs the steps above for us. If this is enough dotfile configuration for you, then feel free to stop now, if you'd like to go deeper we'll look at loading additional files.</p><h1 id=sourcing-files-from-a-folder>Sourcing Files from a Folder</h1><p>A common pattern with Linux and Unix systems is to allow <em>multiple</em> configuration files to be stored in a folder. A convention is to have a folder with the letters <code>.d</code> at the end, to differentiate between a single configuration file and a configuration folder.</p><p>This pattern became popular over the years as individual configuration files became larger and more complex, and operators wanted to be able to spread their configuration across multiple files.</p><p>Here are some common examples:</p><table><thead><tr><th>Configuration File</th><th>Configuration Directory</th><th>Notes</th></tr></thead><tbody><tr><td><code>/etc/crontab</code></td><td><code>/etc/cron.d</code></td><td>Configuration for scheduled tasks.</td></tr><tr><td><code>/etc/bash_completion</code></td><td><code>/etc/bash_completion.d</code></td><td>Configuration for Bash auto-complete.</td></tr><tr><td><code>/etc/sudoers</code></td><td><code>/etc/sudoers.d</code></td><td>Configuration for super-users.</td></tr></tbody></table><p>We can follow exactly the same pattern for our shell configuration. Let's say for example that we want to customise our command prompt when we start the shell, we could put the file that contains the definition of the <code>set_ps1</code> function from the last chapter in our configuration folder. The file will be loaded and then we can use it to set the <code>PS1</code> variable in our shell configuration.</p><p>First, let's make a directory to hold our shell configuration files:</p><pre><code>$ mkdir ~/dotfiles/shell.d
</code></pre><p>Now let's copy over our <em>~/effective-shell/scripts/set_ps1.sh</em> file:</p><pre><code>$ cp ~/effective-shell/scripts/set_ps1.sh ~/dotfiles/shell.d
</code></pre><p>Now let's update our <code>shell.sh</code> file to source all of the files in the <em>~/.shell.d</em> folder:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># If we are not running interactively do not continue loading this file.</span>
<span style=color:#66d9ef>case</span> $- in
    *i*<span style=color:#f92672>)</span> ;;
      *<span style=color:#f92672>)</span> <span style=color:#66d9ef>return</span>;;
<span style=color:#66d9ef>esac</span>

<span style=color:#75715e># Source any files in our ~/.shell.d folder.</span>
<span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -x ~/.shell.d <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
    <span style=color:#66d9ef>for</span> shellfile in ~/.shell.d/*; <span style=color:#66d9ef>do</span>
        <span style=color:#f92672>[</span> -r <span style=color:#e6db74>&#34;</span>$shellfile<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span> <span style=color:#f92672>&amp;&amp;</span> source <span style=color:#e6db74>&#34;</span>$shellfile<span style=color:#e6db74>&#34;</span>
    <span style=color:#66d9ef>done</span>
    unset shellfile
<span style=color:#66d9ef>fi</span>
</code></pre></div><p>The new code goes after the test to see whether the shell is interactive. We check to see whether there is a directory that can be searched (using the <code>-x</code> test), and then we loop through each file in the directory. If the file can be read (using the <code>-r</code> test) then we source it.</p><p>At the end of the <em>shell.sh</em> file we can now call the <code>set_ps1</code> function to set our theme:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Set the theme. Do not fail if the function doesn&#39;t exist.</span>
set_ps1 <span style=color:#e6db74>&#34;debian&#34;</span> <span style=color:#f92672>||</span> true
</code></pre></div><p>Finally, let's create a symlink in our home directory for the shell configuration files:</p><pre><code>$ ln -sf &quot;$HOME/dotfiles/shell.d&quot; &quot;$HOME/.shell.d&quot;
</code></pre><p>At this stage we've now successfully created a <em>dotfiles</em> folder to store our configuration, symlinks in our <code>$HOME</code> directory that point to our dotfiles and we have also updated our <em>~/.bashrc</em> or <em>~/.zshrc</em> to load our shell configuration.</p><p>If you want to see the new links you've created you can run the <code>ls</code> command just like so (I've abbreviated the output to make it more readable):</p><pre><code>$ ls -al ~ | grep shell
lrwxr-xr-x    dwmkerr  .shell.d -&gt; /home/dwmkerr/dotfiles/shell.d
lrwxr-xr-x    dwmkerr  .shell.sh -&gt; /home/dwmkerr/dotfiles/shell.sh
</code></pre><h1 id=a-dotfile-install-script>A Dotfile Install Script</h1><p>The manual steps we performed to setup the links for our dotfiles can be easily run using a shell script.</p><p>The script below shows how we can easily setup the links to the dotfiles, and source the appropriate files from our shell configuration:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e>#!/usr/bin/env sh
</span><span style=color:#75715e></span>
<span style=color:#75715e># This script installs the dotfiles locally. Note that it should be run from the</span>
<span style=color:#75715e># dotfiles folder so that the links are set properly!</span>

<span style=color:#75715e># Create links for the shell configuration.</span>
ln -sf <span style=color:#e6db74>&#34;</span>$PWD<span style=color:#e6db74>/shell.sh</span><span style=color:#e6db74>&#34;</span> <span style=color:#e6db74>&#34;</span>$HOME<span style=color:#e6db74>/.shell.sh</span><span style=color:#e6db74>&#34;</span>
ln -sf <span style=color:#e6db74>&#34;</span>$PWD<span style=color:#e6db74>/shell.d</span><span style=color:#e6db74>&#34;</span> <span style=color:#e6db74>&#34;</span>$HOME<span style=color:#e6db74>/.shell.d</span><span style=color:#e6db74>&#34;</span>

<span style=color:#75715e># Source our shell configuration in any local shell config files.</span>
config_files<span style=color:#f92672>=</span><span style=color:#f92672>(</span>~/.bashrc ~/.zshrc<span style=color:#f92672>)</span>
<span style=color:#66d9ef>for</span> config_file in <span style=color:#e6db74>${</span>config_files[@]<span style=color:#e6db74>}</span>; <span style=color:#66d9ef>do</span>
    <span style=color:#75715e># Skip config files that don&#39;t exist.</span>
    <span style=color:#f92672>[</span> -r <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>config_file<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span> <span style=color:#f92672>||</span> <span style=color:#66d9ef>continue</span>

    <span style=color:#75715e># If we don&#39;t have the &#39;source ~/.shell.d&#39; line in our config, add it.</span>
    source_command<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;[ -r ~/.shell.sh ] &amp;&amp; source ~/.shell.sh&#34;</span>
    <span style=color:#66d9ef>if</span> ! grep -q <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>source_command<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>config_file<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>; <span style=color:#66d9ef>then</span>
        echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>.shell.sh is not sourced in &#39;</span><span style=color:#e6db74>${</span>config_file<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39; adding this now...</span><span style=color:#e6db74>&#34;</span>
        echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>source_command<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> &gt;&gt; <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>config_file<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
    <span style=color:#66d9ef>fi</span>
<span style=color:#66d9ef>done</span>
</code></pre></div><p>This script creates the symlinks to our dotfiles and loops through a set of shell configuration files, adding a line to source the <em>~/.shell.sh</em> in the configuration file if it doesn't exist.</p><p>Note how we use the <code>grep -q</code> command to search through the shell configuration file to see if the line that sources our dotfile exists. The <code>grep</code> command returns <code>0</code> if it finds a result and <code>1</code> otherwise, meaning we can easily use it in an &lsquo;if&rsquo; statement</p><p>This script can be run from the dotfiles folder like so:</p><pre><code>$ cd ~/dotfiles
$ ./install.sh
.shell.sh is not sourced in '/home/dwmkerr/.bashrc' adding this now...
</code></pre><p>And that is it - we now have a <em>~/dotfiles</em> folder with our configuration, a sensible set of options for the shell, and the ability to quickly configure our dotfiles for different shells.</p><p>The dotfiles that we have a created are available in the <em>~/effective-shell/dotfiles</em> folder from the samples. The install script shown above is also in that folder.</p><h1 id=summary>Summary</h1><p>In this chapter we looked at some sensible configuration settings for shells. We also looked at how to keep our settings separated from the system provided configuration file. We also saw how to manage our configuration files and folders in a &lsquo;dotfiles&rsquo; folder. Finally, we created a simple script to &lsquo;install&rsquo; our dotfiles for the local user.</p><p>In the next chapter we'll introduce Git - a version control tool we can use to manage changes to files like the &lsquo;dotfiles&rsquo; easily over time. We can also use this tool to share our dotfiles across many machines.</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>If you are curious, the <code>debian_chroot</code> variable is set when you are running as a user that has run the <code>chroot</code> (<em>change root</em>) command. The <code>chroot</code> command allows you to create an isolated file system tree. This lets you run programs in what is sometimes called a &lsquo;jail&rsquo;, which is a little like a container. <code>chroot</code> is an advanced topic and out of the scope of this book, but the <code>debian_chroot</code> command in the <code>PS1</code> variable is used to help make it clear when running a shell if you are in a &lsquo;changed root&rsquo; environment. <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>For a reminder on how to check whether a command is available, see <em>Checking for Installed Programs</em> in <a href=/docs/part-4-shell-scripting/useful-patterns-for-shell-scripts/>Chapter 23 - Useful Patterns for Shell Scripts</a>. <a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></article><div class="book-footer justify-between"><div><a class="flex align-center" href=https://github.com/dwmkerr/effective-shell/commit/f5b1f3130544dfd22ca3334634a3464c80be86c5 title="Last modified by Dave Kerr | Jan 15, 2022" target=_blank><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>Jan 15, 2022</span></a></div><div><a class="flex align-center" href=https://github.com/dwmkerr/effective-shell/edit/master/website/content/docs/part-5-building-your-toolkit/managing-your-dotfiles/_index.md target=_blank><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"effective-shell"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><p>Copyright &copy; <script>document.write(new Date().getFullYear())</script>, Dave Kerr</p></div><aside class="book-toc levels-3 fixed"><nav id=TableOfContents><ul><li><a href=#chapter-26---managing-your-dotfiles>Chapter 26 - Managing Your Dotfiles</a></li><li><a href=#dotfiles>Dotfiles</a></li><li><a href=#the-default-shell-dotfile>The Default Shell Dotfile</a></li><li><a href=#creating-a-dotfiles-folder>Creating a Dotfiles Folder</a></li><li><a href=#creating-a-shell-dotfile>Creating a Shell Dotfile</a></li><li><a href=#testing-the-shell-dotfile>Testing the Shell Dotfile</a></li><li><a href=#sourcing-the-shell-dotfile>Sourcing the Shell Dotfile</a></li><li><a href=#sourcing-files-from-a-folder>Sourcing Files from a Folder</a></li><li><a href=#a-dotfile-install-script>A Dotfile Install Script</a></li><li><a href=#summary>Summary</a></li></ul></nav></aside></main></body></html>