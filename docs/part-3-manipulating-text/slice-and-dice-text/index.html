<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Slice and Dice Text"><meta property="og:title" content="Slice and Dice Text"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://effective-shell.com/docs/part-3-manipulating-text/slice-and-dice-text/"><title>Slice and Dice Text | Effective Shell</title><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.f8520695a602b532b093067e25561bfe6fa10ca8c25171b97142acf58fa8f13c.css integrity="sha256-+FIGlaYCtTKwkwZ+JVYb/m+hDKjCUXG5cUKs9Y+o8Tw="><script defer src=/en.search.min.49a2ce60154f676ad4f05eb4d7d4b56502de95dd3c0f8fc97ecdb281359ad1f7.js integrity="sha256-SaLOYBVPZ2rU8F6019S1ZQLeld08D4/Jfs2ygTWa0fc="></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-155335600-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><link rel=alternate type=application/rss+xml href=https://effective-shell.com/docs/part-3-manipulating-text/slice-and-dice-text/index.xml title="Effective Shell"><script id=mcjs>!function(c,h,i,m,p){m=c.createElement(h),p=c.getElementsByTagName(h)[0],m.async=1,m.src=i,p.parentNode.insertBefore(m,p)}(document,"script","https://chimpstatic.com/mcjs-connected/js/users/eac1a082b6db34d40aaff2caf/a2aaca5a8358c2e12d3f43f1a.js");</script></head><body><input type=checkbox class=hidden id=menu-control><main class="flex container"><aside class="book-menu fixed"><nav><h2 class=book-brand><a href=https://effective-shell.com/><span>Effective Shell</span></a></h2><h2 class=book-subtitle><span>By Dave Kerr</span></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/docs/introduction/><strong>Introduction</strong></a></li><li><a href=/docs/getting-started/><strong>Getting Started</strong></a></li><li><a href=/docs/part-1-transitioning-to-the-shell/><strong>Part 1 - Transitioning to the Shell</strong></a><ul><li><a href=/docs/part-1-transitioning-to-the-shell/navigating-your-system/>Navigating Your System</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/managing-your-files/>Managing Your Files</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/clipboard-gymnastics/>Clipboard Gymnastics</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/getting-help/>Getting Help</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/the-renaissance-of-the-shell/>The Renaissance of the Shell</a></li></ul></li><li><a href=/docs/part-2-core-skills/><strong>Part 2 - Core Skills</strong></a><ul><li><a href=/docs/part-2-core-skills/thinking-in-pipelines/>Thinking in Pipelines</a></li><li><a href=/docs/part-2-core-skills/fly-on-the-command-line/>Fly on the Command Line</a></li><li><a href=/docs/part-2-core-skills/job-control/>Job Control</a></li><li><a href=/docs/part-2-core-skills/understanding-commands/>Understanding Commands</a></li><li><a href=/docs/part-2-core-skills/finding-files/>Finding Files</a></li><li><a href=/docs/part-2-core-skills/what-is-a-shell/>What is a Shell?</a></li></ul></li><li><a href=/docs/part-3-manipulating-text/><strong>Part 3 - Manipulating Text</strong></a><ul><li><a href=/docs/part-3-manipulating-text/regex-essentials/>Regex Essentials</a></li><li><a href=/docs/part-3-manipulating-text/get-to-grips-with-grep/>Get to Grips with Grep</a></li><li><a href=/docs/part-3-manipulating-text/slice-and-dice-text/ class=active>Slice and Dice Text</a></li><li><a href=/docs/part-3-manipulating-text/advanced-text-manipulation/>Advanced Text Manipulation with Sed</a></li><li><a href=/docs/part-3-manipulating-text/build-commands-on-the-fly/>Build Commands on the Fly with Xargs</a></li></ul></li><li><a href=/docs/part-4-shell-scripting/><strong>Part 4 - Shell Scripting</strong></a><ul><li><a href=/docs/part-4-shell-scripting/shell-script-essentials/>Shell Script Essentials</a></li><li><a href=/docs/part-4-shell-scripting/variables-reading-input-and-mathematics/>Variables, Reading Input, and Mathematics</a></li><li><a href=/docs/part-4-shell-scripting/mastering-conditional-logic/>Mastering Conditional Logic</a></li><li><a href=/docs/part-4-shell-scripting/loops-and-working-with-files-and-folders/>Loops and working with Files and Folders</a></li><li><a href=/docs/part-4-shell-scripting/functions-parameters-and-error-handling/>Functions, Parameters and Error Handling</a></li><li><a href=/docs/part-4-shell-scripting/useful-patterns-for-shell-scripts/>Useful Patterns for Shell Scripts</a></li></ul></li><li><a href=/docs/part-5-building-your-toolkit/><strong>Part 5 - Building Your Toolkit</strong></a><ul><li><a href=/docs/part-5-building-your-toolkit/configuring-the-shell/>Configuring the Shell</a></li><li><a href=/docs/part-5-building-your-toolkit/customising-your-command-prompt/>Customising Your Command Prompt</a></li><li><a href=/docs/part-5-building-your-toolkit/managing-your-dotfiles/>Managing Your Dotfiles</a></li></ul></li><li><a href=/docs/work-in-progress/><strong>Work in Progress</strong></a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class="flex align-center justify-between book-header"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Slice and Dice Text</strong></header><article class=markdown><h1 id=chapter-15---slice-and-dice-text>Chapter 15 - Slice and Dice Text</h1><p>In <a href=/docs/part-3-manipulating-text/get-to-grips-with-grep/>Chapter 14</a> we looked at how to use the <code>grep</code> command to search through text and filter text. In this chapter we're going to look at some of the basic commands which we can use to <em>manipulate</em> text. There are a whole raft of commands and options available.</p><p>We'll start with the basics and move onto some of the more sophisticated commands in the next chapter.</p><h1 id=heads-and-tails>Heads and Tails</h1><p>The commands <code>head</code> and <code>tail</code> are very simple but incredibly useful.</p><p><code>head</code> is used to extract part of the <em>top</em> of a file and <code>tail</code> is used to extract part of the <em>end</em> of a file. Once you starting using these commands you'll find yourself using them regularly.</p><p>Let's start with <code>head</code>. Imagine we have a data file which has been sent to us, we don't know exactly what is in it, but we know it is large. How can we take a quick look?</p><pre><code>$ head ~/effective-shell/data/top100.csv

&quot;Rank&quot;,&quot;Rating&quot;,&quot;Title&quot;,&quot;Reviews&quot;
&quot;1&quot;,&quot;97&quot;,&quot;Black Panther (2018)&quot;,&quot;515&quot;
&quot;2&quot;,&quot;94&quot;,&quot;Avengers: Endgame (2019)&quot;,&quot;531&quot;
&quot;3&quot;,&quot;93&quot;,&quot;Us (2019)&quot;,&quot;536&quot;
&quot;4&quot;,&quot;97&quot;,&quot;Toy Story 4 (2019)&quot;,&quot;445&quot;
&quot;5&quot;,&quot;99&quot;,&quot;Lady Bird (2017)&quot;,&quot;393&quot;
&quot;6&quot;,&quot;100&quot;,&quot;Citizen Kane (1941)&quot;,&quot;94&quot;
&quot;7&quot;,&quot;97&quot;,&quot;Mission: Impossible - Fallout (2018)&quot;,&quot;430&quot;
&quot;8&quot;,&quot;98&quot;,&quot;The Wizard of Oz (1939)&quot;,&quot;120&quot;
&quot;9&quot;,&quot;96&quot;,&quot;The Irishman (2019)&quot;,&quot;441&quot;
</code></pre><p>The <code>head</code> command just shows the first ten lines of a file. Here we can see that this is a <em>comma separated values</em> file which seems to be a list of movies. This file is actually a list of the top 100 films on &lsquo;Rotten Tomatoes&rsquo; at the time of writing, with the score, tomato meter, name and number of votes. We'll use it a lot in this chapter to demonstrate text manipulation.</p><p>You can use the <code>-n</code> flag to specify the number of lines you want to see, for example:</p><pre><code>$ head -n 3 ~/effective-shell/data/top100.csv

&quot;Rank&quot;,&quot;Rating&quot;,&quot;Title&quot;,&quot;Reviews&quot;
&quot;1&quot;,&quot;97&quot;,&quot;Black Panther (2018)&quot;,&quot;515&quot;
&quot;2&quot;,&quot;94&quot;,&quot;Avengers: Endgame (2019)&quot;,&quot;531&quot;
</code></pre><p>The <code>tail</code> command works in the same way - but looks at the <em>end</em> of a file. This is more useful when you are looking content which changes over time, like log files. In this case you probably want to see only the most <em>recent</em> entries.</p><p>Here's how we can see the ten most recent commands we entered in our shell:</p><pre><code>$ tail $HISTFILE

: 1606818280:0;ls
: 1606818300:0;ln -s $(pwd) ~/effective-shell
: 1606818308:0;cat ~/effective-shell/data/top100.csv
: 1606818342:0;head -n 3 ~/effective-shell/data/top100.csv
: 1606819062:0;head ~/effective-shell/data/top100.csv
: 1606819647:0;gcd
: 1606819649:0;git stash
: 1606819650:0;gcd
: 1606819662:0;git stash pop
: 1606819803:0;tail $HISTFILE
</code></pre><blockquote class="book-hint info"><p><strong>What is $HISTFILE?</strong></p><p>Most Bash-like shells keep a file called the <em>history</em> file. This is essentially a record of all of the commands which have been written in the shell. The <code>history</code> command can be used to show the contents of this file. But if we want to work with the file directly, we can find its location with the special variable called <code>$HISTFILE</code>.</p><p>Enter <code>help history</code> for more information on the shell history.</p></blockquote><p>We can be more specific, just like with <code>head</code>, by specifying the number of lines to show:</p><pre><code>$ tail -n 3 $HISTFILE

: 1606819650:0;gcd
: 1606819662:0;git stash pop
: 1606819803:0;tail $HISTFILE
</code></pre><p><code>tail</code> can also be used to show the <em>changes</em> to a file in real time. Add the <code>-f</code> flag to <em>follow</em> the contents of the file - this means the <code>tail</code> command show each new line as it gets added to the file.</p><p>To try it out, run the following command in one shell:</p><pre><code>$ tail -f $HISTFILE
</code></pre><p>In another terminal window, start entering commands. You'll see that the <code>tail</code> command in the first window is writing the updates to the terminal as they are entered in the file. Press <code>Ctrl+C</code> to close the <code>tail</code> program.</p><p>Another trick I use a lot with <code>tail</code> is to use <code>-n +2</code>. This shows everything <em>from the second line</em> - the <code>+</code> symbol indicates we show everything from the given line onwards. This makes it easy to strip the header, or first line, from content. Here's how you might use it:</p><pre><code>$ head ~/effective-shell/data/top100.csv | tail -n +2

&quot;1&quot;,&quot;97&quot;,&quot;Black Panther (2018)&quot;,&quot;515&quot;
&quot;2&quot;,&quot;94&quot;,&quot;Avengers: Endgame (2019)&quot;,&quot;531&quot;
&quot;3&quot;,&quot;93&quot;,&quot;Us (2019)&quot;,&quot;536&quot;
&quot;4&quot;,&quot;97&quot;,&quot;Toy Story 4 (2019)&quot;,&quot;445&quot;
&quot;5&quot;,&quot;99&quot;,&quot;Lady Bird (2017)&quot;,&quot;393&quot;
&quot;6&quot;,&quot;100&quot;,&quot;Citizen Kane (1941)&quot;,&quot;94&quot;
&quot;7&quot;,&quot;97&quot;,&quot;Mission: Impossible - Fallout (2018)&quot;,&quot;430&quot;
&quot;8&quot;,&quot;98&quot;,&quot;The Wizard of Oz (1939)&quot;,&quot;120&quot;
&quot;9&quot;,&quot;96&quot;,&quot;The Irishman (2019)&quot;,&quot;441&quot;
</code></pre><p>Here I've taken the <code>head</code> of the file (otherwise the output gets quite difficult to follow), then piped the results into <code>tail -n +2</code> to grab everything from the second line onwards - which removes the heading line. We see the films only, not the titles of each column.</p><p>We're going to use <code>head</code> and <code>tail</code> quite a lot when working with text. These are two crucial tools which can really speed up your work.</p><h1 id=replacing-text>Replacing Text</h1><p>The next tool we'll look at is <code>tr</code> (<em>translate characters</em>). This program is very simple. My most common use for <code>tr</code> is to perform a simple substitution of characters.</p><p>Let's create a list of each of the columns in the data file we saw before to show how the command works:</p><pre><code>$ head -n 1 ~/effective-shell/data/top100.csv | tr ',' '\n'

&quot;Rank&quot;
&quot;Rating&quot;
&quot;Title&quot;
&quot;Reviews&quot;
</code></pre><p>What about if we wanted to remove the quotes?</p><pre><code>$ head -n 1 ~/effective-shell/data/top100.csv | tr ',' '\n' | tr -d '&quot;'

Rank
Rating
Title
Reviews
</code></pre><p>Here we've seen two variations on how we can run the command. The first form is used to <em>replace</em> characters. Running:</p><pre><code>tr ',' '\n'
</code></pre><p>Replaces the first specified character with the second. The <code>\n</code> character is the special <em>newline</em> character, which is used to create a line break at the end of a file.</p><p>The second form uses the <code>-d</code> flag to specify a set of characters to delete:</p><pre><code>tr -d '&quot;'
</code></pre><p>In the form above we delete quote (<code>"</code>) characters.</p><p>When using <code>tr</code> remember that it works on <em>characters</em>. For example, the following might not work as you expect:</p><pre><code>$ echo &quot;Welcome to the shell&quot; | tr 'shell' 'machine'

Wcicomc to tac macii
</code></pre><p>The reason the output is like this is that we're specifying <em>character</em> replacements - so we're changing characters as shown below:</p><pre><code>s -&gt; m
h -&gt; a
e -&gt; c
l -&gt; h
l -&gt; i
</code></pre><p>There <em>are</em> plenty of ways to replace entire words or perform more complex operations, but we'll use <code>sed</code> or <code>awk</code> for these operations - which we'll see in the following chapter.</p><p>There is one final thing it is worth mentioning about <code>tr</code>. It can be provided with <em>character classes</em>. This is easiest to explain with an example:</p><pre><code>$ echo &quot;Use your inside voice...&quot; | tr '[[:lower:]]' '[[:upper:]]'

USE YOUR INSIDE VOICE...
</code></pre><p>In this case we are transforming characters in the <code>lower</code> class (lowercase characters) to the <code>upper</code> class (uppercase characters).</p><p>On Linux systems you can find more about character classes with <code>man 7 regex</code>. I am not going to go deeper into character classes at this stage. They provide a simple way to specify things like digits, alphabetic characters and so on, but there are other ways to do this (with <em>extended regexes</em>) which I think are likely to be more useful to learn about instead.</p><h1 id=how-to-cut>How to Cut</h1><p>The next command is one which I've used far more than I expected. The <code>cut</code> command <em>splits</em> a line of text, using a given delimiter. Let's see some examples:</p><pre><code>$ cut -d',' -f 3 ~/effective-shell/data/top100.csv | head

&quot;Title&quot;
&quot;Black Panther (2018)&quot;
&quot;Avengers: Endgame (2019)&quot;
&quot;Us (2019)&quot;
&quot;Toy Story 4 (2019)&quot;
&quot;Lady Bird (2017)&quot;
&quot;Citizen Kane (1941)&quot;
&quot;Mission: Impossible - Fallout (2018)&quot;
&quot;The Wizard of Oz (1939)&quot;
&quot;The Irishman (2019)&quot;
</code></pre><p>This is the first way to use <code>cut</code>. We specify the <code>-d</code> flag to choose a <em>delimiter</em> which we will cut the text with, then <code>-f</code> to choose <em>which field</em> we want to see. In this case we show split on the command character and show the third field - the <em>title</em> of the film in the data file.</p><p>This can be extraordinarily useful. Let's see how to get the names of the Kubernetes pods I have running on a cluster. I can use the following command to get the pods:</p><pre><code>$ kubectl get pods

NAME                                  READY   STATUS    RESTARTS   AGE
elastic-operator-0                    1/1     Running   0          35d
elk-apm-server-65b698fb8c-rzncz       1/1     Running   0          13d
elk-es-default-0                      1/1     Running   0          35d
elk-kb-6f8bb6457b-bbbnn               1/1     Running   0          35d
filebeat-beat-filebeat-ccgl7          1/1     Running   1          13d
filebeat-beat-filebeat-dvf2l          1/1     Running   2          13d
filebeat-beat-filebeat-mnpms          1/1     Running   329        13d
kube-state-metrics-5cb57bdc45-mqv9d   1/1     Running   0          35d
metricbeat-beat-metricbeat-2xm7t      1/1     Running   6103       35d
metricbeat-beat-metricbeat-96dkt      1/1     Running   6097       35d
metricbeat-beat-metricbeat-n7kxm      1/1     Running   6109       35d
</code></pre><p>Now to get the name I can just <code>cut</code> the lines on the &lsquo;space&rsquo; character and grab the first field:</p><pre><code>$ kubectl get pods | cut -d' ' -f 1

NAME
elastic-operator-0
elk-apm-server-65b698fb8c-rzncz
elk-es-default-0
elk-kb-6f8bb6457b-bbbnn
filebeat-beat-filebeat-ccgl7
filebeat-beat-filebeat-dvf2l
filebeat-beat-filebeat-mnpms
kube-state-metrics-5cb57bdc45-mqv9d
metricbeat-beat-metricbeat-2xm7t
metricbeat-beat-metricbeat-96dkt
metricbeat-beat-metricbeat-n7kxm
</code></pre><p>And if we want to strip the first line? We can use the <code>tail -n +2</code> command to tail everything from the second line onwards:</p><pre><code>$ kubectl get pods | cut -d' ' -f 1 | tail -n +2

elastic-operator-0
elk-apm-server-65b698fb8c-rzncz
elk-es-default-0
elk-kb-6f8bb6457b-bbbnn
filebeat-beat-filebeat-ccgl7
filebeat-beat-filebeat-dvf2l
filebeat-beat-filebeat-mnpms
kube-state-metrics-5cb57bdc45-mqv9d
metricbeat-beat-metricbeat-2xm7t
metricbeat-beat-metricbeat-96dkt
metricbeat-beat-metricbeat-n7kxm
</code></pre><p>Bingo - we've removed the heading line. If you remember <code>grep</code> from the previous chapter, you might have spotted that we could also just filter the content:</p><pre><code>$ kubectl get pods | cut -d' ' -f 1 | grep -v NAME

elastic-operator-0
elk-apm-server-65b698fb8c-rzncz
elk-es-default-0
elk-kb-6f8bb6457b-bbbnn
filebeat-beat-filebeat-ccgl7
filebeat-beat-filebeat-dvf2l
filebeat-beat-filebeat-mnpms
kube-state-metrics-5cb57bdc45-mqv9d
metricbeat-beat-metricbeat-2xm7t
metricbeat-beat-metricbeat-96dkt
metricbeat-beat-metricbeat-n7kxm
</code></pre><p>With even just a few simple shell commands there are often many ways to accomplish the same goal!</p><p>There is another way we can <code>cut</code> text. We can <code>cut</code> by slicing a number of characters from each line.</p><p>Let's take a look at our web logs file:</p><pre><code>$ tail ~/effective-shell/logs/web-server-logs.txt

2020-11-29T12:50:52.721Z: info - Request: GET /en.search.min.1f83b222e24a227c0f5763727cb9e4f3b435f08b936f6ce529c9c9359f6b61a8.js
2020-11-29T12:50:52.722Z: info - Serving file '../../../website/public/en.search.min.1f83b222e24a227c0f5763727cb9e4f3b435f08b936f6ce529c9c9359f6b61a8.js'...
2020-11-29T12:50:52.762Z: info - Request: GET /svg/menu.svg
2020-11-29T12:50:52.763Z: info - Serving file '../../../website/public/svg/menu.svg'...
2020-11-29T12:50:52.763Z: info - Request: GET /svg/calendar.svg
2020-11-29T12:50:52.764Z: info - Serving file '../../../website/public/svg/calendar.svg'...
2020-11-29T12:50:52.765Z: info - Request: GET /svg/edit.svg
2020-11-29T12:50:52.766Z: info - Serving file '../../../website/public/svg/edit.svg'...
2020-11-29T12:50:52.784Z: info - Request: GET /fonts/roboto-v19-latin-300italic.woff2
2020-11-29T12:50:52.785Z: info - Serving file '../../../website/public/fonts/roboto-v19-latin-300italic.woff2'...
</code></pre><p>We can use the <code>-c</code> (<em>characters</em>) flag to specify the characters in the line we want to see. Let's extract the timestamp only:</p><pre><code>$ tail -n 3 ~/effective-shell/logs/web-server-logs.txt | cut -c 12-19

12:50:52
12:50:52
12:50:52
</code></pre><p>We can also use the character option to extract everything from a specific point onwards:</p><pre><code>$ tail -n 3 ~/effective-shell/logs/web-server-logs.txt | cut -c 27-

info - Serving file '../../../website/public/svg/edit.svg'...
info - Request: GET /fonts/roboto-v19-latin-300italic.woff2
info - Serving file '../../../website/public/fonts/roboto-v19-latin-300italic.woff2'...
</code></pre><p>By cutting from the 27th character onwards (<code>-c 27-</code>) we remove the timestamp and just get the log message.</p><p>As a nice trick you can use the same syntax when splitting by fields:</p><pre><code>$ tail -n 3 ~/effective-shell/data/top100.csv | cut -d',' -f 3-

&quot;Pinocchio (1940)&quot;,&quot;55&quot;
&quot;Chinatown (1974)&quot;,&quot;75&quot;
&quot;The Dark Knight (2008)&quot;,&quot;342&quot;
</code></pre><p>This is field three onwards. If we just want fields two and three, we use:</p><pre><code>$ tail -n 3 ~/effective-shell/data/top100.csv | cut -d',' -f 2,3

&quot;100&quot;,&quot;Pinocchio (1940)&quot;
&quot;99&quot;,&quot;Chinatown (1974)&quot;
&quot;94&quot;,&quot;The Dark Knight (2008)&quot;
</code></pre><p>There's a surprising amount you can do with the <code>cut</code> tool. As we introduce more complex tools later on, like <code>sed</code> and <code>awk</code>, we'll see other ways to accomplish the same goals, but I often find that by filtering down the content with <code>grep</code> first I can <code>cut</code> my way to what I need without having to use more complex tools.</p><h1 id=a-trick-with-rev>A Trick with Rev</h1><p>There is a very simple command called <code>rev</code> which reverses the given input. For example:</p><pre><code>$ echo &quot;A nut for a jar of tuna&quot; | rev

anut fo raj a rof tun A
</code></pre><p>At first glance this doesn't seem very useful - but there's a nice trick we can do with this:</p><pre><code>$ pwd | rev | cut -d\ -f 1 | rev

effective-shell-playground
</code></pre><p>Here we take the current working directory, reverse it, cut the first field, then reverse it again. Here's what's happening at each stage:</p><pre><code>pwd              /Users/dwmkerr/effective-shell
rev              llehs-evitceffe/rrekmwd/sresU/
cut -d'/' -f 1   llehs-evitceffe
rev              effective-shell
</code></pre><p>This is a neat trick to rip all of the text from the <em>final</em> occurrence of a character. You might not use it very often but it's an interesting reminder that you can often do more than you think by chaining together simple commands into a pipeline!</p><h1 id=sort-and-unique>Sort and Unique</h1><p>Two other commands which can be really helpful are <code>sort</code> and <code>uniq</code>. Let's see <code>sort</code> first:</p><pre><code>$ cut -d',' -f 3 ~/effective-shell/data/top100.csv | sort | head

&quot;12 Years a Slave (2013)&quot;
&quot;A Hard Day's Night (1964)&quot;
&quot;A Night at the Opera (1935)&quot;
&quot;A Quiet Place (2018)&quot;
&quot;A Star Is Born (2018)&quot;
&quot;Alien (1979)&quot;
&quot;All About Eve (1950)&quot;
&quot;Argo (2012)&quot;
&quot;Arrival (2016)&quot;
&quot;Avengers: Endgame (2019)&quot;
</code></pre><p>Here we've grabbed the third field in our data file (the name of the film), sorted, then shown the first ten values.</p><p>You can <em>reverse</em> the direction of <code>sort</code> with the <code>-r</code> flag:</p><pre><code>$ cut -d',' -f 3 ~/effective-shell/data/top100.csv | sort -r | head

&quot;Zootopia (2016)&quot;
&quot;Wonder Woman (2017)&quot;
&quot;Won't You Be My Neighbor? (2018)&quot;
&quot;Widows (2018)&quot;
&quot;War for the Planet of the Apes (2017)&quot;
&quot;Us (2019)&quot;
&quot;Up (2009)&quot;
&quot;Toy Story 4 (2019)&quot;
&quot;Toy Story 3 (2010)&quot;
&quot;Toy Story 2 (1999)&quot;
</code></pre><p>There are actually quite a few other options for sort, you can see them with <code>man sort</code>. However, most of them perform functionality which you can get from other tools (such as making the lines unique, which we can do with <code>uniq</code>). You might find some of them useful so don't be shy to explore some of the other options.</p><p>The <code>uniq</code> command removes duplicate lines from a stream of text. Note that this <em>only</em> removes duplicate lines when they are <em>next to each other</em>. This means that you will often have to <code>sort</code> first.</p><p>Here's an example of where I might use <code>uniq</code> - getting all unique error messages in a log file:</p><pre><code>$ cut -c 27- ~/effective-shell/logs/web-server-logs.txt | grep error | sort | uniq

error - Unhandled error EACCES trying to read '../../../website/public/docs/part-1-transitioning-to-the-shell/5-getting-help/index.html', returning a 500
error - Unhandled error EACCES trying to read '../../../website/public/svg/calendar.svg', returning a 500
error - Unhandled error EACCES trying to read '../../../website/public/svg/edit.svg', returning a 500
info - Request: GET /docs/1-getting-started/images/ls-applications-windows-error.png
info - Request: GET /docs/part-1-transitioning-to-the-shell/3-managing-your-files/images/rm-error-directory.png
info - Serving file '../../../website/public/docs/1-getting-started/images/ls-applications-windows-error.png'...
info - Serving file '../../../website/public/docs/part-1-transitioning-to-the-shell/3-managing-your-files/images/rm-error-directory.png'...
</code></pre><p>Let's break this down:</p><ul><li><code>cut -c 27- ~/effective-shell/logs/web-server-logs.txt</code> - extract log messages from a log file, skipping the timestamp</li><li><code>grep error</code> - filter down to lines which contain the text <code>error</code></li><li><code>sort</code> - sort the output</li><li><code>uniq</code> - show only unique values</li></ul><p>This is a powerful technique - if we had thousands of errors in the file, this would make sure we only see <em>distinct</em> errors, rather than showing <em>every</em> error.</p><h1 id=dont-forget-your-pager>Don't Forget Your Pager!</h1><p>In <a href=/docs/part-1-transitioning-to-the-shell/getting-help/>Chapter 5 - Getting Help</a> we talked about the <em>pager</em> - the program your shell uses to make it easier to look through larger text files, giving the option to move backwards and forwards a page at a time (or searching and so on). Don't forget to use your pager when you are working with text. When you are trying to build a pipeline and want to see intermediate results (perhaps <em>before</em> you use <code>head</code> or <code>tail</code>) then you can use the pager to avoid filling your screen and terminal with too much text.</p><p>For example, when looking at the sorted list of films, I might run this:</p><pre>
$ cut -d',' -f 3 ~/effective-shell/data/top100.csv | sort | less

"<strong>Jaws</strong> (1975)"
"King Kong (1933)"
"La Grande illusion (Grand Illusion) (1938)"
"La La Land (2016)"
"Lady Bird (2017)"
"Laura (1944)"

/<strong>Jaws</strong>
</pre><p>I've made the output smaller so that it is easier to see what is happening. In this example I've cut out the film name from my data file, sorted it, then piped the result into <code>less</code> so that I can page through the data and ensure it is correct - I've also searched for the text <code>Jaws</code> to see where it is in the file.</p><h1 id=summary>Summary</h1><p>In this chapter we introduced a number of basic tools which let us work with text.</p><ul><li><code>head</code> will show the first ten lines of a file.</li><li><code>head -n 30</code> will show the first thirty lines of a file, using the <code>-n</code> flag to specify the number of lines.</li><li><code>tail</code> will show the final ten lines of a file.</li><li><code>tail -n 3</code> uses the <code>-n</code> flag to specify three lines only.</li><li>The <code>$HISTFILE</code> environment variable holds the path to the shell command history file.</li><li><code>tail -f $HISTFILE</code> uses the <code>-f</code> flag to <em>follow</em> the file, printing output as it is written to the file.</li><li><code>tr 'a' 'b'</code> is the <em>translate text</em> command, which turns one set of characters into another</li><li><code>tr -d '!'</code> shows how the <code>-d</code> or <em>delete</em> flag can specify characters to delete.</li><li>The <code>cut</code> command can be used to extract parts of a line of text.</li><li><code>cut -d',' -f 3</code> shows how the <code>-d</code> or <em>delimiter</em> flag is used to specify the delimiter to cut on and how the <code>-f</code> or <em>field</em> flag specifies which of the fields the text has been cut into is printed.</li><li><code>cut -c 2-4</code> uses the <code>-c</code> or <em>characters</em> flag to specify that we are extracting a subset of characters in the line, in this case characters two to four.</li><li><code>cut -c 10-</code> cuts from character ten to the end of the line</li><li>The <code>cut</code> command also allows for multiple fields to be specified when cutting by field, such as <code>-f 2,3</code> for the second and third field, or <code>-f 4-</code> for fields four onwards.</li><li><code>rev</code> reverses text - by reversing, cutting and then re-reversing you can quickly extract text from the <em>end</em> of a line.</li><li><code>sort</code> sorts the incoming text alphabetically.</li><li>The <code>-r</code> flag for <code>sort</code> reverses the sort order.</li><li>The <code>uniq</code> command removes duplicate lines - but only when they are next to each other, so you'll often use it in combination with <code>sort</code>.</li><li>Your pager, for example the <code>less</code> program can be useful when inspecting the output of your text transformation commands.</li></ul></article><div class="book-footer justify-between"><div><a class="flex align-center" href=https://github.com/dwmkerr/effective-shell/commit/1bca26c4aff39ab3f7d3d6ebf304980b9de95e40 title="Last modified by github-actions[bot] | Jun 10, 2021" target=_blank><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>Jun 10, 2021</span></a></div><div><a class="flex align-center" href=https://github.com/dwmkerr/effective-shell/edit/master/website/content/docs/part-3-manipulating-text/slice-and-dice-text/_index.md target=_blank><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"effective-shell"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><p>Copyright &copy; <script>document.write(new Date().getFullYear())</script>, Dave Kerr</p></div><aside class="book-toc levels-3 fixed"><nav id=TableOfContents><ul><li><a href=#chapter-15---slice-and-dice-text>Chapter 15 - Slice and Dice Text</a></li><li><a href=#heads-and-tails>Heads and Tails</a></li><li><a href=#replacing-text>Replacing Text</a></li><li><a href=#how-to-cut>How to Cut</a></li><li><a href=#a-trick-with-rev>A Trick with Rev</a></li><li><a href=#sort-and-unique>Sort and Unique</a></li><li><a href=#dont-forget-your-pager>Don't Forget Your Pager!</a></li><li><a href=#summary>Summary</a></li></ul></nav></aside></main></body></html>