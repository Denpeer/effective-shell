<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Build Commands on the Fly"><meta property="og:title" content="Build Commands on the Fly"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://effective-shell.com/docs/part-3-manipulating-text/build-commands-on-the-fly/"><title>Build Commands on the Fly | Effective Shell</title><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.f8520695a602b532b093067e25561bfe6fa10ca8c25171b97142acf58fa8f13c.css integrity="sha256-+FIGlaYCtTKwkwZ+JVYb/m+hDKjCUXG5cUKs9Y+o8Tw="><script defer src=/en.search.min.72fef7b748318abf9aeae24f9c3b34b16c1f49b9b26d045b2c61f46bf8d2f401.js integrity="sha256-cv73t0gxir+a6uJPnDs0sWwfSbmybQRbLGH0a/jS9AE="></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-155335600-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><link rel=alternate type=application/rss+xml href=https://effective-shell.com/docs/part-3-manipulating-text/build-commands-on-the-fly/index.xml title="Effective Shell"></head><body><input type=checkbox class=hidden id=menu-control><main class="flex container"><aside class="book-menu fixed"><nav><h2 class=book-brand><a href=https://effective-shell.com/><span>Effective Shell</span></a></h2><h2 class=book-subtitle><span>By Dave Kerr</span></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/docs/introduction/><strong>Introduction</strong></a></li><li><a href=/docs/getting-started/><strong>Getting Started</strong></a></li><li><a href=/docs/part-1-transitioning-to-the-shell/><strong>Part 1 - Transitioning to the Shell</strong></a><ul><li><a href=/docs/part-1-transitioning-to-the-shell/navigating-your-system/>Navigating Your System</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/managing-your-files/>Managing Your Files</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/clipboard-gymnastics/>Clipboard Gymnastics</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/getting-help/>Getting Help</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/the-renaissance-of-the-shell/>The Renaissance of the Shell</a></li></ul></li><li><a href=/docs/part-2-core-skills/><strong>Part 2 - Core Skills</strong></a><ul><li><a href=/docs/part-2-core-skills/thinking-in-pipelines/>Thinking in Pipelines</a></li><li><a href=/docs/part-2-core-skills/fly-on-the-command-line/>Fly on the Command Line</a></li><li><a href=/docs/part-2-core-skills/job-control/>Job Control</a></li><li><a href=/docs/part-2-core-skills/understanding-commands/>Understanding Commands</a></li><li><a href=/docs/part-2-core-skills/finding-files/>Finding Files</a></li><li><a href=/docs/part-2-core-skills/what-is-a-shell/>What is a Shell?</a></li></ul></li><li><a href=/docs/part-3-manipulating-text/><strong>Part 3 - Manipulating Text</strong></a><ul><li><a href=/docs/part-3-manipulating-text/get-to-grips-with-grep/>Get to Grips with Grep</a></li><li><a href=/docs/part-3-manipulating-text/slice-and-dice-text/>Slice and Dice Text</a></li><li><a href=/docs/part-3-manipulating-text/advanced-text-manipulation/>Advanced Text Manipulation with Sed</a></li><li><a href=/docs/part-3-manipulating-text/build-commands-on-the-fly/ class=active>Build Commands on the Fly with Xargs</a></li><li><a href=/docs/part-3-manipulating-text/regex-essentials/>Regex Essentials</a></li></ul></li><li><a href=/docs/work-in-progress/><strong>Work in Progress</strong></a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class="flex align-center justify-between book-header"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Build Commands on the Fly</strong></header><article class=markdown><h1 id=chapter-17---build-commands-on-the-fly-with-xargs>Chapter 17 - Build Commands on the Fly with Xargs</h1><p>In the earlier chapters of this part of the book we've seen a number of ways to manipulate text. Now we're going to introduce the <code>xargs</code> command and show how to use our text manipulation skills to dynamically build complex commands on the fly.</p><h1 id=introducing-xargs>Introducing Xargs</h1><p>The <code>xargs</code> [<em>build and execute commands</em>] command takes input, uses the input to create commands, then executes the commands. I tend to remember it as &ldquo;Execute with Arguments&rdquo; as the name <code>xargs</code> sounds a little odd!</p><p>How <code>xargs</code> is used is probably easiest to see with an example. Let's use it to build a set of commands which will remove any empty files from a folder.</p><p>Before we show <code>xargs</code> let's create some empty files which we'll later clean up:</p><pre><code>$ mkdir -p ~/effective-shell/tmp
$ cd ~/effective-shell/tmp
$ touch file{1..100}.txt
</code></pre><p>We're using a nice shell trick here called <em>Brace Expansion</em> - the shell will expand <code>file{1..100}.txt</code> into <code>file1.txt</code>, <code>file2.txt</code> and so on, all the way to <code>file100.txt</code>.</p><p>We could just look for empty files in our <code>/tmp</code> folder for this example, but a file in that folder might be in use, so a safer way to demonstrate <code>xargs</code> is to use some temporary files which we create ourselves.</p><p>We could search for empty files with the command below:</p><pre><code>$ find . -empty
file1.txt
file2.txt
file3.txt
file4.txt
file5.txt
...
</code></pre><blockquote class="book-hint info"><p><strong>A refresher on Finding Files</strong></p><p>In this chapter we'll be using the <code>find</code> (<em>find files and folders</em>) command a lot - if you need a refresher, check <a href=/docs/part-2-core-skills/finding-files/>Chapter 11 - Finding Files</a>.</p></blockquote><p>The <code>find</code> command has outputted a list of files, now we want to use the <code>rm</code> (<em>remove file</em>) command to delete each one. Let's just <em>pipe</em> the list of files to the <code>rm</code> command, check <a href=/docs/part-2-core-skills/thinking-in-pipelines/>Chapter 7 - Thinking in Pipelines</a> if you need a reminder of how piping works:</p><pre><code>$ find . -empty | rm
rm: missing operand
Try 'rm --help' for more information.
</code></pre><p>What's going on here? Well basically the issue is that the <code>rm</code> command doesn't actually read the list of files from <em>stdin</em>, the list of files has to be passed as a parameter to the command. How can we take this list of files and pass it to <code>rm</code> as a set of parameters?</p><p>This is what <code>xargs</code> is for! Before we delete the files, let's just see what happens when we pass the list to <code>xargs</code>:</p><pre><code>$ find . -empty | xargs
./file40.txt ./file8.txt ./file35.txt ./file81.txt ...
</code></pre><p>By default <code>xargs</code> take the input, joins each line together with a space and then passes it to the <code>echo</code> command. The <code>echo</code> command writes it out to the screen.</p><p>We can change the command <code>xargs</code> passes the arguments to:</p><pre><code>$ find . -empty | xargs echo rm
rm ./file40.txt ./file8.txt ./file35.txt ./file81.txt ...
</code></pre><p>Very interesting! Now we've told <code>xargs</code> to pass the output to the <code>echo rm</code> command - this just writes out <code>rm</code> followed by the list of files. Putting <code>echo</code> before whatever command you want to run is a useful way to <em>check</em> the command before we commit to running it.</p><p>Let's finish the job and delete each file:</p><pre><code>$ find . -empty | xargs rm
</code></pre><p>Done! You can run <code>ls</code> to confirm that the file has been deleted.</p><p>This is <code>xargs</code> - it <em>constructs and executes</em> a command using <em>arguments</em> from <em>standard input</em>. Now let's see how we can take this further.</p><h1 id=handling-whitespace-special-characters-and-tracing>Handling Whitespace, Special Characters and Tracing</h1><p>One common challenge with <code>xargs</code> is how to deal with spaces. To see what I mean, let's create three files with spaces in the names:</p><pre><code>$ touch &quot;chapter &quot;{1,2,3}.md
$ find . -type f
./chapter 1.md
./chapter 2.md
./chapter 3.md
</code></pre><p>What if we wanted to delete these files? Let's try that with <code>rm</code>:</p><pre><code>$ find . -type f | xargs rm
rm: cannot remove './chapter': No such file or directory
rm: cannot remove '1.md': No such file or directory
...
</code></pre><p>The file name has a space in it, which is confusing <code>rm</code> as it thinks we're providing six paths rather than three.</p><p>We can use the <code>-t</code> (<em>trace</em>) option to see what <code>xargs</code> actually tried to do:</p><pre><code>$ find . -type f | xargs -t rm
rm ./chapter 1.md ./chapter 2.md ./chapter 3.md
...
</code></pre><p>Hopefully you can spot the error - the <code>rm</code> command thinks it needs to remove six files, because there are spaces in the filenames and there are not quotes around the filenames to let <code>rm</code> know this!</p><p>Fortunately, <code>find</code> loves <code>xargs</code> - they are part of the same package of tools (which is called &lsquo;findutils&rsquo;). And there's a special pair of options that can deal with this.</p><p>For find, we are going to use the <code>-print0</code> action and for <code>xargs</code> we'll use the <code>-0</code> option. Let's see how it looks now, then describe what's going on under the hood:</p><pre><code>$ find . -type f -print0 | xargs -0 -t rm
rm './chapter 1.md' './chapter 2.md' './chapter 3.md' 
</code></pre><p>In <a href=/docs/part-2-core-skills/finding-files/>Chapter 11 - Finding Files</a> we saw that the <em>default</em> action of the <code>find</code> command is <code>-print</code>, which writes out the path of each item found. The <code>-print0</code> action is very similar - but it instead it writes out each item followed by a special &lsquo;null&rsquo; character<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><p>Now that we've told <code>find</code> to end each result with a special &lsquo;null&rsquo; character, we just tell <code>xargs</code> that the &lsquo;null&rsquo; character is what separates each line of input. We do this with the <code>-0</code> (<em>use NUL as separators</em>) option.</p><p>You don't need to really understand the internals - if you are a computer programmer it might make sense, this is how strings in things like the C Programming language work. All you need to know is that it means the <code>xargs</code> program won't get confused when it sees spaces, tabs, quotes, newlines, or anything else which might be goofy in a file name.</p><p>My recommendation would be to <em>always</em> pair up the <code>-print0</code> action with the <code>-0</code> option - it means you won't get caught out by odd file names. And definitely make use of the <code>-t</code> (<em>trace</em>) option to see what <code>xargs</code> is actually doing!</p><h1 id=one-command-or-many-commands>One Command or Many Commands?</h1><p>By default <code>xargs</code> takes all of the input and passes it as a <em>set</em> of arguments to the provided command. We can see this below:</p><pre><code>$ touch file{1..5}
$ find . -type f | xargs echo
./file1 ./file2 ./file3 ./file4 ./file5
</code></pre><p>We don't need to provide <code>echo</code> to <code>xargs</code>, it is the default, but I have added it for clarity. But what is really important is that we have called <code>echo</code> once and once only.</p><p><code>xargs</code> has passed <em>all</em> of the arguments it has been given to the command.</p><p>We can tell <code>xargs</code> how many lines of input it should use for the command with the <code>-L</code> (<em>max lines</em>) parameter:</p><pre><code>$ find . -type f | xargs -L 1 echo
./file1
./file2
./file3
./file4
./file5
</code></pre><p>We've now called the <code>echo</code> command once for each line of input, meaning that <code>echo</code> has been called five times.</p><p>In general if you can provide all of the arguments to a single command the system may be able to process the command slightly faster. However, if there are lots of arguments, the command itself might not be able to handle all of the arguments you give it.</p><p>You can set <code>-L</code> to other values too - <code>xargs</code> will use up to the number of lines provided:</p><pre><code>$ find . -type f | xargs -L 3 echo
./file1 ./file2 ./file3
./file4 ./file5
</code></pre><p>Here we've allowed up to three input lines per command.</p><p>You will probably <em>not</em> use the <code>-L</code> parameter very often, but it is really important that you understand what it does. And that is because many of the other options we'll use <em>imply</em> <code>-L 1</code> - we'll see why in the next example.</p><pre><code>find . -name &quot;chapter*&quot; | xargs rm
rm: cannot remove './chapter': No such file or directory
rm: cannot remove '1.txt': No such file or directory
</code></pre><h1 id=constructing-more-complex-commands-with-the-i-parameter>Constructing more complex commands with the &lsquo;I&rsquo; Parameter</h1><p>You have probably noticed by now that the <code>xargs</code> command puts the arguments it is given at the end of the command you write.</p><p>What if you need the arguments to go somewhere else? For example, what if I wanted to copy every text file in a folder to another location?</p><p>Here's how we might start - and what'll go wrong!</p><pre><code>$ find . -name &quot;*.txt&quot; -print0 | xargs -0 -t cp ~/backups
cp /home/dwmkerr/backups ./file2.txt ./file3.txt ./file1.txt
cp: target './file1.txt' is not a directory
</code></pre><p>The problem is that the destination location for where we copy the files has to be the <em>last</em> parameter - but <code>xargs</code> puts the list of files at the end of the command.</p><p>And by the way - we've used the <code>-0</code> parameter to make sure that funny filenames are handled properly (a good habit to get into) and the <code>-t</code> parameter to trace - which means we see the command which will be run.</p><p>So we need to tell <code>xargs</code> where to put the list of arguments. We can do that with the <code>-I</code> (<em>replace string</em>) parameter. This parameter lets us tell <code>xargs</code> exactly where we want to put the arguments:</p><pre><code>$ find . -name &quot;*.txt&quot; -print0 | xargs -0 -t -I {} cp {} ~/backups
cp ./file2.txt /home/dwmkerr/backups
cp ./file3.txt /home/dwmkerr/backups
cp ./file1.txt /home/dwmkerr/backups
</code></pre><p>Here we have set the &lsquo;replacement string&rsquo; to be <code>{}</code>. This means when <code>xargs</code> sees <code>{}</code> in the command it will replace it with the arguments we provide as its input.</p><p>The first observation you might make is that as soon as we use the <code>-I</code> parameter it <em>automatically</em> implies that we use the <code>-L 1</code> parameter, i.e. we run the command once for each individual input line.</p><p>For the example we have shown above, this isn't really necessary, <code>xargs</code> could just write all of the arguments. The reason <code>xargs</code> does this is that we are not actually limited to using the replacement once only - we can use it multiple times.</p><p>Here's a similar example, but in this one we put <code>.bak</code> at the end of each filename as we copy it:</p><pre><code>$ find . -name &quot;*.txt&quot; -print0 | xargs -0 -t -I {} cp {} ~/backups/{}.bak
cp ./file2.txt /home/dwmkerr/backups/./file2.txt.bak
cp ./file3.txt /home/dwmkerr/backups/./file3.txt.bak
cp ./file1.txt /home/dwmkerr/backups/./file1.txt.bak
</code></pre><p>Because we can use the replacement string multiple times, <code>xargs</code> splits up the commands so it is one command per input argument. If it didn't do this and we tried the command above it would not work properly.</p><p>The <code>-I</code> parameter is incredibly powerful, it lets us construct complex commands.</p><p>You don't need to use the <code>{}</code> letters as the replacement string, any sequence of characters will work. For example:</p><pre><code>$ env | xargs -I % echo &quot;You have env var: % set!&quot;
You have env var: SHELL=/bin/bash set!
You have env var: COLORTERM=truecolor set!
You have env var: EDITOR=vi set!
</code></pre><p>In this example we used <code>%</code> as the replacement string.</p><p>You might wonder why is <code>{}</code> so commonly used in examples or the manpages. The reason is that this is the default replacement string used by <code>find</code> if we perform an action like <code>-exec</code>:</p><pre><code>$ find . -type f -empty -exec stat {} \;
</code></pre><p>The <code>{}</code> characters are used as the placeholder for files found with the <code>find</code> command, so people often use the same placeholder for <code>xargs</code>, but you are not required to use these characters.</p><h1 id=requesting-confirmation-with-the-prompt-option>Requesting Confirmation with the Prompt Option</h1><p>The <code>-p</code> (<em>prompt</em>) option tells <code>xargs</code> to ask the user to confirm each command before it is run.</p><p>Let's test this out by deleting a set of &lsquo;pods&rsquo; from a Kubernetes cluster. You don't have to worry about what a Kubernetes cluster is, I'm just using this as an example to highlight that you don't have to be limited to using <code>find</code> as the input for <code>xargs</code>!</p><p>On my machine I can show the pods available to me in my cluster with this command:</p><pre><code>$ kubectl get pods -o name
pod/my-app
pod/nginx
pod/postgres
</code></pre><p>Three pods are shown. I could use this command to build input to <code>xargs</code> to let me to chose which pods to delete, interactively:</p><pre><code>$ kubectl get pods -o name | xargs -L 1 -p kubectl delete
kubectl --context minikube delete pod/my-app?...n
kubectl --context minikube delete pod/nginx?...y
pod &quot;nginx&quot; deleted
kubectl --context minikube delete pod/postgres?...n
</code></pre><p>This is fantastic! We've used <code>-L 1</code> to make sure that we only deal with one pod at a time (rather than trying to delete all three at once) and the <code>-p</code> flag to ask the user to press &lsquo;y&rsquo; or &lsquo;n&rsquo; in each case. The <code>xargs</code> command helpfully shows us what it is going to do and asks for confirmation first.</p><p>I think this really hints at the true power of <code>xargs</code> - yes it can be combined with <code>find</code> to perform operations on files, but it can also be used with other tools to build more complex operations.</p><h1 id=splitting-up-input-with-a-delimiter>Splitting up Input with a Delimiter</h1><p>We can ask the user whether they want to see files in <em>all</em> of their &lsquo;path&rsquo; locations with the command below:</p><pre><code>$ echo $PATH | xargs -d ':' -p -L 1 ls
ls /home/dwmkerr/.pyenv/shims ?...n
ls /home/dwmkerr/.nvm/versions/node/v14.15.1/bin ?...n
</code></pre><p>The <code>$PATH</code> environment variable holds all of the folders the shell will search in for binaries - and each folder is separated by a <code>:</code> colon character (you can read more about <code>$PATH</code> in <a href=/docs/part-2-core-skills/finding-files/>Chapter 10 - Understanding Commands</a>.</p><p>We use the <code>-d</code> (<em>delimiter</em>) parameter to tell <code>xargs</code> that each argument in the input is separated with a colon. We also use the <code>-L 1</code> and <code>-p</code> parameters to process this input one folder at a time and ask the user if they want to see the contents of the folder.</p><h1 id=summary>Summary</h1><p>In this chapter we introduced <code>xargs</code>, a powerful command which allows us to build other commands on the fly. We can trace, showing how the resulting command will look, ask the user for confirmation, control how many commands we run and more.</p><p>There are more options for the <code>xargs</code> command, you can read all about them with <code>man xargs</code>. But I think if you learn the key parameters we've shown in this chapter you'll be well equipped to use <code>xargs</code> in your day to day wok.</p><p>In the next chapter we'll look at some of the advanced features which are built into most shells which allow us to manipulate text.</p><hr><p><strong>Footnotes</strong></p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>The character is ASCII NUL, which is the number zero. This is often used in programming to represent &lsquo;null&rsquo; or &lsquo;nothing at all&rsquo;, not the <em>digit</em> zero as is used when printing to the screen, which is actually represented by number 30. You can see the actual ASCII table with <code>man ascii</code>. <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></article><div class="book-footer justify-between"><div><a class="flex align-center" href=https://github.com/dwmkerr/effective-shell/commit/0a17b177dec5918201f194046e2917eb87e1871f title="Last modified by Dave Kerr | Apr 3, 2021" target=_blank><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>Apr 3, 2021</span></a></div><div><a class="flex align-center" href=https://github.com/dwmkerr/effective-shell/edit/master/website/content/docs/part-3-manipulating-text/build-commands-on-the-fly/_index.md target=_blank><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"effective-shell"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><p>Copyright &copy; <script>document.write(new Date().getFullYear())</script>, Dave Kerr</p></div><aside class="book-toc levels-3 fixed"><nav id=TableOfContents><ul><li><a href=#chapter-17---build-commands-on-the-fly-with-xargs>Chapter 17 - Build Commands on the Fly with Xargs</a></li><li><a href=#introducing-xargs>Introducing Xargs</a></li><li><a href=#handling-whitespace-special-characters-and-tracing>Handling Whitespace, Special Characters and Tracing</a></li><li><a href=#one-command-or-many-commands>One Command or Many Commands?</a></li><li><a href=#constructing-more-complex-commands-with-the-i-parameter>Constructing more complex commands with the &lsquo;I&rsquo; Parameter</a></li><li><a href=#requesting-confirmation-with-the-prompt-option>Requesting Confirmation with the Prompt Option</a></li><li><a href=#splitting-up-input-with-a-delimiter>Splitting up Input with a Delimiter</a></li><li><a href=#summary>Summary</a></li></ul></nav></aside></main></body></html>