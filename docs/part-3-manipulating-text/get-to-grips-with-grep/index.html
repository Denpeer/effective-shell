<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Get to Grips with Grep"><meta property="og:title" content="Get to Grips with Grep"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://effective-shell.com/docs/part-3-manipulating-text/get-to-grips-with-grep/"><title>Get to Grips with Grep | Effective Shell</title><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.f8520695a602b532b093067e25561bfe6fa10ca8c25171b97142acf58fa8f13c.css integrity="sha256-+FIGlaYCtTKwkwZ+JVYb/m+hDKjCUXG5cUKs9Y+o8Tw="><script defer src=/en.search.min.e0b4846a73b8d514246bd1f61df1f5d19ae8bbd72a101ec5b8d3911bca5db452.js integrity="sha256-4LSEanO41RQka9H2HfH10Zrou9cqEB7FuNORG8pdtFI="></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-155335600-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><link rel=alternate type=application/rss+xml href=https://effective-shell.com/docs/part-3-manipulating-text/get-to-grips-with-grep/index.xml title="Effective Shell"><script id=mcjs>!function(c,h,i,m,p){m=c.createElement(h),p=c.getElementsByTagName(h)[0],m.async=1,m.src=i,p.parentNode.insertBefore(m,p)}(document,"script","https://chimpstatic.com/mcjs-connected/js/users/eac1a082b6db34d40aaff2caf/a2aaca5a8358c2e12d3f43f1a.js");</script></head><body><input type=checkbox class=hidden id=menu-control><main class="flex container"><aside class="book-menu fixed"><nav><h2 class=book-brand><a href=https://effective-shell.com/><span>Effective Shell</span></a></h2><h2 class=book-subtitle><span>By Dave Kerr</span></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/docs/introduction/><strong>Introduction</strong></a></li><li><a href=/docs/getting-started/><strong>Getting Started</strong></a></li><li><a href=/docs/part-1-transitioning-to-the-shell/><strong>Part 1 - Transitioning to the Shell</strong></a><ul><li><a href=/docs/part-1-transitioning-to-the-shell/navigating-your-system/>Navigating Your System</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/managing-your-files/>Managing Your Files</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/clipboard-gymnastics/>Clipboard Gymnastics</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/getting-help/>Getting Help</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/the-renaissance-of-the-shell/>The Renaissance of the Shell</a></li></ul></li><li><a href=/docs/part-2-core-skills/><strong>Part 2 - Core Skills</strong></a><ul><li><a href=/docs/part-2-core-skills/thinking-in-pipelines/>Thinking in Pipelines</a></li><li><a href=/docs/part-2-core-skills/fly-on-the-command-line/>Fly on the Command Line</a></li><li><a href=/docs/part-2-core-skills/job-control/>Job Control</a></li><li><a href=/docs/part-2-core-skills/understanding-commands/>Understanding Commands</a></li><li><a href=/docs/part-2-core-skills/finding-files/>Finding Files</a></li><li><a href=/docs/part-2-core-skills/what-is-a-shell/>What is a Shell?</a></li></ul></li><li><a href=/docs/part-3-manipulating-text/><strong>Part 3 - Manipulating Text</strong></a><ul><li><a href=/docs/part-3-manipulating-text/regex-essentials/>Regex Essentials</a></li><li><a href=/docs/part-3-manipulating-text/get-to-grips-with-grep/ class=active>Get to Grips with Grep</a></li><li><a href=/docs/part-3-manipulating-text/slice-and-dice-text/>Slice and Dice Text</a></li><li><a href=/docs/part-3-manipulating-text/advanced-text-manipulation/>Advanced Text Manipulation with Sed</a></li><li><a href=/docs/part-3-manipulating-text/build-commands-on-the-fly/>Build Commands on the Fly with Xargs</a></li></ul></li><li><a href=/docs/part-4-shell-scripting/><strong>Part 4 - Shell Scripting</strong></a><ul><li><a href=/docs/part-4-shell-scripting/shell-script-essentials/>Shell Script Essentials</a></li><li><a href=/docs/part-4-shell-scripting/variables-reading-input-and-mathematics/>Variables, Reading Input, and Mathematics</a></li><li><a href=/docs/part-4-shell-scripting/mastering-conditional-logic/>Mastering Conditional Logic</a></li><li><a href=/docs/part-4-shell-scripting/loops-and-working-with-files-and-folders/>Loops and working with Files and Folders</a></li><li><a href=/docs/part-4-shell-scripting/functions-parameters-and-error-handling/>Functions, Parameters and Error Handling</a></li><li><a href=/docs/part-4-shell-scripting/useful-patterns-for-shell-scripts/>Useful Patterns for Shell Scripts</a></li></ul></li><li><a href=/docs/part-5-building-your-toolkit/><strong>Part 5 - Building Your Toolkit</strong></a><ul><li><a href=/docs/part-5-building-your-toolkit/configuring-the-shell/>Configuring the Shell</a></li></ul></li><li><a href=/docs/work-in-progress/><strong>Work in Progress</strong></a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class="flex align-center justify-between book-header"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Get to Grips with Grep</strong></header><article class=markdown><h1 id=chapter-14---get-to-grips-with-grep>Chapter 14 - Get to Grips with Grep</h1><p>The <code>grep</code> tool is a real workhorse for shell users - once you've learned how to use it you will find yourself using it again and again. In this chapter we'll see how you can use <code>grep</code> for common tasks, and how to use it in combination with other tools.</p><p>As with the other tools we'll introduce in this chapter, we'll also look at when <code>grep</code> is the right tool for the job and when we should consider other options.</p><h1 id=what-is-grep>What is Grep</h1><p>A quick check of the manual page for <code>grep</code> gives an overview:</p><pre><code>$ man grep

GREP(1)                   BSD General Commands Manual                  GREP(1)

NAME
     grep, egrep, fgrep, zgrep, zegrep, zfgrep -- file pattern searcher

SYNOPSIS
     grep [-abcdDEFGHhIiJLlmnOopqRSsUVvwxZ] [-A num] [-B num] [-C[num]] [-e pattern] [-f file]
          [--binary-files=value] [--color[=when]] [--colour[=when]] [--context[=num]] [--label]
          [--line-buffered] [--null] [pattern] [file ...]

DESCRIPTION
     The grep utility searches any given input files, selecting lines that match one or more
     patterns.  By default, a pattern matches an input line if the regular expression (RE) in
     the pattern matches the input line without its trailing newline.  An empty expression
     matches every line.  Each input line that matches at least one of the patterns is written
     to the standard output.
</code></pre><p>Wow. Lots of options for this command. And confusingly, lots of alternative forms as well (such as <code>egrep</code>, <code>zgrep</code> and so on).</p><p>Maybe the <code>tldr</code> tool will provide a more concise overview?</p><pre><code>$ tldr grep

  grep

  Matches patterns in input text.
  Supports simple patterns and regular expressions.
</code></pre><p>That is indeed a little more concise. By the way, if you are not familiar with how you can get help on commands, check out <a href=/docs/part-1-transitioning-to-the-shell/getting-help/>Chapter 5 - Getting Help</a>. As the manual pages indicate, <code>grep</code> is used to match patterns in files. More advanced users will most likely know exactly what this means, but a more simple description is just:</p><blockquote><p>Grep lets you search for text or filter text.</p></blockquote><p>That's it. You can search in files, but you are not <em>limited</em> to searching in files. And you can search for <em>literal</em> text, such as the word &lsquo;error&rsquo;, or you can search for <em>patterns</em>. <em>Patterns</em> in this case means <em>regular expressions</em> - expressions which allow you to be more specific in how you search (such as looking for a set of 16 numbers in a row, like a credit card number, or any text which looks like an email address). You can also do the opposite - filtering out parts of text.</p><p>We'll use <code>grep</code> to search through text. Let's get straight into it!</p><h1 id=why-grep>Why Grep?</h1><p>Why the odd name? Grep is such a commonly used tool that the name has become a verb amongst technologists (people will often suggest you <em>grep</em> for something in files).</p><p>The name comes from a command which was used in the original <code>ed</code> text editor - the command:</p><pre><code>g/re/p
</code></pre><p>This command ran on all lines (<code>g</code>, for <em>global</em>), applied a regular expression (<code>re</code>, for <em>regular expression</em>) and then printed (<code>p</code> for <em>print</em>) the results. A colleague of Ken Thompson, one of the early innovators and inventors in the Unix world, needed to edit a large file - a file which was too large to fit in <code>ed</code>. Ken wrote the <code>grep</code> program overnight to allow the file's text to be filtered - and the results passed to the <code>ed</code> editor!</p><p>You can read more about this story and some of the fascinating history of the early days of Unix in a <a href="https://www.youtube.com/watch?v=NTfOnGZUZDk&feature=emb_title">great interview with Brian Kerninghan</a> from Computerphile<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><h1 id=searching-through-text>Searching Through Text</h1><p>If you've been working through this book, you've probably entered quite a few commands in the shell. Most shells keep a history of the commands you type. Under the hood, when you use the up and down keys to look through commands you entered earlier, or use the <code>Ctrl-R</code> shortcut to <em>search</em> through earlier commands, your shell is looking through this file. If these tricks are not familiar, check <a href=/docs/part-2-core-skills/fly-on-the-command-line/>Chapter 9 - Fly on the Command Line</a>.</p><p>The file which keeps the history can vary from shell to shell. For example, on my system, my history for Bash is in the file <code>~/.bash_history</code>. But most &lsquo;Bash-like&rsquo; shells provide a built-in environment variable which let's you find the path of the shell history. Let's at this file:</p><pre><code>cat $HISTFILE

...
cat ~/.ssh/config
ssh bastion.cloudops
help echo
help cd
exit
</code></pre><p>This file will generally contain a list of the commands that the logged in user has entered in their shell. This file will likely be huge. Let's search through it using <code>grep</code>! Here's how we can use the <code>grep</code> command to search for lines which contain the text <code>man</code>:</p><pre>
grep man $HISTFILE

...
<strong>man</strong> socket
k describe services eventstoredb-http-<strong>man</strong>agement
<strong>man</strong> cal
gcb refactor/perfor<strong>man</strong>ce/standardise-eventstore
vi src/tests/handlers/test_com<strong>man</strong>d_handlers.py
gco src/handlers/com<strong>man</strong>d_handlers.py
gcb feat/perfor<strong>man</strong>ce/use-eventstore-writer
nvim perfor<strong>man</strong>ce.md
<strong>man</strong> grep
</pre><p>Here I can see all of the commands I have recently entered which have the text <code>man</code> in them. Note that the text which matches is highlighted and shown in bold.</p><p>Now what if you a different shell, or forget where the history file lives? A nice trick here is to use the <code>history</code> command. This command prints out the history, as well as the line number. The <code>history</code> command writes to <code>stdout</code>. If we don't give <code>grep</code> a source file, it will simply search through <code>stdin</code>. Just as we learnt in <a href=/docs/part-2-core-skills/thinking-in-pipelines/>Chapter 7 - Thinking in Pipelines</a> this means we can just <code>grep</code> the output of the <code>history</code> command!</p><p>Here's how that would work:</p><pre>
history | grep man

...
 9125  <strong>man</strong> socket
 9188  k describe services eventstoredb-http-<strong>man</strong>agement
 9211  <strong>man</strong> cal
 9341  gcb refactor/perfor<strong>man</strong>ce/standardise-eventstore
 9344  vi src/tests/handlers/test_com<strong>man</strong>d_handlers.py
 9347  gco src/handlers/com<strong>man</strong>d_handlers.py
 9352  gcb feat/perfor<strong>man</strong>ce/use-eventstore-writer
 9355  nvim perfor<strong>man</strong>ce.md
10002  <strong>man</strong> grep
</pre><p>This is easier to remember! There's one more cool trick - if we just type in the exclamation point symbol followed by any line number shown above, we repeat the command! For example, typing in:</p><pre><code>!9355
</code></pre><p>Would repeat line <code>9355</code> of the history (which is <code>nvim performance.md</code>).</p><h1 id=using-patterns>Using Patterns</h1><p>Now as you can see from the output above, when we searched through my history, we didn't just find times I executed the <code>man</code> command - we found <em>any</em> line which has the characters <code>man</code> in it. What about if we only wanted to find the lines which start with <code>man</code>?</p><p>To perform a search like this, we can use a <em>regular expression</em>. Here's how it would work:</p><pre>
history | grep "[0-9]\+  man"

...
 <strong>9125  man</strong> socket
 <strong>9211  man</strong> cal
<strong>10002  man</strong> grep
</pre><p>Let's break this down. In this search, we are using a <em>pattern</em> to search for text. The pattern in this case is a <em>basic regular expression</em>. Regular expressions allow us to use some clever constructs to search for text. The expression we've used is made up of the following components:</p><ul><li><code>[0-9]\+</code> At least one number - any character in the range zero to nine.</li><li><code>man</code> The literal text written, i.e. two spaces and the letters <code>man</code>.</li></ul><p>Now for anyone who is familiar with regular expressions, you might wonder why we have a slash before the <code>+</code> symbol, when the <code>+</code> symbol has a specific meaning in regular expressions (it means &lsquo;at least one of the previous characters). The reason we have a leading slash is that by default <code>grep</code> is using <em>basic regular expressions</em>. In general, this will be less familiar for users and will be different to what they are used to from different tools.</p><p>To make regular expressions more &lsquo;standard&rsquo;, we can use the <code>-E</code> flag to tell <code>grep</code> to use <em>Extended Regular Expressions</em>. We can also use the <code>egrep</code> tool, which assumes the pattern will be an extended regular expression. Using either approach will work, and allow you to re-write the pattern as below:</p><pre><code>history | grep -E &quot;[0-9]+  man&quot;

# ...or...

history | egrep &quot;[0-9]+  man&quot;
</code></pre><p>This is just a little hint of the power of regular expressions. They can be daunting at first, and many people never become comfortable with them, but I would strongly encourage you to start exploring them.</p><blockquote class="book-hint info"><p><strong>Getting Help on Regular Expressions</strong><br>If you want to find out more about the difference between the slightly old-fashioned <em>basic</em> regular expressions and modern regular expressions, you can use:</p><pre><code>man re_format
</code></pre><p>This manpage gives lots of information on regular expressions, including the differences between basic and extended patterns.</p></blockquote><p>If you ever want to see how a regular expression works, try using the website <a href=https://regex101.com>regex101.com</a>. It let's you test out regular expressions and also describes exactly how they work. For example, if I enter the regular expression we just used I'll see this:</p><p><img src=images/regex101.png width=800px alt="Screenshot of the 'regex101' website"></p><p>We're going to see more about regular expressions as we go through the book.</p><h1 id=finding-problems>Finding Problems</h1><p>If there's one command I use a lot, it's this:</p><pre><code>grep -i err
</code></pre><p>The <code>-i</code> flag makes the search case-insensitive. This makes this a very quick way to scan through a file for any text which matches the letters <code>err</code> - making it a very quick way to find <em>errors</em> in log files.</p><p>You can try this out by using some of the log files in the <code>logs</code> folder of the playground. Here's how you can try it out:</p><pre>
grep -i err ~/effective-shell/logs/web-server-logs.txt

...
2020-11-29T12:50:30.594Z: info - Serving file '../../../website/public/docs/part-2-core-skills/7-thinking-in-pipelines/images/diagram-std<strong>err</strong>-redirect.png'...
2020-11-29T12:50:31.827Z: <strong>err</strong>or - Unhandled <strong>err</strong>or EACCES trying to read '../../../website/public/svg/calendar.svg', returning a 500
2020-11-29T12:50:31.827Z: <strong>err</strong>or - Unhandled <strong>err</strong>or EACCES trying to read '../../../website/public/svg/calendar.svg', returning a 500
2020-11-29T12:50:31.827Z: <strong>err</strong>or - Unhandled <strong>err</strong>or EACCES trying to read '../../../website/public/svg/calendar.svg', returning a 500
2020-11-29T12:50:31.848Z: <strong>err</strong>or - Unhandled <strong>err</strong>or EACCES trying to read '../../../website/public/svg/edit.svg', returning a 500
2020-11-29T12:50:31.849Z: <strong>err</strong>or - Unhandled <strong>err</strong>or EACCES trying to read '../../../website/public/svg/edit.svg', returning a 500
</pre><p>This is a very useful trick. You could use this technique to search for warnings, problems, specific messages and so on.</p><h1 id=the-abc-of-grep>The ABC of Grep</h1><p>There are three <em>really</em> useful parameters for <code>grep</code>, which I used to struggle to remember, until I realised that they are simple - ABC!</p><p>Here's how they work:</p><pre>
$ grep host -A 3 ./programs/web-server/web-server.js
  <strong>host</strong>: process.env.HOST || 'local<strong>host</strong>',
  port: process.env.PORT || getOptonalEnvInt('PORT', 8080),
  root: process.env.ROOT || process.cwd(),
  defaultPage: 'index.html',
--
  httpServer.listen({ <strong>host</strong>: config.<strong>host</strong>, port: config.port });
  log.info(`Server running on: ${config.<strong>host</strong>}:${config.port}`);
}
main();
</pre><p><code>A</code> stands for <em>after</em>. In this example we show the three lines after each occurrence of the work <code>host</code> in the <code>web-server.js</code> script. This is a quick way to see how something you search for might be used!</p><p><code>B</code> stands for <em>before</em> - we can use this to see what comes <em>before</em> a match when we're searching. What can lead to us sending an error in our web server? Let's see:</p><pre>
$ grep throw -B 5 ./programs/web-server/web-server.js

//  Helper to return an optional numeric environment variable or the default.
function getOptonalEnvInt(name, defaultValue) {
  const val = process.env[name];
  if (!val) return defaultValue;
  const intVal = parseInt(val, 10);
  if (isNaN(intVal)) <strong>throw</strong> new Error(`Unable to parse environment variable named '${name}' with value '${val}' into an integer`);
</pre><p>And finally <code>C</code>, the most useful of them all. <code>C</code> stands for <em>context</em>, and lets you see a number of lines <em>before and after</em> each match. What was I up to the last time I ran the <code>git init</code> command? Let's see!</p><pre>
$ history | grep -C 5 'git init'
 5802  git push --follow-tags && git push origin
 5803  cd ../java-maven-standard-version-sample
 5804  rm -rg .git
 5805  rm -rf git
 5806  rm -rf .idea
 5807  <strong>git init</strong> -h
 5808  git remote add origin git@github.com:dwmkerr/java-maven-standard-version-sample.git
 5809  git push origin -u
 5810  git push -u origin
 5811  git push --set-upstream origin master
 5812  git rm --cached tpm
</pre><p>Don't forget that these flags need to be capitalised! These three flags are <em>very</em> useful - knowing how to find context of a match can be a lifesaver when quickly searching through text.</p><h1 id=working-with-multiple-files>Working with Multiple Files</h1><p>What about if you have a bunch of files you want to search? One problem we have at the moment is that everything we search through has been a single file. But if we are searching through multiple files, how can we identify where the matches come from?</p><p>There's a useful pair of flags for this. <code>-H</code> stands for &lsquo;header&rsquo;, which shows the file name before each match. <code>-n</code> stands for &lsquo;number&rsquo;, which makes sure the line number is shown. Here's how we might use this command:</p><pre>
$ grep -Hn ERROR ./logs/apm-logs/*.logs

...
./logs/apm-logs/apm02.logs:34893:2020-11-27T12:24:37.429Z       <strong>ERROR</strong>   [request]       middleware/log_middleware.go:95unauthorized     {"request_id": "53a41a98-ba12-454e-aadf-72c97dc40e96", "method": "POST", "URL": "/config/v1/agents", "content_length": 27, "remote_address": "127.0.0.1", "user-agent": "elasticapm-python/5.9.0", "response_code": 401, "error": "unauthorized"}
./logs/apm-logs/apm02.logs:34906:2020-11-27T12:25:11.415Z       <strong>ERROR</strong>   [request]       middleware/log_middleware.go:95unauthorized     {"request_id": "a49d5546-b8d2-4e50-9dd0-6cbf419a365e", "method": "POST", "URL": "/config/v1/agents", "content_length": 27, "remote_address": "127.0.0.1", "user-agent": "elasticapm-python/5.9.0", "response_code": 401, "error": "unauthorized"}
</pre><p>Note that in this case we searched through many files - anything which matches the <code>*.logs</code> wildcard. To help us identify in <em>which</em> file the match was found, we used the <code>-Hn</code> flags. The beginning of the lines now start with the path of the file and the line number, for example:</p><pre><code>./logs/apm-logs/apm02.logs:34906
</code></pre><p>You can take this even further:</p><pre><code>$ grep -R -Hn -i error ./logs
</code></pre><p>Adding the <code>-R</code> or <em>recursive</em> flag tells <code>grep</code> to search recursively in folders if they are included in the search.</p><h1 id=v-for-invert>V for Invert</h1><p>As long as your remember that <code>-i</code> is the flag for <em>case insensitive</em>, it makes it a little easier to remember <em>v for invert</em>. This tells <code>grep</code> to <em>exclude</em> lines which match the pattern. This works kind of like a filter.</p><p>Here's how I could look through my log files, excluding any messages with &lsquo;debug&rsquo; in them:</p><pre><code>$ grep -v debug ./logs/web-server.logs
</code></pre><p>Don't forget, you can always <em>pipe</em> a series of <code>grep</code> commands together. Rather than trying to work out a perfect pattern which searches for exactly what you want, you could just pipe a a set of commands together:</p><pre><code>$ grep -i error -R ./logs | grep -i -v memory | grep -i -v 'not found'
</code></pre><p>This set of small, simple, commands is chained together to make a more sophisticated operation:</p><ul><li>First we recursively search for any <code>error</code> text in the <code>./logs</code> folder</li><li>Then we exclude anything which matches <code>memory</code></li><li>Then we exclude anything which matches <code>not found</code></li></ul><p>This is the essence of the Unix Philosophy - with a small number of simple tools, we can <em>compose</em> a more complex workflow!</p><h1 id=dont-forget-your-pipelines>Don't Forget Your Pipelines!</h1><p>We've introduced a very powerful command in this chapter. For familiar users, <code>grep</code> becomes a <em>verb</em> they use regularly - you <code>grep</code> the output of something, or might be <em>grepping</em> to find something. Remember that <code>grep</code>, just like most of the tools in this section, works on <code>stdin</code> by default. So you can easily <code>grep</code> the output of almost anything!</p><p>Here are a few simple examples just to show you how easy it is to perform more complex tasks with grep.</p><pre><code>ps -a | grep vim
</code></pre><p>Show all processes, then filter the list down to only <code>vim</code> processes.</p><pre><code>grep -Hv -C 3 -R password ./k8s/**/*.yaml | less
</code></pre><p>Search through all of the <code>yaml</code> files in my <code>k8s</code> folder, for the text &lsquo;password&rsquo;, show three lines of context, as well as the file name and number, and put the output in my pager so that it is easy to search through.</p><pre><code>ls -al /usr/bin /bin /usr/local/bin | grep zip
</code></pre><p>Search through all of my installed programs for programs which have <code>zip</code> in the name.</p><pre><code>history | grep grep | tail -n 10
</code></pre><p>Show me the last ten <code>grep</code> commands I typed in my shell!</p><p>We'll see a lot more examples as we go through the book - just remember that <code>grep</code> is alwaays available to search or filter text!</p><h1 id=alternatives-to-grep>Alternatives to Grep</h1><p>Grep is a very commonly used tool and has been around for a long time. It can vary a bit from system to system. Over the years a number of alternatives have been developed. Most of these alternatives are either designed to be <em>faster</em>, so that you can search through files much more quickly, or <em>easier</em> so that you don't have to remember too many flags.</p><p>In general, I would advise <em>against</em> using alternatives - until you genuinely find you are limited by <code>grep</code>. Every alternative is another tool to learn, which might not be present on other systems you use. It is also less likely to be available if you are writing scripts or instructions for others.</p><p>If you find yourself really struggling with performance - perhaps you often search huge folders of text or if you find yourself regularly struggling to find ways to craft your search patterns, then perhaps you can investigate some of the popular alternatives. But I would suggest that you master the core <code>grep</code> functionality first, before installing other tools.</p><p>If you <em>do</em> decide you want to add some more text searching tools to your toolkit, I would suggest <code>ripgrep</code>, <code>ag</code> and <code>ack</code> as three potential options. Each of them offer performance improvements and additional functionality.</p><h1 id=summary>Summary</h1><p>Grep is a simple text-based search tool! If you need to <em>find</em> text, or want to <em>filter</em> text, then <code>grep</code> should be your go-to tool.</p><p>Here's a summary of what we've covered:</p><ul><li><code>grep pattern file</code> searches <code>file</code> for the text <code>pattern</code></li><li>the <code>-E</code> flag lets you use <em>regular expressions</em> for more sophisticated searches</li><li>You can make the search case insensitive with the <code>-i</code> flag</li><li>Remember the <code>ABC</code> flags - <em>after</em>, <em>before</em> and <em>context</em>, which show lines after, before and around the matches</li><li>Include the filename and line number with the <code>-Hn</code> flags</li><li>V for invert! Use the <code>-v</code> flag to invert the search, or filter out matches</li><li><code>grep</code> works great in pipelines! Use it to search or filter when working with <em>other</em> commands</li></ul><hr><p><strong>Footnotes</strong></p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>See the interview at: <a href="https://www.youtube.com/watch?v=NTfOnGZUZDk&feature=emb_title">https://www.youtube.com/watch?v=NTfOnGZUZDk&feature=emb_title</a> <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></article><div class="book-footer justify-between"><div><a class="flex align-center" href=https://github.com/dwmkerr/effective-shell/commit/05042c5b9860b66be4edb7195bf03b4d58c52f1c title="Last modified by Dave Kerr | Jun 5, 2021" target=_blank><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>Jun 5, 2021</span></a></div><div><a class="flex align-center" href=https://github.com/dwmkerr/effective-shell/edit/master/website/content/docs/part-3-manipulating-text/get-to-grips-with-grep/_index.md target=_blank><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"effective-shell"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><p>Copyright &copy; <script>document.write(new Date().getFullYear())</script>, Dave Kerr</p></div><aside class="book-toc levels-3 fixed"><nav id=TableOfContents><ul><li><a href=#chapter-14---get-to-grips-with-grep>Chapter 14 - Get to Grips with Grep</a></li><li><a href=#what-is-grep>What is Grep</a></li><li><a href=#why-grep>Why Grep?</a></li><li><a href=#searching-through-text>Searching Through Text</a></li><li><a href=#using-patterns>Using Patterns</a></li><li><a href=#finding-problems>Finding Problems</a></li><li><a href=#the-abc-of-grep>The ABC of Grep</a></li><li><a href=#working-with-multiple-files>Working with Multiple Files</a></li><li><a href=#v-for-invert>V for Invert</a></li><li><a href=#dont-forget-your-pipelines>Don't Forget Your Pipelines!</a></li><li><a href=#alternatives-to-grep>Alternatives to Grep</a></li><li><a href=#summary>Summary</a></li></ul></nav></aside></main></body></html>