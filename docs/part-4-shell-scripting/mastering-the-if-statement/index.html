<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Mastering the If Statement"><meta property="og:title" content="Mastering the If Statement"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://effective-shell.com/docs/part-4-shell-scripting/mastering-the-if-statement/"><title>Mastering the If Statement | Effective Shell</title><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.f8520695a602b532b093067e25561bfe6fa10ca8c25171b97142acf58fa8f13c.css integrity="sha256-+FIGlaYCtTKwkwZ+JVYb/m+hDKjCUXG5cUKs9Y+o8Tw="><script defer src=/en.search.min.6498fa3f8ac91e2d4dba90f56c9f362bfcc7a95ea821df78046729b32b57a27c.js integrity="sha256-ZJj6P4rJHi1NupD1bJ82K/zHqV6oId94BGcpsytXonw="></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-155335600-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><link rel=alternate type=application/rss+xml href=https://effective-shell.com/docs/part-4-shell-scripting/mastering-the-if-statement/index.xml title="Effective Shell"></head><body><input type=checkbox class=hidden id=menu-control><main class="flex container"><aside class="book-menu fixed"><nav><h2 class=book-brand><a href=https://effective-shell.com/><span>Effective Shell</span></a></h2><h2 class=book-subtitle><span>By Dave Kerr</span></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/docs/introduction/><strong>Introduction</strong></a></li><li><a href=/docs/getting-started/><strong>Getting Started</strong></a></li><li><a href=/docs/part-1-transitioning-to-the-shell/><strong>Part 1 - Transitioning to the Shell</strong></a><ul><li><a href=/docs/part-1-transitioning-to-the-shell/navigating-your-system/>Navigating Your System</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/managing-your-files/>Managing Your Files</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/clipboard-gymnastics/>Clipboard Gymnastics</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/getting-help/>Getting Help</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/the-renaissance-of-the-shell/>The Renaissance of the Shell</a></li></ul></li><li><a href=/docs/part-2-core-skills/><strong>Part 2 - Core Skills</strong></a><ul><li><a href=/docs/part-2-core-skills/thinking-in-pipelines/>Thinking in Pipelines</a></li><li><a href=/docs/part-2-core-skills/fly-on-the-command-line/>Fly on the Command Line</a></li><li><a href=/docs/part-2-core-skills/job-control/>Job Control</a></li><li><a href=/docs/part-2-core-skills/understanding-commands/>Understanding Commands</a></li><li><a href=/docs/part-2-core-skills/finding-files/>Finding Files</a></li><li><a href=/docs/part-2-core-skills/what-is-a-shell/>What is a Shell?</a></li></ul></li><li><a href=/docs/part-3-manipulating-text/><strong>Part 3 - Manipulating Text</strong></a><ul><li><a href=/docs/part-3-manipulating-text/regex-essentials/>Regex Essentials</a></li><li><a href=/docs/part-3-manipulating-text/get-to-grips-with-grep/>Get to Grips with Grep</a></li><li><a href=/docs/part-3-manipulating-text/slice-and-dice-text/>Slice and Dice Text</a></li><li><a href=/docs/part-3-manipulating-text/advanced-text-manipulation/>Advanced Text Manipulation with Sed</a></li><li><a href=/docs/part-3-manipulating-text/build-commands-on-the-fly/>Build Commands on the Fly with Xargs</a></li></ul></li><li><a href=/docs/part-4-shell-scripting/><strong>Part 4 - Shell Scripting</strong></a><ul><li><a href=/docs/part-4-shell-scripting/shell-script-essentials/>Shell Script Essentials</a></li><li><a href=/docs/part-4-shell-scripting/variables-reading-input-and-mathematics/>Variables, Reading Input, and Mathematics</a></li><li><a href=/docs/part-4-shell-scripting/mastering-the-if-statement/ class=active>Mastering the If Statement</a></li><li><a href=/docs/part-4-shell-scripting/loops-and-working-with-files-and-folders/>Loops and working with Files and Folders</a></li><li><a href=/docs/part-4-shell-scripting/functions-parameters-and-error-handling/>Functions, Parameters and Error Handling</a></li></ul></li><li><a href=/docs/work-in-progress/><strong>Work in Progress</strong></a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class="flex align-center justify-between book-header"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Mastering the If Statement</strong></header><article class=markdown><h1 id=chapter-20---mastering-the-if-statement>Chapter 20 - Mastering the If Statement</h1><p>In this chapter we'll introduce the <em>if statement</em> - a crucial feature of the shell that allows us to perform operations only when certain conditions are met. First we'll look at the basics of how the statement is used and then look at some more advanced scenarios.</p><p>Let's get right into it!</p><h1 id=the-if-statement---index--->The If Statement</h1><p>We can use the <em>if statement</em> to perform operations in shell scripts only when certain conditions are met.</p><p>The <em>if statement</em> has the following structure:</p><pre><code>if &lt;test-commands&gt;
then
    &lt;conditional-command 1&gt;
    &lt;conditional-command 2&gt;
    &lt;conditional-command n&gt;
fi
</code></pre><p>The <em>if</em> statement will run the &lsquo;test commands&rsquo;. If the result of the commands are all zero (which means &lsquo;success&rsquo;), then each of the &lsquo;conditional&rsquo; commands will be run. We &lsquo;close&rsquo; the if statement with the <code>fi</code> keyword, which is <code>if</code> written backwards.</p><p>Let's see how the if statement is used with a simple example. We will try and create a folder using <code>mkdir</code>. The <code>mkdir</code> command will return zero if the folder is created successfully:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#66d9ef>if</span> mkdir ~/backups
<span style=color:#66d9ef>then</span>
    echo <span style=color:#e6db74>&#34;Successfully created the &#39;backups&#39; folder&#34;</span>
<span style=color:#66d9ef>fi</span>
</code></pre></div><p>If you don't have a folder called <em>backups</em> in your home directory then the command will run successfully. The <code>mkdir</code> command will return zero and the conditional statements will be run and you will see the output below:</p><pre><code>Successfully created the 'backups' folder
</code></pre><p>If you then run the script again, the <code>mkdir</code> command will fail. In this case it does <em>not</em> return zero and the conditional commands are not executed. We will see an error message from the <code>mkdir</code> command:</p><pre><code>mkdir: /home/dwmkerr/backups: File exists
</code></pre><p>This is the basics of how the if statement works. We provide test commands, if the test commands succeed, a set of conditional commands are then executed.</p><p>You might be surprised to hear that the result of the test commands has to be zero for the conditional commands to run. This is the opposite of how most programming languages work - normally zero would be considered &lsquo;false&rsquo;.</p><p>The reason for this - is that for computer programs that run, &lsquo;zero&rsquo; generally means success. Any non-zero value is typically used to indicate an error code. So whilst inside a programming language, an if statement will check for a value to be &lsquo;true&rsquo;, just remember that in the shell an if statement will check for a <em>command to be successful</em>.</p><h1 id=the-test-command>The Test Command</h1><p>The <code>test</code> (<em>evaluate expression</em>) command is used to check whether a certain condition is true or not. If the condition is true then the test command returns zero to indicate success.</p><p>We could improve our earlier if statement example by only creating the &lsquo;backups&rsquo; folder if it doesn't already exist, using the test command:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#66d9ef>if</span> ! test -d ~/backups
<span style=color:#66d9ef>then</span>
    echo <span style=color:#e6db74>&#34;Creating backups folder&#34;</span>
    mkdir ~/backups
<span style=color:#66d9ef>fi</span>
</code></pre></div><p>The <code>test</code> command evaluates an expression. In this case the expression is:</p><pre><code>-d ~/backups
</code></pre><p>This expression uses the <code>-d</code> (<em>file exists and is a directory</em>) operator to check to see if the provided path is a directory. We to want to create the directory only if it <em>doesn't</em> exist, so we use the &lsquo;not&rsquo; operator to &lsquo;invert&rsquo; the result of <code>test</code>. The &lsquo;not&rsquo; operator is written with the <code>!</code> exclamation point symbol.</p><p>You can surround an expression with square bracket and the shell will evaluate the expression with the <code>test</code> command. This can make your scripts far more compact:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#66d9ef>if</span> ! <span style=color:#f92672>[</span> -d ~/backups<span style=color:#f92672>]</span>
<span style=color:#66d9ef>then</span>
    echo <span style=color:#e6db74>&#34;Creating backups folder&#34;</span>
    mkdir ~/backups
<span style=color:#66d9ef>fi</span>
</code></pre></div><p>This square bracket syntax is very commonly used - but just remember it is shorthand for the <code>test</code> command.</p><p>One of the most useful manual pages is the page for the <code>test</code> command as it shows all of the available operators. Open the page with <code>man test</code>.</p><h1 id=using-multiple-statements-in-a-single-line>Using Multiple Statements in a Single Line</h1><p>You will often see &lsquo;if&rsquo; and &lsquo;then&rsquo; statements on the same line as below:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#66d9ef>if</span> ! <span style=color:#f92672>[</span> -d ~/backups <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
    mkdir ~/backups
<span style=color:#66d9ef>fi</span>
</code></pre></div><p>The shell assumes that each individual line is a single statement. If you want to put more than one statement on a line then you need to let the shell know when one statement ends and another starts. We can use a semi-colon for this. The shell uses the semi-colon as a &lsquo;command separator&rsquo; symbol.</p><p>If you don't include a semi-colon at the end of a command then the shell assumes that the entire line is a single statement. If you try and run the script without the semi-colon you will get an error:</p><pre><code>bash: syntax error near unexpected token `fi'
</code></pre><p>I would suggest you start by writing your if statements with the if and the then on separate lines. Once you are more familiar with the syntax, you can start to combine the lines if you prefer.</p><p>You can put as many statements on a single line as you like - you could even write the script like so:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#66d9ef>if</span> ! test -d ~/backups; <span style=color:#66d9ef>then</span> mkdir ~/backups; <span style=color:#66d9ef>fi</span>
</code></pre></div><p>The <code>then</code> doesn't require a semi-colon as it is a <em>keyword</em> rather than a command. I think that in general keeping things on separate lines will be a bit more readable for other users, but sometimes you may prefer a more compact form.</p><h1 id=the-else-statement---index--->The Else Statement</h1><p>You can use the <em>else statement</em> to define a series of statements that should be executed if the condition in the <em>if</em> statement is <em>not</em> true.</p><p>Here's how we can write a script that informs the user of whether they have installed the &lsquo;common&rsquo; command or not:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -e /usr/local/bin/common <span style=color:#f92672>]</span>
<span style=color:#66d9ef>then</span>
    echo <span style=color:#e6db74>&#34;The &#39;common&#39; command has been installed in the local bin folder.&#34;</span>
<span style=color:#66d9ef>else</span>
    echo <span style=color:#e6db74>&#34;The &#39;common&#39; command has not been installed in the local bin folder.&#34;</span>
<span style=color:#66d9ef>fi</span>
</code></pre></div><p>In this case we used the <code>-e</code> (<em>file or folder exists</em>) operator to check whether a file or folder exists in the location <em>/usr/local/bin/common</em>. The &lsquo;common&rsquo; command is the command we created in <a href=/docs/part-4-shell-scripting/shell-script-essentials/>Chapter 18 - Shell Script Essentials</a>.</p><p>Now if you run the script and you don't have the &lsquo;common&rsquo; command installed you will see the following output:</p><pre><code>The 'common' command has not been installed in the local bin folder.
</code></pre><p>Note that we still need to use the &lsquo;fi&rsquo; keyword to close the &lsquo;if&rsquo; statement.</p><h1 id=the-elif-statement---index--->The Elif Statement</h1><p>The <em>elif statement</em> (which is short for &lsquo;else if&rsquo;) can be used to create additional checks and define statements that should run if <em>other</em> conditions are true.</p><p>Let's see this in action by updating our script to check to see whether the &lsquo;common&rsquo; command is executable, using the <code>-x</code> (<em>is executable</em>) operator:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -x /usr/local/bin/common <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
    echo <span style=color:#e6db74>&#34;The &#39;common&#39; command has been installed and is executable.&#34;</span>
<span style=color:#66d9ef>elif</span> <span style=color:#f92672>[</span> -e /usr/local/bin/common <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
    echo <span style=color:#e6db74>&#34;The &#39;common&#39; command has been installed and is not executable.&#34;</span>
<span style=color:#66d9ef>else</span>
    echo <span style=color:#e6db74>&#34;The &#39;common&#39; command has not been installed.&#34;</span>
<span style=color:#66d9ef>fi</span>
</code></pre></div><p>The message you see will depend on whether you have installed the &lsquo;common&rsquo; command in your local binaries folder and whether the script is executable. If you want to see each of the different messages, you might find the following snippets useful to add or remove the command or change its executable permissions:</p><ul><li><code>ln -s $HOME/effective-shell/scripts/common.v1.sh /usr/local/bin/common</code> - Create a link to the &lsquo;common&rsquo; command in the local binaries folder</li><li><code>chmod -x $HOME/effective-shell/scripts/common.v1.sh</code> remove the &lsquo;executable&rsquo; flag from the &lsquo;common&rsquo; command, making it not executable</li><li><code>chmod +x $HOME/effective-shell/scripts/common.v1.sh</code> add the &lsquo;executable&rsquo; flag from the &lsquo;common&rsquo; command, making it executable</li><li><code>rm /usr/local/bin/common</code> remove the link to the &lsquo;common&rsquo; command from the local binaries folder</li></ul><p>The <em>elif</em> statement looks very similar to the <em>if</em> statement. The statement takes a set of commands. These commands could be normal shell commands, <code>test</code> commands, or <code>test</code> commands written with the square brackets short-hand notation.</p><p>It is very important to think about the order in which the <em>if</em> and <em>elif</em> statement are executed. If we had written the script like this, it would not work:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -e /usr/local/bin/common <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
    echo <span style=color:#e6db74>&#34;The &#39;common&#39; command has been installed and is executable.&#34;</span>
<span style=color:#66d9ef>elif</span> <span style=color:#f92672>[</span> -x /usr/local/bin/common <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
    echo <span style=color:#e6db74>&#34;The &#39;common&#39; command has been installed and is not executable.&#34;</span>
<span style=color:#66d9ef>else</span>
    echo <span style=color:#e6db74>&#34;The &#39;common&#39; command has not been installed.&#34;</span>
<span style=color:#66d9ef>fi</span>
</code></pre></div><p>In this script we check to see if the file exists first. If the file exists then the condition <code>-e</code> operator will return true, and we will <em>not</em> run the check in the <em>elif</em> statement. This means we'll <em>never</em> successfully evaluate the statements in the <em>elif</em> block (because for the file to be executable it must exist, so the first condition in the <em>if</em> statement will always take precedence. So it is important to think about the order of the statements!</p><h1 id=common-test-operators>Common Test Operators</h1><p>There are many operators that can be used in a <code>test</code> expression. You can find the full list by running <code>man test</code>.</p><p>Here are the most common operators you should know about!</p><table><thead><tr><th>Operator</th><th>Usage</th></tr></thead><tbody><tr><td><code>-n</code></td><td>True if the length of a string is non-zero.</td></tr><tr><td><code>-z</code></td><td>True if the length of a string is zero.</td></tr><tr><td><code>var</code></td><td>True if the variable <code>var</code> is set and is not empty.</td></tr><tr><td><code>s1 = s2</code></td><td>True if the strings <code>s1</code> and <code>s2</code> are identical.</td></tr><tr><td><code>s1 != s2</code></td><td>True if the strings <code>s1</code> and <code>s2</code> are not identical.</td></tr><tr><td><code>n1 -eq n2</code></td><td>True if the numbers <code>n1</code> and <code>n2</code> are equal.</td></tr><tr><td><code>n1 -ne n2</code></td><td>True if the numbers <code>n1</code> and <code>n2</code> are not equal.</td></tr><tr><td><code>n1 -lt n2</code></td><td>True if the number <code>n1</code> is less than <code>n2</code>.</td></tr><tr><td><code>n1 -le n2</code></td><td>True if the number <code>n1</code> is less than or equal to <code>n2</code>.</td></tr><tr><td><code>n1 -gt n2</code></td><td>True if the number <code>n1</code> is greater than <code>n2</code>.</td></tr><tr><td><code>n1 -ge n2</code></td><td>True if the number <code>n1</code> is greater than or equal to <code>n2</code>.</td></tr></tbody></table><h1 id=common-test-operators-for-files>Common Test Operators for Files</h1><p>One of the great things about the <code>test</code> command is the presence of a number of operators that are specifically used to work with the filesystem. These operators are very handy when you are building shell scripts!</p><p>Here are some of the most useful ones:</p><table><thead><tr><th>Operator</th><th>Usage</th></tr></thead><tbody><tr><td><code>-d</code></td><td>True if the file exists and is a folder.</td></tr><tr><td><code>-e</code></td><td>True if the file exists, regardless of the file type.</td></tr><tr><td><code>-f</code></td><td>True if the file exists and is a regular file.</td></tr><tr><td><code>-L</code></td><td>True if the file exists and is a symbolic link.</td></tr><tr><td><code>-r</code></td><td>True if the file exists and is readable.</td></tr><tr><td><code>-s</code></td><td>True if the file exists and has a size greater than zero.</td></tr><tr><td><code>-w</code></td><td>True if the file exists is writable.</td></tr><tr><td><code>-x</code></td><td>True if the file exists and is executable - if it is a directory this checks if it can be searched.</td></tr><tr><td><code>file1 -nt file2</code></td><td>True if file1 is exists and is newer than file2.</td></tr><tr><td><code>file1 -ot file2</code></td><td>True if file1 is exists and is older than file2.</td></tr><tr><td><code>file1 -ef file2</code></td><td>True if file1 and file2 exist and are the same file.</td></tr></tbody></table><p>There are plenty of other operators that you can use when working with files, you can see them all by running <code>man test</code>.</p><h1 id=combining-tests>Combining Tests</h1><p>Often you will want to check multiple conditions. You can use the <code>&&</code> &lsquo;and&rsquo; operator and the <code>||</code> &lsquo;or&rsquo; operator to check for multiple conditions:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> $year -ge <span style=color:#ae81ff>1980</span> <span style=color:#f92672>]</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>[</span> $year -lt <span style=color:#ae81ff>1990</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
    echo <span style=color:#e6db74>&#34;</span>$year<span style=color:#e6db74> is in the 1980s</span><span style=color:#e6db74>&#34;</span>
<span style=color:#66d9ef>fi</span>
</code></pre></div><p>This script checks to see whether the variable &lsquo;year&rsquo; is greater than or equal to 1980 and less than 1990.</p><p>You can use &lsquo;and&rsquo; or &lsquo;or&rsquo; in a single test statement by using the special <code>-a</code> (and) and <code>-o</code> (or) operators. This is how the script would look using the <code>-a</code> operator:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> $year -ge <span style=color:#ae81ff>1980</span> -a $year -lt <span style=color:#ae81ff>1990</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
    echo <span style=color:#e6db74>&#34;</span>$year<span style=color:#e6db74> is in the 1980s</span><span style=color:#e6db74>&#34;</span>
<span style=color:#66d9ef>fi</span>
</code></pre></div><p>These operators can lead to some subtle problems so I would not recommend that you use them. A better option is &lsquo;Conditional Expressions&rsquo; which are described in the next section. However, it is important to be able to recognise these operators so that they don't surprise you if you see them in someone else's script.</p><h1 id=conditional-expressions>Conditional Expressions</h1><p>&lsquo;Conditional Expressions&rsquo; are a feature of Bash, and bash-like shells, that offer a more sophisticated option to perform conditional checks. Conditional expressions use two square brackets rather than one:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span><span style=color:#f92672>[</span> $year -ge <span style=color:#ae81ff>1980</span> <span style=color:#f92672>&amp;&amp;</span> $year -lt <span style=color:#ae81ff>1990</span> <span style=color:#f92672>]</span><span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
    echo <span style=color:#e6db74>&#34;</span>$year<span style=color:#e6db74> is in the 1980s</span><span style=color:#e6db74>&#34;</span>
<span style=color:#66d9ef>fi</span>
</code></pre></div><p>Conditional expressions have a number of benefits over plain <code>test</code> commands. Some of the most important ones are:</p><ul><li>You can use the <code>&&</code> and <code>||</code> operators directly in the expression</li><li>If you use an <code>||</code> expression and the left hand side of the expression is true, the right hand side will not be evaluated - this is <em>not</em> always the case with older versions of Bash when using the <code>-o</code> operator (this is a subtle difference but can help avoid potentially incorrect behaviour)</li><li>Numbers are correctly compared even if they are in different formats (for example, you can compare hexadecimal and octal numbers, this does not work in the standard <code>test</code> expression)</li><li>You can use the incredibly useful <code>=~</code> operator to use a regular expression in your condition (we'll look at this next)</li></ul><p>You can find more details on conditional expressions by using <code>man bash</code> and searching for <code>\[\[</code> (this is the double square brackets with each one escaped with a backslash).</p><p>Some people prefer to use single brackets so that their script is more portable, as the double brackets are specific to Bash and Bash-like shells. Others prefer to use the double brackets so that they can use the additional featured offered.</p><p>Whether you use single or double brackets will partly be down to preference and whether it is more important in your use case to have portability or whether it is more important to have the more &lsquo;correct&rsquo; behaviour.</p><h1 id=using-regexes-in-a-conditional-expression>Using Regexes in a Conditional Expression</h1><p>When you use the double square brackets conditional expression syntax you can use the <code>=~</code> operator to test for a regular expression. This can be extremely useful. If you need a reminder on how regular expressions work check <a href=/docs/part-3-manipulating-text/regex-essentials/>Chapter 13 - Regex Essentials</a>.</p><p>In the example below we check to see if the user's shell is &lsquo;zsh&rsquo; by seeing whether the path of the shell ends with the text <code>zsh</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>zsh_regex<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>zsh</span>$<span style=color:#e6db74>&#34;</span>
<span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span><span style=color:#f92672>[</span> $SHELL <span style=color:#f92672>=</span>~ $zsh_regex <span style=color:#f92672>]</span><span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
    echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>It looks like your shell &#39;</span>$SHELL<span style=color:#e6db74>&#39; is Z-Shell</span><span style=color:#e6db74>&#34;</span>
<span style=color:#66d9ef>fi</span>
</code></pre></div><p>If you are running Z-Shell you will see the output below:</p><pre><code>It looks like your shell '/bin/zsh' is Z-Shell
</code></pre><p>It is best to declare the regular expression in a variable rather than including it directly in the expression, this makes it easier to handle special characters such as the dollar symbol.</p><p>You can use capture groups in your regular expression to help you extract text. For example, we could get the name of the current shell binary with the code below:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>shell_regex<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>([^/]+)</span>$<span style=color:#e6db74>&#34;</span>
<span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span><span style=color:#f92672>[</span> $SHELL <span style=color:#f92672>=</span>~ $shell_regex <span style=color:#f92672>]</span><span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
    echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Your shell binary is: </span><span style=color:#e6db74>${</span>BASH_REMATCH[1]<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
<span style=color:#66d9ef>else</span>
    echo <span style=color:#e6db74>&#34;Unable to extract your shell binary&#34;</span>
<span style=color:#66d9ef>fi</span>
</code></pre></div><p>On my machine this script shows the following output:</p><pre><code>Your shell binary is: bash
</code></pre><p>The <code>$BASH_REMATCH</code> variable is an array - the first result value in the array is the entire match, each subsequent value in the array is the result of each capture group in the expression. Double check <a href=/docs/part-4-shell-scripting/variables-reading-input-and-mathematics/>Chapter 19 - Variables, Reading Input, and Mathematics</a> if you need a reminder on how arrays work in Bash.</p><h1 id=updating-the-common-command>Updating the &lsquo;Common&rsquo; Command</h1><p>Now that we know how to use if statements, we can update the &lsquo;common&rsquo; command that we have been improving as part of each chapter.</p><p>We will update it to check to see whether the user is using Bash or Z-Shell and search through the history for for common commands appropriately.</p><p>As a reference, let's look at the <code>common.v2.sh</code> command we created in the previous chapter:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Write the title of our command.</span>
echo <span style=color:#e6db74>&#34;common commands:&#34;</span>

<span style=color:#75715e># The following variables control how the command runs.</span>
history_lines<span style=color:#f92672>=</span><span style=color:#ae81ff>1000</span> <span style=color:#75715e># The number of lines of history to search through</span>
command_count<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span>   <span style=color:#75715e># The number of common commands to show</span>

<span style=color:#75715e># Show the most commonly used commands.</span>
tail ~/.bash_history -n <span style=color:#e6db74>${</span>history_lines<span style=color:#e6db74>}</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    | sort <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    | uniq -c <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    | sed <span style=color:#e6db74>&#39;s/^ *//&#39;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    | sort -n <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    | tail -n <span style=color:#e6db74>${</span>command_count<span style=color:#e6db74>}</span>
</code></pre></div><p>We'll create a new version of this script called <code>common.v3.sh</code> that checks the user's shell to work out what file to use to find the history of commands:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># The following variables control how the command runs.</span>
shell_binary<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span>    <span style=color:#75715e># We will work out what shell we are in later.</span>
history_file<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span>    <span style=color:#75715e># We will work out the history file later.</span>
history_lines<span style=color:#f92672>=</span><span style=color:#ae81ff>1000</span> <span style=color:#75715e># The number of lines of history to search through</span>
command_count<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span>   <span style=color:#75715e># The number of common commands to show</span>

<span style=color:#75715e># Check to see if we can work out the name of the shell binary.</span>
shell_regex<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>([^/]+</span>$<span style=color:#e6db74>)</span><span style=color:#e6db74>&#34;</span>
<span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span><span style=color:#f92672>[</span> $SHELL <span style=color:#f92672>=</span>~ $shell_regex <span style=color:#f92672>]</span><span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
    <span style=color:#75715e># Depending on the name of the shell binary, set the history file path.</span>
    shell_binary<span style=color:#f92672>=</span><span style=color:#e6db74>${</span>BASH_REMATCH[1]<span style=color:#e6db74>}</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span><span style=color:#f92672>[</span> $shell_binary <span style=color:#f92672>=</span><span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;bash&#34;</span> <span style=color:#f92672>]</span><span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
        history_file<span style=color:#f92672>=</span>~/.bash_history
    <span style=color:#66d9ef>elif</span> <span style=color:#f92672>[</span><span style=color:#f92672>[</span> $shell_binary <span style=color:#f92672>=</span><span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;zsh&#34;</span> <span style=color:#f92672>]</span><span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
        history_file<span style=color:#f92672>=</span>~/.bash_history
    <span style=color:#66d9ef>fi</span>
<span style=color:#66d9ef>fi</span>

<span style=color:#75715e># If we are searching through the bash history, we can look at the history file</span>
<span style=color:#75715e># to get the most common commands.</span>
<span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span><span style=color:#f92672>[</span> $shell_binary <span style=color:#f92672>=</span><span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;bash&#34;</span> <span style=color:#f92672>]</span><span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
    <span style=color:#75715e># Show the most commonly used commands.</span>
    tail <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>history_file<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> -n <span style=color:#e6db74>${</span>history_lines<span style=color:#e6db74>}</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>        | sort <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>        | uniq -c <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>        | sed <span style=color:#e6db74>&#39;s/^ *//&#39;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>        | sort -n -r <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>        | head -n <span style=color:#e6db74>${</span>command_count<span style=color:#e6db74>}</span>
<span style=color:#66d9ef>elif</span> <span style=color:#f92672>[</span><span style=color:#f92672>[</span> $shell_binary <span style=color:#f92672>=</span><span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;zsh&#34;</span> <span style=color:#f92672>]</span><span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
    <span style=color:#75715e># Z-Shell history lines look like this:</span>
    <span style=color:#75715e># : 1621135004:0;uname -a</span>
    <span style=color:#75715e># So we run the same command as above, but use the &#39;rev | cut | rev&#39; trick</span>
    <span style=color:#75715e># to extract everything _after_ the semi-colon, which is the command text.</span>
    tail <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>history_file<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> -n <span style=color:#e6db74>${</span>history_lines<span style=color:#e6db74>}</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>        | rev <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>        | cut -d<span style=color:#e6db74>&#39;;&#39;</span> -f1 <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>        | rev <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>        | sort <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>        | uniq -c <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>        | sed <span style=color:#e6db74>&#39;s/^ *//&#39;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>        | sort -n -r <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>        | head -n <span style=color:#e6db74>${</span>command_count<span style=color:#e6db74>}</span>
<span style=color:#66d9ef>else</span>
    <span style=color:#75715e># Show a warning to the user that we don&#39;t know where the history file is</span>
    <span style=color:#75715e># for their shell.</span>
    echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Sorry, I don&#39;t know where to find the history for &#39;</span><span style=color:#e6db74>${</span>SHELL<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>&#34;</span>
<span style=color:#66d9ef>fi</span>
</code></pre></div><p>In this script we now first check to see if we can extract the name of the shell binary from the shell path. If we can, we store the name of the shell binary and its associated history in a pair of variables.</p><p>Then when we come to actually search through the history, we check the shell binary. If it is <code>bash</code>, we run the same command as before. If it is <code>zsh</code> we run a similar command, but account for the fact that the Z-Shell history file has some extra content which needs to be removed.</p><p>Note that as well as showing how to use more variables and if statements, as well as <em>nested</em> if statements (when one if statement is inside another) we can also see that we have very descriptive comments. Each comment is giving clear information on what we are trying to accomplish, which should make the script easier to maintain.</p><p>If you want to replace the installed <code>common</code> command with this new one, update the symlink in your <em>/usr/local/bin</em> folder:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>ln -sf $HOME/effective-shell/scripts/common.v3.sh /usr/local/bin/common
</code></pre></div><p>Note that in this command we use the <code>-f</code> flag to force the creation of the symlink even if one already exists in the given location.</p><h1 id=summary>Summary</h1><p>In this chapter we looked at the If statement - an extremely important statement that allows us to perform conditional logic. In the next chapter we will look at another crucial logical feature of the shell - loops.</p></article><div class="book-footer justify-between"><div><a class="flex align-center" href=https://github.com/dwmkerr/effective-shell/commit/fb95e4a93fd073f4b74175e84d624ae0d4c79d42 title="Last modified by Dave Kerr | May 29, 2021" target=_blank><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>May 29, 2021</span></a></div><div><a class="flex align-center" href=https://github.com/dwmkerr/effective-shell/edit/master/website/content/docs/part-4-shell-scripting/mastering-the-if-statement/_index.md target=_blank><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"effective-shell"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><p>Copyright &copy; <script>document.write(new Date().getFullYear())</script>, Dave Kerr</p></div><aside class="book-toc levels-3 fixed"><nav id=TableOfContents><ul><li><a href=#chapter-20---mastering-the-if-statement>Chapter 20 - Mastering the If Statement</a></li><li><a href=#the-if-statement---index--->The If Statement</a></li><li><a href=#the-test-command>The Test Command</a></li><li><a href=#using-multiple-statements-in-a-single-line>Using Multiple Statements in a Single Line</a></li><li><a href=#the-else-statement---index--->The Else Statement</a></li><li><a href=#the-elif-statement---index--->The Elif Statement</a></li><li><a href=#common-test-operators>Common Test Operators</a></li><li><a href=#common-test-operators-for-files>Common Test Operators for Files</a></li><li><a href=#combining-tests>Combining Tests</a></li><li><a href=#conditional-expressions>Conditional Expressions</a></li><li><a href=#using-regexes-in-a-conditional-expression>Using Regexes in a Conditional Expression</a></li><li><a href=#updating-the-common-command>Updating the &lsquo;Common&rsquo; Command</a></li><li><a href=#summary>Summary</a></li></ul></nav></aside></main></body></html>