<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Variables, Reading Input, and Mathematics"><meta property="og:title" content="Variables, Reading Input, and Mathematics"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://effective-shell.com/docs/part-4-shell-scripting/variables-reading-input-and-mathematics/"><title>Variables, Reading Input, and Mathematics | Effective Shell</title><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.f8520695a602b532b093067e25561bfe6fa10ca8c25171b97142acf58fa8f13c.css integrity="sha256-+FIGlaYCtTKwkwZ+JVYb/m+hDKjCUXG5cUKs9Y+o8Tw="><script defer src=/en.search.min.fc205ecc7cbf97e98d147373b77353d24cc90bab8e846c7be3f535114b9422aa.js integrity="sha256-/CBezHy/l+mNFHNzt3NT0kzJC6uOhGx74/U1EUuUIqo="></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-155335600-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><link rel=alternate type=application/rss+xml href=https://effective-shell.com/docs/part-4-shell-scripting/variables-reading-input-and-mathematics/index.xml title="Effective Shell"></head><body><input type=checkbox class=hidden id=menu-control><main class="flex container"><aside class="book-menu fixed"><nav><h2 class=book-brand><a href=https://effective-shell.com/><span>Effective Shell</span></a></h2><h2 class=book-subtitle><span>By Dave Kerr</span></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/docs/introduction/><strong>Introduction</strong></a></li><li><a href=/docs/getting-started/><strong>Getting Started</strong></a></li><li><a href=/docs/part-1-transitioning-to-the-shell/><strong>Part 1 - Transitioning to the Shell</strong></a><ul><li><a href=/docs/part-1-transitioning-to-the-shell/navigating-your-system/>Navigating Your System</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/managing-your-files/>Managing Your Files</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/clipboard-gymnastics/>Clipboard Gymnastics</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/getting-help/>Getting Help</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/the-renaissance-of-the-shell/>The Renaissance of the Shell</a></li></ul></li><li><a href=/docs/part-2-core-skills/><strong>Part 2 - Core Skills</strong></a><ul><li><a href=/docs/part-2-core-skills/thinking-in-pipelines/>Thinking in Pipelines</a></li><li><a href=/docs/part-2-core-skills/fly-on-the-command-line/>Fly on the Command Line</a></li><li><a href=/docs/part-2-core-skills/job-control/>Job Control</a></li><li><a href=/docs/part-2-core-skills/understanding-commands/>Understanding Commands</a></li><li><a href=/docs/part-2-core-skills/finding-files/>Finding Files</a></li><li><a href=/docs/part-2-core-skills/what-is-a-shell/>What is a Shell?</a></li></ul></li><li><a href=/docs/part-3-manipulating-text/><strong>Part 3 - Manipulating Text</strong></a><ul><li><a href=/docs/part-3-manipulating-text/regex-essentials/>Regex Essentials</a></li><li><a href=/docs/part-3-manipulating-text/get-to-grips-with-grep/>Get to Grips with Grep</a></li><li><a href=/docs/part-3-manipulating-text/slice-and-dice-text/>Slice and Dice Text</a></li><li><a href=/docs/part-3-manipulating-text/advanced-text-manipulation/>Advanced Text Manipulation with Sed</a></li><li><a href=/docs/part-3-manipulating-text/build-commands-on-the-fly/>Build Commands on the Fly with Xargs</a></li></ul></li><li><a href=/docs/part-4-shell-scripting/><strong>Part 4 - Shell Scripting</strong></a><ul><li><a href=/docs/part-4-shell-scripting/shell-script-essentials/>Shell Script Essentials</a></li><li><a href=/docs/part-4-shell-scripting/variables-reading-input-and-mathematics/ class=active>Variables, Reading Input, and Mathematics</a></li><li><a href=/docs/part-4-shell-scripting/mastering-the-if-statement/>Mastering the If Statement</a></li></ul></li><li><a href=/docs/work-in-progress/><strong>Work in Progress</strong></a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class="flex align-center justify-between book-header"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Variables, Reading Input, and Mathematics</strong></header><article class=markdown><h1 id=chapter-19---variables-reading-input-and-mathematics>Chapter 19 - Variables, Reading Input, and Mathematics</h1><p>We've seen variables a few times in our journey so far. In this chapter we'll look at variables in a bit more detail. We'll then see how to read input from the user and also look at how to perform basic mathematical operations in the shell.</p><h1 id=variables>Variables</h1><p><em>Variables</em> are places where the system, the shell, or shell users like ourselves can store data.</p><p>We've already seen variables a few times in this book. For example in <a href=/docs/part-1-transitioning-to-the-shell/getting-help/>Chapter 5 - Getting Help</a> we saw the <code>$PAGER</code> variable that is used to specify what pager program should be used in the shell.</p><p>When we want to use a variable in the shell, we use the <code>$</code> dollar symbol to specify the variable name:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Your pager is: </span>$PAGER<span style=color:#e6db74>&#34;</span>
</code></pre></div><p>If you run this command you will see something like this:</p><pre><code>Your pager is: less
</code></pre><p>By convention, if a variable is in uppercase then it is an _environment variable_ or a built in variable that comes from the shell. An environment variable is a variable that is set by the system. They often contain useful values and are used to help configure your system.</p><p>Here's a few common environment variables we might use:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Your shell is: </span>$SHELL<span style=color:#e6db74>&#34;</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Your user is: </span>$USER<span style=color:#e6db74>&#34;</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Your user&#39;s home directory is: </span>$HOME<span style=color:#e6db74>&#34;</span>
</code></pre></div><p>Your output will look similar to the below:</p><pre><code>Your shell is: /bin/bash
Your user is: dwmkerr
Your user's home directory is: /home/dwmkerr
</code></pre><h2 id=setting-variables>Setting Variables</h2><p>You can create or set your own variables by simply entering the name you would like to use and putting an <code>=</code> equals symbol after the variable, followed by the value you would like to use.</p><p>This is the one of the few times that you will use a variable name without putting a dollar symbol before it!</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Dave&#34;</span>
location<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Singapore&#34;</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Hello </span>$name<span style=color:#e6db74> in </span>$location<span style=color:#e6db74>&#34;</span>
</code></pre></div><p>This will produce the output:</p><pre><code>Hello Dave in Singapore
</code></pre><p>By convention, variables that you define yourself should be lowercase. This helps to distinguish between environment variables and your own variables.</p><p>It is a good habit to use lowercase for variable names. Using uppercase will work, but when you use uppercase you run the risk of &lsquo;overwriting&rsquo; the value of an environment variable and causing unexpected results later.</p><p>For example, in this snippet I accidentally overwrite the <code>USER</code> variable. If a later part of the script expects the <code>USER</code> variable to contain the Linux username of the user then there will likely be an error because I have set it to something else!</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Don&#39;t do this!</span>
USER<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Dave Kerr&#34;</span>

<span style=color:#75715e># If I wanted to go to my home directory, this command would fail. That&#39;s</span>
<span style=color:#75715e># because USER should be &#39;dwmkerr&#39; but I&#39;ve set it to something else!</span>
cd <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>/home/</span>$USER<span style=color:#e6db74>&#34;</span>
</code></pre></div><p>If you set a system variable to something incorrect, the impact will be limited to only the script you are running or the shell session you are in, or any commands you run from the script or session - other running programs will <em>not</em> have their copy of the variable changed. You can read more about this in the <a href=/docs/work-in-progress/>Processes</a> chapter of the <a href=/docs/work-in-progress/>Linux Fundamentals</a> section.</p><h2 id=storing-the-output-of-a-command-into-a-variable>Storing the Output of a Command into a Variable</h2><p>We can use a _subshell_ to run a command and store the result in a variable.</p><p>For example, if we had a variable which held a user's password and wanted to show it on the screen in a &lsquo;masked&rsquo; form, where all of the characters are replaced with an asterisks symbol, we could write the password variable into the <code>sed</code> command and replace every character with an asterisks symbol like so:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>password<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;somethingsecret&#34;</span>
masked_password<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>echo <span style=color:#e6db74>&#34;</span>$password<span style=color:#e6db74>&#34;</span> | sed <span style=color:#e6db74>&#39;s/./*/g&#39;</span><span style=color:#66d9ef>)</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Setting password &#39;</span><span style=color:#e6db74>${</span>masked_password<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;...</span><span style=color:#e6db74>&#34;</span>
</code></pre></div><p>The output of this script will look like this:</p><pre><code>Setting password '***************'...
</code></pre><p>To execute a set of commands in a &lsquo;sub shell&rsquo;, we can use the <code>$()</code> sequence. Everything inside the brackets will be executed in a new shell. We can then store the output of the commands in a variable by using the <code>=</code> equals symbol.</p><h2 id=being-explicit-with-variable-names>Being Explicit with Variable Names</h2><p>You can use curly braces around the name of a variable to be more explicit about what the variable name is. Let's take a look at why you might need to do this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Creating backup folder at: &#39;</span>$USERbackup<span style=color:#e6db74>&#39;</span><span style=color:#e6db74>&#34;</span>
mkdir $USERbackup
</code></pre></div><p>This script shows the output:</p><pre><code>Creating backup folder at: ''
usage: mkdir [-pv] [-m mode] directory ...
</code></pre><p>Rather than creating a folder called <code>dwmkerrbackup</code> (which is my <code>$USER</code> variable followed by the text <code>backup</code>), the script has actually failed. That is because it is looking for a variable called <code>USERbackup</code> - which has does not exist!</p><p>To get around this we would surround the variable name with curly braces like so:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Creating backup folder at: &#39;</span><span style=color:#e6db74>${</span>USER<span style=color:#e6db74>}</span><span style=color:#e6db74>backup&#39;</span><span style=color:#e6db74>&#34;</span>
mkdir <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>USER<span style=color:#e6db74>}</span><span style=color:#e6db74>backup</span><span style=color:#e6db74>&#34;</span>
</code></pre></div><p>This script will show the correct output:</p><pre><code>Creating backup folder at: 'dwmkerrbackup'
</code></pre><p>If there is ever any potential ambiguity with a variable name you should enclose it with curly braces to be on the safe side. Some people will use curly braces in all circumstances to be as explicit as possible about what the variable name is and reduce the risk of mistakes if someone later comes along to edit or change the code.</p><p>This script would be improved with the use of a variable of our own to avoid us having to repeat the <code>${USER}backup</code> text:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>backupdir<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>USER<span style=color:#e6db74>}</span><span style=color:#e6db74>backup</span><span style=color:#e6db74>&#34;</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Creating backup folder at: &#39;</span><span style=color:#e6db74>${</span>backupdir<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>&#34;</span>
mkdir <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>backupdir<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</code></pre></div><p>In this case creating a variable to save us from creating the backup directory folder name each time we want to use it.</p><p>We've looked at environment variables and our own <em>local</em> variables. Now let's look at how we can read input from the user and store it in a variable for later usage.</p><h1 id=the-read-command>The Read Command</h1><p>The <code>read</code> (<em>read from standard input</em>) command can be used to read a line of text from standard input. When the text is read it is put into a variable, allowing it to be used in our scripts.</p><p>Let's see how this look in action!</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>echo <span style=color:#e6db74>&#34;What is your name?&#34;</span>
read
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Hello, </span>$REPLY<span style=color:#e6db74>&#34;</span>
</code></pre></div><p>Run the script - when you have finished writing your name, press &lsquo;enter&rsquo;. This is needed because <code>read</code> will keep on reading until it reaches the end of a line, so we need to press &lsquo;enter&rsquo; to complete the input.</p><pre><code>What is your name?
Dave
Hello, Dave
</code></pre><p>The <code>read</code> command reads a line of text from standard input and stores the result in a variable called <code>REPLY</code>. We can then use this variable to use the text that was read.</p><p>Why is the variable in uppercase? That's because even though we are setting the variable itself, it is still a &lsquo;special&rsquo; variable defined by the shell. It is the variable that <code>read</code> puts its input into if we don't explicitly tell <code>read</code> what the variable name should be.</p><h3 id=reading-into-a-variable>Reading into a Variable</h3><p>We can tell the <code>read</code> command to put the input it reads into a variable with a name of our choice by specifying the variable name after the command, like so:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>echo <span style=color:#e6db74>&#34;What is your name?&#34;</span>
read name
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Hello, </span><span style=color:#e6db74>${</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</code></pre></div><p>In general you should provide a variable name for <code>read</code> - it will make your script a little easier to understand. Not every user will know that the <code>$REPLY</code> variable is the default location, so they might find it confusing if you don't provide a variable name. By specifying a variable name explicitly we make our script easier to follow.</p><p>This also shows good coding practices - your variable names should be <em>descriptive</em>, and inform the reader of what they are likely to be used for. This makes the script easier to follow and maintain over time.</p><p>This is another time that we use a variable name without putting a dollar before it. It might be helpful to remember that the dollar is used when we want to <em>use</em> the variable and the dollar is omitted when we want to <em>set</em> the variable.</p><h3 id=prompting-for-input>Prompting for Input</h3><p>Before you run the <code>read</code> command you are probably going to write a message to the user letting them know they need to enter some input. We can either write out a message first to prompt the user, using the <code>echo</code> command as shown above, or we can use the special <code>-p</code> (<em>prompt</em>) parameter:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>read -p <span style=color:#e6db74>&#34;Please enter your name: &#34;</span> name
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Hello, </span>$name<span style=color:#e6db74>&#34;</span>
</code></pre></div><p>Now the output will look like this:</p><pre><code>Please enter your name: Dave
Hello, Dave
</code></pre><p><strong>Z-Shell Note</strong></p><p>If you are using the Z-Shell, then this command will fail as <code>zsh</code> does not use the <code>-p</code> parameter for at prompt. To prompt a user for input with the <code>read</code> command in <code>zsh</code>, just put a line of text after the command that starts with a question mark:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>read <span style=color:#e6db74>&#34;?Please enter your name: &#34;</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Hello, </span>$REPLY<span style=color:#e6db74>&#34;</span>
</code></pre></div><h3 id=reading-secrets>Reading Secrets</h3><p>The <code>-s</code> (<em>silent</em>) flag can be used to hide the input as it is being written. This is useful if you want to read a secret such as a password:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>read -s -p <span style=color:#e6db74>&#34;Enter a new password: &#34;</span> password
masked_password<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>echo <span style=color:#e6db74>&#34;</span>$password<span style=color:#e6db74>&#34;</span> | sed <span style=color:#e6db74>&#39;s/./*/g&#39;</span><span style=color:#66d9ef>)</span> 
echo <span style=color:#e6db74>&#34;&#34;</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Your password is: </span>$masked_password<span style=color:#e6db74>&#34;</span>
</code></pre></div><p>The output of this script will be something like the below:</p><pre><code>Enter a new password:
Your password is: ********
</code></pre><p>This uses the same trick as before to mask the characters. Note that when we use the <code>-s</code> flag, the read command does not print what we've typed - meaning we don't print the &lsquo;enter&rsquo; symbol that the user presses to finish entering text. This means we don't see a new line after the <code>read</code> command. So we use <code>echo ""</code> to write a newline before we show the output.</p><h3 id=limiting-the-input>Limiting the Input</h3><p>There may be times where you don't want to have the user press &lsquo;enter&rsquo; to indicate that they have finished writing input.</p><p>There are a couple of ways we can limit the input. The first is to use the <code>-n</code> (<em>number of characters</em>) parameter to limit the number of characters that are read:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>read -n <span style=color:#ae81ff>1</span> -p <span style=color:#e6db74>&#34;Continue? (y/n): &#34;</span> yesorno
echo <span style=color:#e6db74>&#34;&#34;</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>You typed: </span><span style=color:#e6db74>${</span>yesorno<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</code></pre></div><p>This script will only wait for the user to type a single character as we used the <code>-n</code> flag with the value <code>1</code> to specify that we want to read a single character only.</p><p>Because the user doesn't press &lsquo;enter&rsquo; at the end of their input, we need to add a blank newline before we show the output - otherwise it would look like this:</p><pre><code>Continue? (y/n): nYou typed: n
</code></pre><p>It's only when we read a full line of text that we don't need to write an empty line. That's because when we read a full line of text we finish by pressing &lsquo;enter&rsquo;, which moves the cursor down to the next line for us.</p><p>The other way to limit the input is to specify a character that is to use a <em>delimiter</em> to indicate when <code>read</code> should stop reading input:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>read -d <span style=color:#e6db74>&#39; &#39;</span> -p <span style=color:#e6db74>&#34;Enter your favourite word (then a space): &#34;</span> word
echo <span style=color:#e6db74>&#34;&#34;</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Your favourite word is: </span><span style=color:#e6db74>${</span>word<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</code></pre></div><p>Because we used the <code>-d ' '</code> parameter, the read command will read up until it finds a &lsquo;space&rsquo; symbol. This can be confusing for users however - if they press enter then <code>read</code> will read it as a newline and continue waiting for a space. So you should let the user know to finish input with the delimiter you have chosen!</p><p>In general using another anything than a newline as the delimiter may be confusing to the user, and also causes some problems when the user wants to type special characters such as backspace, so I would suggest that you avoid this trick. Instead, let the user type their input and then use something like <code>sed</code> to extract everything up to the point that you want.</p><p>There are a number of other options for the <code>read</code> command that you can read about by typing <code>help read</code>. But these are the ones that I think you will see most commonly used.</p><h1 id=mathematics>Mathematics</h1><p>The shell has some built in features that let you perform mathematical operations. You will commonly perform these operations on variables.</p><p>You might assume that you can use symbols like <code>+</code> directly in the your scripts to perform mathematical operations - but they may not perform as expected. For example, here's what happens if you try to add two numbers together with the <code>+</code> plus symbol:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>read -p <span style=color:#e6db74>&#34;Enter a number: &#34;</span> number1
read -p <span style=color:#e6db74>&#34;Enter another number: &#34;</span> number2
sum<span style=color:#f92672>=</span>$number1+$number2
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>The sum of </span>$number1<span style=color:#e6db74> and </span>$number2<span style=color:#e6db74> is </span>$sum<span style=color:#e6db74>&#34;</span>
</code></pre></div><p>If you run this script you'll see something like this:</p><pre><code>Enter a number: 23
Enter another number: 34
The sum of 23 and 34 is 23+34
</code></pre><p>The result we see is not the sum of the two numbers - it is the two numbers with the literal <code>+</code> plus symbol between them.</p><p>To tell the shell that we want to perform an arithmetic operation, rather than just write out a mathematical operator, we use the &lsquo;double parenthesis&rsquo; syntax shown below:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>read -p <span style=color:#e6db74>&#34;Enter a number: &#34;</span> number1
read -p <span style=color:#e6db74>&#34;Enter another number: &#34;</span> number2
sum<span style=color:#f92672>=</span><span style=color:#66d9ef>$((</span>$number1 <span style=color:#f92672>+</span> $number2<span style=color:#66d9ef>))</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>The sum of </span>$number1<span style=color:#e6db74> and </span>$number2<span style=color:#e6db74> is </span>$sum<span style=color:#e6db74>&#34;</span>
</code></pre></div><p>The output of this script will be something like the below:</p><pre><code>Enter a number: 23
Enter another number: 34
The sum of 23 and 34 is 57
</code></pre><p>There is an alternative syntax - we can use the <code>let</code> keyword to indicate to the shell that we want to perform an arithmetic operation. This would look like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>let sum<span style=color:#f92672>=</span>$number1 + $number2
</code></pre></div><p>I've included the <code>let</code> keyword here for completeness, but I would recommend that you use the double-parenthesis where possible as I think that it is probably the more commonly used construct.</p><p>There are many arithmetic operators available. Here's a table showing a few common ones and how they are used:</p><table><thead><tr><th>Operator</th><th>Meaning</th><th>Example</th></tr></thead><tbody><tr><td><code>+</code></td><td>Addition</td><td><code>echo $((3+4)) # prints 7</code></td></tr><tr><td><code>-</code></td><td>Subtraction</td><td><code>echo $((4-2)) # prints 2</code></td></tr><tr><td><code>*</code></td><td>Multiplication</td><td><code>echo $((4*2)) # prints 8</code></td></tr><tr><td><code>/</code></td><td>Division</td><td><code>echo $((4/2)) # prints 2</code></td></tr><tr><td><code>**</code></td><td>Exponent</td><td><code>echo $((4**3)) # prints 64</code></td></tr><tr><td><code>%</code></td><td>Modulus</td><td><code>echo $((7%3)) # prints 1</code></td></tr></tbody></table><p>If you want to find the complete set of arithmetic operators available or find more details on how arithmetic works in the shell, use <code>man bash</code> and search for the text <code>ARITHMETIC\ EVALUATION</code> (the backslash is needed to escape the space between the words when searching in the manual).</p><p>The script below shows how you can use a combination of operators to convert a value in degrees Celsius to Fahrenheit:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>read -p <span style=color:#e6db74>&#34;Enter a value in Celsius: &#34;</span> celcius
fahrenheit<span style=color:#f92672>=</span><span style=color:#66d9ef>$((</span> <span style=color:#f92672>(</span>celcius <span style=color:#f92672>*</span> <span style=color:#ae81ff>9</span><span style=color:#f92672>/</span><span style=color:#ae81ff>5</span><span style=color:#f92672>)</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>32</span> <span style=color:#66d9ef>))</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>celcius<span style=color:#e6db74>}</span><span style=color:#e6db74> degrees Celsius is </span><span style=color:#e6db74>${</span>fahrenheit<span style=color:#e6db74>}</span><span style=color:#e6db74> degrees Fahrenheit</span><span style=color:#e6db74>&#34;</span>
</code></pre></div><p>Note that you can use brackets in your arithmetic expressions to be explicit about the order in which the calculations should be performed. The order that is used if you don't use brackets is detailed in the manual page, but in general using brackets will make things clearer to the reader.</p><h1 id=arrays>Arrays</h1><p>Arrays are variables which can store multiple values. An array is created by using the equals symbol and putting the array values in parenthesis, like so:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>days<span style=color:#f92672>=</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Monday&#34;</span> <span style=color:#e6db74>&#34;Tuesday&#34;</span> <span style=color:#e6db74>&#34;Wednesday&#34;</span> <span style=color:#e6db74>&#34;Thursday&#34;</span> <span style=color:#e6db74>&#34;Friday&#34;</span> <span style=color:#e6db74>&#34;Saturday&#34;</span> <span style=color:#e6db74>&#34;Sunday&#34;</span><span style=color:#f92672>)</span>
</code></pre></div><p>Once you have defined your array you can retrieve an element at a given index by using the square bracket notation shown below:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>The first day is: </span><span style=color:#e6db74>${</span>days[0]<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>The last day is: </span><span style=color:#e6db74>${</span>days[6]<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</code></pre></div><p>Arrays in Bash start at index zero. Arrays in the Z-Shell start at index one - this can cause confusion and mistakes in scripts so it is something you might have to consider if you are writing scripts that can be used by either shell.</p><p>There are a number of useful operations you can perform on arrays. An example of each is shown below:</p><table><thead><tr><th>Operation</th><th>Syntax</th><th>Example</th></tr></thead><tbody><tr><td>Create Array</td><td>array=()</td><td><code>days=("Monday" "Tuesday" "Wednesday" "Thursday" "Friday" "Saturday" "Sunday")</code></td></tr><tr><td>Get Array Element</td><td>${array[index]}</td><td><code>echo ${days[2]} # prints 'Wednesday'</code></td></tr><tr><td>Get All Elements</td><td>${array[@]}</td><td><code>echo ${days[@]} # prints 'Monday Tuesday Wednesday Thursday Friday Saturday Sunday'</code></td></tr><tr><td>Set Array Element</td><td>${array[index]}=value</td><td><code>days[0]="Mon"</code></td></tr><tr><td>Get Array Indexes</td><td>${!array[@]}</td><td><code>arr=(); arr[3]="apple"; arr[5]="pear"; echo ${!arr[@]} # prints 3 5</code></td></tr><tr><td>Get Array Length</td><td>${#array[@]}</td><td><code>echo ${#days[@]} # Prints 7</code></td></tr><tr><td>Append to Array</td><td>array+=(val1 val2 valN)</td><td><code>fruits=(); fruits+=("Apples"); fruits+=("Pears" "Grapes"); echo ${fruits[@]} # prints 'Apples Pears Grapes'</code></td></tr><tr><td>Get a subset of elements</td><td>${array[@]:start:number}</td><td><code>echo ${days[@]:5:2} # prints 'Saturday Sunday'</code></td></tr></tbody></table><p>It's important to use curly braces around your array expressions. Note that in the examples above when we <em>set</em> an array value we don't use braces or the dollar symbol - this is consistent with what we've seen so far - variable names do not have a dollar symbol when we are setting a value.</p><p>You might have noticed from the examples that arrays in Bash can be <em>sparse</em> - that means that you can have &lsquo;gaps&rsquo; in your array. Arrays can also have a mixture of strings or numbers - not every element in an array has to be of the same type.</p><p>We'll see arrays in more detail in the chapter on Loops.</p><h1 id=variable-string-manipulation>Variable String Manipulation</h1><p>There are some built-in features in the Bash shell that allow you to manipulate string variables. In general I think that these are quite difficult to follow when they are in scripts so most readers can probably skip this section. But feel free to read about some of these common operations if you think you will use them or you think you might encounter them when working with scripts that other people have written!</p><p><strong>String Length</strong></p><p>The <code>${#var}</code> operator returns the length of the variable <code>var</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>var<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;The quick brown fox jumps over the lazy dog&#34;</span>
length<span style=color:#f92672>=</span><span style=color:#e6db74>${#</span>var<span style=color:#e6db74>}</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Length: </span>$length<span style=color:#e6db74>&#34;</span>
<span style=color:#75715e># Prints: 43</span>
</code></pre></div><p><strong>Set Default Value</strong></p><p>The <code>${var:-default}</code> operator returns the value of the variable <code>var</code> or the text <code>default</code> if it is not found:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>read -p <span style=color:#e6db74>&#34;Enter your username: &#34;</span> user
username<span style=color:#f92672>=</span><span style=color:#e6db74>${</span>user<span style=color:#66d9ef>:-</span>$USER<span style=color:#e6db74>}</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Username: </span>$username<span style=color:#e6db74>&#34;</span>
<span style=color:#75715e># Prints what you typed or the value of $USER otherwise</span>
</code></pre></div><p>There are a number of other operators that exist. They allow you to extract parts of a string, make test uppercase or lowercase, apply regular expressions and so on. But I would recommend avoiding them as they are fairly specific to bash and likely will be confusing to readers. If you need to manipulate text I would recommend that you use the techniques described in <a href=/docs/part-3-manipulating-text/><strong>Part 3 - Manipulating Text</strong></a>.</p><p>It is generally enough to know that if you see special symbols inside a <code>${variable}</code> expression then the writer is performing some kind of string manipulation. Hopefully they have included a comment that describes what they are doing to make it easier to follow!</p><h1 id=updating-the-common-command>Updating the &lsquo;Common&rsquo; Command</h1><p>With our new understanding of variables, we can improve the &lsquo;common&rsquo; command we created in the previous chapter by extracting certain values into variables so that they can be more easily changed.</p><p>Let's look at our original &lsquo;common&rsquo; command:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Write the title of our command.</span>
echo <span style=color:#e6db74>&#34;common commands:&#34;</span>

<span style=color:#75715e># Show the most commonly used commands.</span>
tail ~/.bash_history -n <span style=color:#ae81ff>1000</span> | sort | uniq -c | sed <span style=color:#e6db74>&#39;s/^ *//&#39;</span> | sort -n | tail -n <span style=color:#ae81ff>10</span>
</code></pre></div><p>We could improve on this by making the number of lines of text in the history we search through and the number of commands to show variables, so that they can be more easily changed.</p><p>Create a copy of the <code>common.v1.sh</code> script and call it <code>common.v2.sh</code> and update it like so:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Write the title of our command.</span>
echo <span style=color:#e6db74>&#34;common commands:&#34;</span>

<span style=color:#75715e># The following variables control how the command runs.</span>
history_lines<span style=color:#f92672>=</span><span style=color:#ae81ff>1000</span> <span style=color:#75715e># The number of lines of history to search through</span>
command_count<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span>   <span style=color:#75715e># The number of common commands to show.</span>

<span style=color:#75715e># Show the most commonly used commands.</span>
tail ~/.bash_history -n <span style=color:#e6db74>${</span>history_lines<span style=color:#e6db74>}</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    | sort <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    | uniq -c <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    | sed <span style=color:#e6db74>&#39;s/^ *//&#39;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    | sort -n <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    | tail -n <span style=color:#e6db74>${</span>command_count<span style=color:#e6db74>}</span>
</code></pre></div><p>We have replaced two &lsquo;hard-coded&rsquo; values (the number of lines of history to search and the number of common commands to show) with variables, which are now easier to find and change. We have also split the command into multiple lines so that it is easier to read (as the line is quite long otherwise).</p><p>If you want to replace the installed <code>common</code> command with this new one, update the symlink in your <em>/usr/local/bin</em> folder:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>ln -sf $HOME/effective-shell/scripts/common.v2.sh /usr/local/bin/common
</code></pre></div><p>Note that in this command we use the <code>-f</code> flag to force the creation of the symlink even if one already exists in the given location.</p><h1 id=summary>Summary</h1><p>In this chapter we looked at how environment variables work and how we can use our own variables. We saw how to read input from the user and how to perform arithmetic operations.</p><p>We've seen a few new constructs in this chapter that will appear again and again, these are summarised below so that you can recognise them!</p><ul><li><code>${variable}</code> gets the value of <code>variable</code> - the braces surround the variable name</li><li><code>$(echo "$PAGER")</code> runs the <code>echo</code> command in a subshell - the single parenthesis indicates we are running a subshell</li><li><code>$(($left + $right))</code> adds the values in the variables <code>left</code> and <code>right</code> - the double parenthesis indicate that we are performing arithmetic</li></ul><p>In the next chapter we are going to see how to perform <em>logic</em> in scripts - running commands only when certain conditions are met. This is an incredibly powerful technique and will let you create much more sophisticated scripts!</p></article><div class="book-footer justify-between"><div><a class="flex align-center" href=https://github.com/dwmkerr/effective-shell/commit/b816e3ce99476f42690dc3b9386742fd28c33059 title="Last modified by Dave Kerr | May 21, 2021" target=_blank><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>May 21, 2021</span></a></div><div><a class="flex align-center" href=https://github.com/dwmkerr/effective-shell/edit/master/website/content/docs/part-4-shell-scripting/variables-reading-input-and-mathematics/_index.md target=_blank><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"effective-shell"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><p>Copyright &copy; <script>document.write(new Date().getFullYear())</script>, Dave Kerr</p></div><aside class="book-toc levels-3 fixed"><nav id=TableOfContents><ul><li><a href=#chapter-19---variables-reading-input-and-mathematics>Chapter 19 - Variables, Reading Input, and Mathematics</a></li><li><a href=#variables>Variables</a><ul><li><a href=#setting-variables>Setting Variables</a></li><li><a href=#storing-the-output-of-a-command-into-a-variable>Storing the Output of a Command into a Variable</a></li><li><a href=#being-explicit-with-variable-names>Being Explicit with Variable Names</a></li></ul></li><li><a href=#the-read-command>The Read Command</a><ul><li><ul><li><a href=#reading-into-a-variable>Reading into a Variable</a></li><li><a href=#prompting-for-input>Prompting for Input</a></li><li><a href=#reading-secrets>Reading Secrets</a></li><li><a href=#limiting-the-input>Limiting the Input</a></li></ul></li></ul></li><li><a href=#mathematics>Mathematics</a></li><li><a href=#arrays>Arrays</a></li><li><a href=#variable-string-manipulation>Variable String Manipulation</a></li><li><a href=#updating-the-common-command>Updating the &lsquo;Common&rsquo; Command</a></li><li><a href=#summary>Summary</a></li></ul></nav></aside></main></body></html>