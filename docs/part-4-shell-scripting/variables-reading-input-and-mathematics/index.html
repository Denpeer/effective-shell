<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Variables, Reading Input, and Mathematics"><meta property="og:title" content="Variables, Reading Input, and Mathematics"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://effective-shell.com/docs/part-4-shell-scripting/variables-reading-input-and-mathematics/"><title>Variables, Reading Input, and Mathematics | Effective Shell</title><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.f8520695a602b532b093067e25561bfe6fa10ca8c25171b97142acf58fa8f13c.css integrity="sha256-+FIGlaYCtTKwkwZ+JVYb/m+hDKjCUXG5cUKs9Y+o8Tw="><script defer src=/en.search.min.49a2ce60154f676ad4f05eb4d7d4b56502de95dd3c0f8fc97ecdb281359ad1f7.js integrity="sha256-SaLOYBVPZ2rU8F6019S1ZQLeld08D4/Jfs2ygTWa0fc="></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-155335600-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><link rel=alternate type=application/rss+xml href=https://effective-shell.com/docs/part-4-shell-scripting/variables-reading-input-and-mathematics/index.xml title="Effective Shell"><script id=mcjs>!function(c,h,i,m,p){m=c.createElement(h),p=c.getElementsByTagName(h)[0],m.async=1,m.src=i,p.parentNode.insertBefore(m,p)}(document,"script","https://chimpstatic.com/mcjs-connected/js/users/eac1a082b6db34d40aaff2caf/a2aaca5a8358c2e12d3f43f1a.js");</script></head><body><input type=checkbox class=hidden id=menu-control><main class="flex container"><aside class="book-menu fixed"><nav><h2 class=book-brand><a href=https://effective-shell.com/><span>Effective Shell</span></a></h2><h2 class=book-subtitle><span>By Dave Kerr</span></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/docs/introduction/><strong>Introduction</strong></a></li><li><a href=/docs/getting-started/><strong>Getting Started</strong></a></li><li><a href=/docs/part-1-transitioning-to-the-shell/><strong>Part 1 - Transitioning to the Shell</strong></a><ul><li><a href=/docs/part-1-transitioning-to-the-shell/navigating-your-system/>Navigating Your System</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/managing-your-files/>Managing Your Files</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/clipboard-gymnastics/>Clipboard Gymnastics</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/getting-help/>Getting Help</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/the-renaissance-of-the-shell/>The Renaissance of the Shell</a></li></ul></li><li><a href=/docs/part-2-core-skills/><strong>Part 2 - Core Skills</strong></a><ul><li><a href=/docs/part-2-core-skills/thinking-in-pipelines/>Thinking in Pipelines</a></li><li><a href=/docs/part-2-core-skills/fly-on-the-command-line/>Fly on the Command Line</a></li><li><a href=/docs/part-2-core-skills/job-control/>Job Control</a></li><li><a href=/docs/part-2-core-skills/understanding-commands/>Understanding Commands</a></li><li><a href=/docs/part-2-core-skills/finding-files/>Finding Files</a></li><li><a href=/docs/part-2-core-skills/what-is-a-shell/>What is a Shell?</a></li></ul></li><li><a href=/docs/part-3-manipulating-text/><strong>Part 3 - Manipulating Text</strong></a><ul><li><a href=/docs/part-3-manipulating-text/regex-essentials/>Regex Essentials</a></li><li><a href=/docs/part-3-manipulating-text/get-to-grips-with-grep/>Get to Grips with Grep</a></li><li><a href=/docs/part-3-manipulating-text/slice-and-dice-text/>Slice and Dice Text</a></li><li><a href=/docs/part-3-manipulating-text/advanced-text-manipulation/>Advanced Text Manipulation with Sed</a></li><li><a href=/docs/part-3-manipulating-text/build-commands-on-the-fly/>Build Commands on the Fly with Xargs</a></li></ul></li><li><a href=/docs/part-4-shell-scripting/><strong>Part 4 - Shell Scripting</strong></a><ul><li><a href=/docs/part-4-shell-scripting/shell-script-essentials/>Shell Script Essentials</a></li><li><a href=/docs/part-4-shell-scripting/variables-reading-input-and-mathematics/ class=active>Variables, Reading Input, and Mathematics</a></li><li><a href=/docs/part-4-shell-scripting/mastering-conditional-logic/>Mastering Conditional Logic</a></li><li><a href=/docs/part-4-shell-scripting/loops-and-working-with-files-and-folders/>Loops and working with Files and Folders</a></li><li><a href=/docs/part-4-shell-scripting/functions-parameters-and-error-handling/>Functions, Parameters and Error Handling</a></li><li><a href=/docs/part-4-shell-scripting/useful-patterns-for-shell-scripts/>Useful Patterns for Shell Scripts</a></li></ul></li><li><a href=/docs/part-5-building-your-toolkit/><strong>Part 5 - Building Your Toolkit</strong></a><ul><li><a href=/docs/part-5-building-your-toolkit/configuring-the-shell/>Configuring the Shell</a></li><li><a href=/docs/part-5-building-your-toolkit/customising-your-command-prompt/>Customising Your Command Prompt</a></li><li><a href=/docs/part-5-building-your-toolkit/managing-your-dotfiles/>Managing Your Dotfiles</a></li></ul></li><li><a href=/docs/work-in-progress/><strong>Work in Progress</strong></a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class="flex align-center justify-between book-header"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Variables, Reading Input, and Mathematics</strong></header><article class=markdown><h1 id=chapter-19---variables-reading-input-and-mathematics>Chapter 19 - Variables, Reading Input, and Mathematics</h1><p>We've seen variables a few times in our journey so far. In this chapter we'll look at variables in a bit more detail. We'll then see how to read input from the user and also look at how to perform basic mathematical operations in the shell.</p><h1 id=variables>Variables</h1><p><em>Variables</em> are places where the system, the shell, or shell users like ourselves can store data.</p><p>We've already seen variables a few times in this book. For example in <a href=/docs/part-1-transitioning-to-the-shell/getting-help/>Chapter 5 - Getting Help</a> we saw the <code>$PAGER</code> variable that is used to specify what pager program should be used in the shell.</p><p>When we want to use a variable in the shell, we use the <code>$</code> dollar symbol to specify the variable name:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Your pager is: </span>$PAGER<span style=color:#e6db74>&#34;</span>
</code></pre></div><p>If you run this command you will see something like this:</p><pre><code>Your pager is: less
</code></pre><p>By convention, if a variable is in uppercase then it is an _environment variable_ or a built in variable that comes from the shell. An environment variable is a variable that is set by the system. They often contain useful values and are used to help configure your system.</p><p>Here's a few common environment variables we might use:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Your shell is: </span>$SHELL<span style=color:#e6db74>&#34;</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Your user is: </span>$USER<span style=color:#e6db74>&#34;</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Your user&#39;s home directory is: </span>$HOME<span style=color:#e6db74>&#34;</span>
</code></pre></div><p>Your output will look similar to the below:</p><pre><code>Your shell is: /bin/bash
Your user is: dwmkerr
Your user's home directory is: /home/dwmkerr
</code></pre><h2 id=setting-variables>Setting Variables</h2><p>You can create or set your own variables by simply entering the name you would like to use and putting an <code>=</code> equals symbol after the variable, followed by the value you would like to use.</p><p>This is the one of the few times that you will use a variable name without putting a dollar symbol before it!</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Dave&#34;</span>
location<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Singapore&#34;</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Hello </span>$name<span style=color:#e6db74> in </span>$location<span style=color:#e6db74>&#34;</span>
</code></pre></div><p>This will produce the output:</p><pre><code>Hello Dave in Singapore
</code></pre><p>By convention, variables that you define yourself should be lowercase. This helps to distinguish between environment variables and your own variables.</p><p>It is a good habit to use lowercase for variable names. Using uppercase will work, but when you use uppercase you run the risk of &lsquo;overwriting&rsquo; the value of an environment variable and causing unexpected results later.</p><p>For example, in this snippet I accidentally overwrite the <code>USER</code> variable. If a later part of the script expects the <code>USER</code> variable to contain the Linux username of the user then there will likely be an error because I have set it to something else!</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Don&#39;t do this!</span>
USER<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Dave Kerr&#34;</span>

<span style=color:#75715e># If I wanted to go to my home directory, this command would fail. That&#39;s</span>
<span style=color:#75715e># because USER should be &#39;dwmkerr&#39; but I&#39;ve set it to something else!</span>
cd <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>/home/</span>$USER<span style=color:#e6db74>&#34;</span>
</code></pre></div><p>If you set a system variable to something incorrect, the impact will be limited to only the script you are running or the shell session you are in, or any commands you run from the script or session - other running programs will <em>not</em> have their copy of the variable changed. You can read more about this in the <a href=/docs/work-in-progress/>Processes</a> chapter of the <a href=/docs/work-in-progress/>Linux Fundamentals</a> section.</p><h2 id=storing-the-output-of-a-command-into-a-variable>Storing the Output of a Command into a Variable</h2><p>We can use a _subshell_ to run a command and store the result in a variable.</p><p>For example, if we had a variable which held a user's password and wanted to show it on the screen in a &lsquo;masked&rsquo; form, where all of the characters are replaced with an asterisks symbol, we could write the password variable into the <code>sed</code> command and replace every character with an asterisks symbol like so:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>password<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;somethingsecret&#34;</span>
masked_password<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>echo <span style=color:#e6db74>&#34;</span>$password<span style=color:#e6db74>&#34;</span> | sed <span style=color:#e6db74>&#39;s/./*/g&#39;</span><span style=color:#66d9ef>)</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Setting password &#39;</span><span style=color:#e6db74>${</span>masked_password<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;...</span><span style=color:#e6db74>&#34;</span>
</code></pre></div><p>The output of this script will look like this:</p><pre><code>Setting password '***************'...
</code></pre><p>To execute a set of commands in a &lsquo;sub shell&rsquo;, we can use the <code>$()</code> sequence. Everything inside the brackets will be executed in a new shell. We can then store the output of the commands in a variable by using the <code>=</code> equals symbol.</p><h2 id=being-explicit-with-variable-names>Being Explicit with Variable Names</h2><p>You can use curly braces around the name of a variable to be more explicit about what the variable name is. Let's take a look at why you might need to do this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Creating backup folder at: &#39;</span>$USERbackup<span style=color:#e6db74>&#39;</span><span style=color:#e6db74>&#34;</span>
mkdir $USERbackup
</code></pre></div><p>This script shows the output:</p><pre><code>Creating backup folder at: ''
usage: mkdir [-pv] [-m mode] directory ...
</code></pre><p>Rather than creating a folder called <code>dwmkerrbackup</code> (which is my <code>$USER</code> variable followed by the text <code>backup</code>), the script has actually failed. That is because it is looking for a variable called <code>USERbackup</code> - which has does not exist!</p><p>To get around this we would surround the variable name with curly braces like so:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Creating backup folder at: &#39;</span><span style=color:#e6db74>${</span>USER<span style=color:#e6db74>}</span><span style=color:#e6db74>backup&#39;</span><span style=color:#e6db74>&#34;</span>
mkdir <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>USER<span style=color:#e6db74>}</span><span style=color:#e6db74>backup</span><span style=color:#e6db74>&#34;</span>
</code></pre></div><p>This script will show the correct output:</p><pre><code>Creating backup folder at: 'dwmkerrbackup'
</code></pre><p>If there is ever any potential ambiguity with a variable name you should enclose it with curly braces to be on the safe side. Some people will use curly braces in all circumstances to be as explicit as possible about what the variable name is and reduce the risk of mistakes if someone later comes along to edit or change the code.</p><p>This script would be improved with the use of a variable of our own to avoid us having to repeat the <code>${USER}backup</code> text:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>backupdir<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>USER<span style=color:#e6db74>}</span><span style=color:#e6db74>backup</span><span style=color:#e6db74>&#34;</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Creating backup folder at: &#39;</span><span style=color:#e6db74>${</span>backupdir<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>&#34;</span>
mkdir <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>backupdir<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</code></pre></div><p>In this case creating a variable to save us from creating the backup directory folder name each time we want to use it.</p><p>We've looked at environment variables and our own <em>local</em> variables. Now let's look at how we can read input from the user and store it in a variable for later usage.</p><h1 id=arrays>Arrays</h1><p>Arrays are variables that can store multiple values. An array is created by using the equals symbol and putting the array values in parenthesis, like so:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>days<span style=color:#f92672>=</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Monday&#34;</span> <span style=color:#e6db74>&#34;Tuesday&#34;</span> <span style=color:#e6db74>&#34;Wednesday&#34;</span> <span style=color:#e6db74>&#34;Thursday&#34;</span> <span style=color:#e6db74>&#34;Friday&#34;</span> <span style=color:#e6db74>&#34;Saturday&#34;</span> <span style=color:#e6db74>&#34;Sunday&#34;</span><span style=color:#f92672>)</span>
</code></pre></div><p>Once you have defined your array you can retrieve an element at a given index by using the square bracket notation shown below:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>The first day is: </span><span style=color:#e6db74>${</span>days[0]<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>The last day is: </span><span style=color:#e6db74>${</span>days[6]<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</code></pre></div><p>Arrays in Bash start at index zero. Arrays in the Z-Shell start at index one - this can cause confusion and mistakes in scripts so it is something you might have to consider if you are writing scripts that can be used by either shell.</p><p>There are a number of useful operations you can perform on arrays. An example of each is shown below:</p><table><thead><tr><th>Operation</th><th>Syntax</th><th>Example</th></tr></thead><tbody><tr><td>Create Array</td><td><code>array=()</code></td><td><code>days=("Monday" "Tuesday" "Wednesday" "Thursday" "Friday" "Saturday" "Sunday")</code></td></tr><tr><td>Get Array Element</td><td><code>${array[index]}</code></td><td><code>echo ${days[2]} # prints 'Wednesday'</code></td></tr><tr><td>Get All Elements</td><td><code>${array[@]}</code></td><td><code>echo ${days[@]} # prints 'Monday Tuesday Wednesday Thursday Friday Saturday Sunday'</code></td></tr><tr><td>Set Array Element</td><td><code>${array[index]}=value</code></td><td><code>days[0]="Mon"</code></td></tr><tr><td>Get Array Indexes</td><td><code>${!array[@]}</code></td><td><code>arr=(); arr[3]="apple"; arr[5]="pear"; echo ${!arr[@]} # prints 3 5</code></td></tr><tr><td>Get Array Length</td><td><code>${#array[@]}</code></td><td><code>echo ${#days[@]} # Prints 7</code></td></tr><tr><td>Append to Array</td><td><code>array+=(val1 val2 valN)</code></td><td><code>fruits=(); fruits+=("Apples"); fruits+=("Pears" "Grapes"); echo ${fruits[@]} # prints 'Apples Pears Grapes'</code></td></tr><tr><td>Get a subset of elements</td><td><code>${array[@]:start:number}</code></td><td><code>echo ${days[@]:5:2} # prints 'Saturday Sunday'</code></td></tr></tbody></table><p>It's important to use curly braces around your array expressions. Note that in the examples above when we <em>set</em> an array value we don't use braces or the dollar symbol - this is consistent with what we've seen so far - variable names do not have a dollar symbol when we are setting a value.</p><p>You might have noticed from the examples that arrays in Bash can be <em>sparse</em> - that means that you can have &lsquo;gaps&rsquo; in your array. Arrays can also have a mixture of strings or numbers - not every element in an array has to be of the same type.</p><p>We'll see arrays in more detail in the chapter on Loops.</p><h2 id=associative-arrays>Associative Arrays</h2><p>More recent versions of Bash support the concept of <em>Associative Arrays</em>. These are arrays where rather than having a numeric index associated with each value, you can have a string. This allows you to create a &lsquo;map&rsquo; or &lsquo;hash table&rsquo; structure.</p><p>An associative array is created using the <code>declare</code> (<em>set variable</em>) command:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Create an associative array called &#39;user&#39;.</span>
declare -A book

<span style=color:#75715e># Set some values on the array.</span>
book<span style=color:#f92672>[</span>title<span style=color:#f92672>]</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Effective Shell&#34;</span>
book<span style=color:#f92672>[</span>author<span style=color:#f92672>]</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Dave Kerr&#34;</span>

<span style=color:#75715e># Show one of the values.</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Book details: </span><span style=color:#e6db74>${</span>book[title]<span style=color:#e6db74>}</span><span style=color:#e6db74> - </span><span style=color:#e6db74>${</span>book[author]<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</code></pre></div><p>Running this command will show the output:</p><pre><code>Book details: Effective Shell - Dave Kerr
</code></pre><p>If you find yourself using associative arrays, I would expect that there is a good chance you are trying to do something that is more complex than is suitable for a shell script. In this circumstance I'd suggest you read the chapter <a href=/docs/work-in-progress/>How to avoid scripting!</a> to see how I'd look at alternative options!</p><h1 id=quoting-variables-and-values>Quoting Variables and Values</h1><p>There is often a lot of confusion about a specific topic in the shell - when should you surround a variable in quotes? This might sound like it is a purely stylistic question, but surrounding a variable in quotes can dramatically change how your script works.</p><p>We're going to look at each type of quoting and when it should be used in the examples below. But if you ever need a reminder, run <code>man bash</code> and search for the text <code>QUOTING</code>.</p><h2 id=single-quotes---literal-values>Single Quotes - Literal Values</h2><p>Use single quotes when declaring a variable or using a value if you want to use literal text. The shell will <em>not</em> expand special characters or variables:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>message<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;   ~~ Save $$$ on with ** &#34;this deal&#34; ** ! ~~   &#39;</span>
echo <span style=color:#e6db74>&#34;</span>$message<span style=color:#e6db74>&#34;</span>
</code></pre></div><p>This script will show:</p><pre><code>   ~~ Save $$$ on with ** &quot;this deal&quot; ** ! ~~
</code></pre><p>Note that the shell has <em>not</em> tried to expand the <code>~</code> tilde into <code>/home/dwmkerr</code>. It has not expanded the <code>*</code> asterisks into a wildcard pattern and it has not tried to use the <code>$</code> dollar symbol to reference an array.</p><p>Single quotes should be used when you want to put special characters into a variable, or call a command that includes whitespace or special characters.</p><h2 id=single-quotes---ansi-c-quoting>Single Quotes - ANSI C Quoting</h2><p>There is a special form of single quotes called &lsquo;ANSI C Quoting&rsquo; that allows you to use escape sequences from the C language. ANSI C quoting is single quoting that starts with a dollar symbol. You can use it to use special characters like newlines in a variable:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>message1<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;Hello\nWorld&#39;</span>
message2<span style=color:#f92672>=</span><span style=color:#e6db74>$&#39;Hello\nWorld&#39;</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Message 1: </span>$message1<span style=color:#e6db74>&#34;</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Message 2: </span>$message2<span style=color:#e6db74>&#34;</span>
</code></pre></div><p>This snippet will show the following results:</p><pre><code>Message 1: Hello\nWorld
Message 2: Hello
World
</code></pre><h2 id=double-quotes---parameter-expansion>Double Quotes - Parameter Expansion</h2><p>Double quotes work in a very similar way to single quotes except that they allow you to use <em>parameter expansion</em> with the <code>$</code> dollar symbol and escaping with the <code>\</code> symbol. The ```` backtick symbol is also treated differently. Let's see some examples:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>deal<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Buy one get one free&#34;</span>
message<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Deal is &#39;</span>$deal<span style=color:#e6db74>&#39; - save \$</span><span style=color:#e6db74>&#34;</span>
echo <span style=color:#e6db74>&#34;</span>$message<span style=color:#e6db74>&#34;</span>
</code></pre></div><p>The output of this snippet is:</p><pre><code>Deal is 'Buy one get one free' - save $
</code></pre><p>Notice that the <code>$deal</code> value has been expanded into the contents of the <code>$deal</code> variable. The last dollar symbol has been escaped with a <code>\</code> backslash - the shell knows that this means we want to use the <em>literal</em> value of the dollar symbol at the end of the message. The backslash has been removed.</p><p>The backtick character is also treated differently, as the backtick can be used to run a sub-shell:</p><pre><code>$ echo &quot;The date is `date`&quot;
The date is Sun 23 May 2021 11:36:54 AM +08
</code></pre><p>However, you should <em>not</em> use the backtick character to run a sub-shell, it is harder to read than using the dollar and parenthesis syntax we've already seen:</p><pre><code>$ echo &quot;The date is `date`&quot;
The date is Sun 23 May 2021 11:36:54 AM +08
</code></pre><h2 id=no-quotes---shell-expansion>No Quotes - Shell Expansion</h2><p>If you don't include quotes around a variable or value, then the shell will perform a series of operations called <em>Shell Expansion</em>. This includes many options we've seen so far, let's take a look at some examples:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>home<span style=color:#f92672>=</span>~
tilde<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;~&#34;</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>My home is: </span>$home<span style=color:#e6db74>&#34;</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>A tilde is: </span>$tilde<span style=color:#e6db74>&#34;</span>
</code></pre></div><p>This snippet shows the results:</p><pre><code>My home is: /home/dwmkerr
A tilde is: ~
</code></pre><p>In the first case the shell has expanded the <code>~</code> tilde to the home directory.</p><p>We do not use quotes around a variable or a value if we want the shell to shell expansion. The following expansions will be performed:</p><ul><li>Brace expansion: <code>touch file{1,2,3}</code> is expanded to <code>touch file1 file2 file3</code></li><li>Tilde expansion: <code>cd ~</code> is expanded to <code>cd /home/dwmkerr</code></li><li>Parameter and variable expansion <code>echo $SHELL</code> is expanded to <code>echo /usr/bin/sh</code> (note that this expansion also occurs with double quotes)</li><li>Command substitution: <code>echo $(date)</code> is expanded to echo the results of the <code>date</code> command (this also occurs with double quotes)</li><li>Arithmetic expansion: <code>square=$((4 * 4))</code> has the value <code>4 * 4</code> evaluated mathematically (we see this at the end of this chapter)</li><li>Word splitting: this is a more complex topic discussed in <a href=/docs/part-4-shell-scripting/loops-and-working-with-files-and-folders/>Chapter 21 - Loops and working with Files and Folders</a></li><li>Pathname expansion: <code>ls *.txt</code> is expanded to all filename that match the wildcard pattern <code>*.txt</code></li></ul><p>We are going to see more detail on Shell Expansion as we continue through this part of the book. There is also a detailed explanation in the final section of the book and an appendix with a quick reference.</p><h2 id=quoting-tips>Quoting Tips</h2><p>Quoting can seem confusing - but remember these tips and you will generally be on the right path:</p><ul><li>Use double quotes most of the time - they will handle variables and sub-shells for you and not do weird things like word splitting</li><li>Use single quotes for literal values</li><li>Use no quotes if you want to expand wildcards</li></ul><h1 id=shell-parameter-expansion>Shell Parameter Expansion</h1><p>Shell Parameter Expansion is the process by which the shell evaluates a variable that follows the <code>$</code> dollar symbol. In most of our examples we've seen simple expansion where we just expand the variable into its value, like so:</p><pre><code>$ echo &quot;My shell is $SHELL&quot;
My shell is: /usr/bin/sh
</code></pre><p>But there are a number of special features we can use when expanding parameters. There are many options available and you can find them all by running <code>man bash</code> and searching for the text <code>EXPANSION</code>. Let's take a look at some of the most common ones.</p><p><strong>Length</strong></p><p>The <code>${#var}</code> operator returns the length of the variable <code>var</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>var<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;The quick brown fox jumps over the lazy dog&#34;</span>
length<span style=color:#f92672>=</span><span style=color:#e6db74>${#</span>var<span style=color:#e6db74>}</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Length: </span>$length<span style=color:#e6db74>&#34;</span>
<span style=color:#75715e># Prints: 43</span>
</code></pre></div><p><strong>Set Default Value</strong></p><p>The <code>${var:-default}</code> operator returns the value of the variable <code>var</code> or the text <code>default</code> if it is not found:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>read -p <span style=color:#e6db74>&#34;Enter your username: &#34;</span> user
username<span style=color:#f92672>=</span><span style=color:#e6db74>${</span>user<span style=color:#66d9ef>:-</span>$USER<span style=color:#e6db74>}</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Username: </span>$username<span style=color:#e6db74>&#34;</span>
<span style=color:#75715e># Prints what you typed or the value of $USER otherwise</span>
</code></pre></div><p><strong>Substring</strong></p><p>The <code>${var:start:count}</code> operator returns a subset of the <code>var</code> variable, starting at position <code>start</code> and extracting up to <code>count</code> characters. If <code>count</code> is omitted everything from <code>start</code> to the end of the string is returned.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>path<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;~/effective-shell&#34;</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>path:0:2<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
<span style=color:#75715e># Prints ~/</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>path:2<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
<span style=color:#75715e># Prints effective-shell</span>
</code></pre></div><p><strong>Make Uppercase</strong></p><p>The <code>${var^^}</code> operator returns the value of <code>var</code> with the text transformed to uppercase:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>message<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;don&#39;t shout&#34;</span>
echo <span style=color:#e6db74>${</span>message^^<span style=color:#e6db74>}</span>
<span style=color:#75715e># Prints: DON&#39;T SHOUT</span>
</code></pre></div><p><strong>Make Lowercase</strong></p><p>The <code>${var,,}</code> operator returns the value of <code>var</code> with the text transformed to lowercase:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>message<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;DON&#39;T SHOUT&#34;</span>
echo <span style=color:#e6db74>${</span>message,,<span style=color:#e6db74>}</span>
<span style=color:#75715e># Prints: don&#39;t shout</span>
</code></pre></div><p><strong>Variable Indirection</strong></p><p>The <code>${!var_name}</code> operator returns the value of the variable with the name in specified in the <code>var_name</code> variable. This is useful if you want to get the value of a variable but don't know the name of the variable:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>read -p <span style=color:#e6db74>&#34;Enter a variable name: &#34;</span> var_name
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>The value of &#39;</span><span style=color:#e6db74>${</span>var_name<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39; is: </span><span style=color:#e6db74>${</span>!var_name<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</code></pre></div><p>The output of this snippet would look like this:</p><pre><code>$ Enter a variable name: SHELL
The value of 'SHELL' is: /bin/bash
</code></pre><p>Notice the similarity to the Array operators such as <code>${#array[@]}</code> to get the length of an array.</p><p>There are a number of other operators that exist. They allow you to extract parts of a string, apply regular expressions, manipulate the case and perform a number of complex operations. I would avoid these techniques if possible as they are fairly specific to Bash and likely will be confusing to readers. Some of these substitutions are not available in older versions of Bash.</p><p>If you need to manipulate text I would recommend that you use the techniques described in <a href=/docs/part-3-manipulating-text/><strong>Part 3 - Manipulating Text</strong></a>.</p><p>It is generally enough to know that if you see special symbols inside a <code>${variable}</code> expression then the writer is performing some kind of string manipulation. Hopefully they have included a comment that describes what they are doing to make it easier to follow!</p><p>You can find out more about these features in the manual under the <code>EXPANSION</code> section<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><h1 id=the-read-command>The Read Command</h1><p>The <code>read</code> (<em>read from standard input</em>) command can be used to read a line of text from standard input. When the text is read it is put into a variable, allowing it to be used in our scripts.</p><p>Let's see how this look in action!</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>echo <span style=color:#e6db74>&#34;What is your name?&#34;</span>
read
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Hello, </span>$REPLY<span style=color:#e6db74>&#34;</span>
</code></pre></div><p>Run the script - when you have finished writing your name, press &lsquo;enter&rsquo;. This is needed because <code>read</code> will keep on reading until it reaches the end of a line, so we need to press &lsquo;enter&rsquo; to complete the input.</p><pre><code>What is your name?
Dave
Hello, Dave
</code></pre><p>The <code>read</code> command reads a line of text from standard input and stores the result in a variable called <code>REPLY</code>. We can then use this variable to use the text that was read.</p><p>Why is the variable in uppercase? That's because even though we are setting the variable itself, it is still a &lsquo;special&rsquo; variable defined by the shell. It is the variable that <code>read</code> puts its input into if we don't explicitly tell <code>read</code> what the variable name should be.</p><h3 id=reading-into-a-variable>Reading into a Variable</h3><p>We can tell the <code>read</code> command to put the input it reads into a variable with a name of our choice by specifying the variable name after the command, like so:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>echo <span style=color:#e6db74>&#34;What is your name?&#34;</span>
read name
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Hello, </span><span style=color:#e6db74>${</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</code></pre></div><p>In general you should provide a variable name for <code>read</code> - it will make your script a little easier to understand. Not every user will know that the <code>$REPLY</code> variable is the default location, so they might find it confusing if you don't provide a variable name. By specifying a variable name explicitly we make our script easier to follow.</p><p>This also shows good coding practices - your variable names should be <em>descriptive</em>, and inform the reader of what they are likely to be used for. This makes the script easier to follow and maintain over time.</p><p>This is another time that we use a variable name without putting a dollar before it. It might be helpful to remember that the dollar is used when we want to <em>use</em> the variable and the dollar is omitted when we want to <em>set</em> the variable.</p><h3 id=prompting-for-input>Prompting for Input</h3><p>Before you run the <code>read</code> command you are probably going to write a message to the user letting them know they need to enter some input. We can either write out a message first to prompt the user, using the <code>echo</code> command as shown above, or we can use the special <code>-p</code> (<em>prompt</em>) parameter:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>read -p <span style=color:#e6db74>&#34;Please enter your name: &#34;</span> name
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Hello, </span>$name<span style=color:#e6db74>&#34;</span>
</code></pre></div><p>Now the output will look like this:</p><pre><code>Please enter your name: Dave
Hello, Dave
</code></pre><p><strong>Z-Shell Note</strong></p><p>If you are using the Z-Shell, then this command will fail as <code>zsh</code> does not use the <code>-p</code> parameter for at prompt. To prompt a user for input with the <code>read</code> command in <code>zsh</code>, just put a line of text after the command that starts with a question mark:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>read <span style=color:#e6db74>&#34;?Please enter your name: &#34;</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Hello, </span>$REPLY<span style=color:#e6db74>&#34;</span>
</code></pre></div><h3 id=reading-secrets>Reading Secrets</h3><p>The <code>-s</code> (<em>silent</em>) flag can be used to hide the input as it is being written. This is useful if you want to read a secret such as a password:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>read -s -p <span style=color:#e6db74>&#34;Enter a new password: &#34;</span> password
masked_password<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>echo <span style=color:#e6db74>&#34;</span>$password<span style=color:#e6db74>&#34;</span> | sed <span style=color:#e6db74>&#39;s/./*/g&#39;</span><span style=color:#66d9ef>)</span> 
echo <span style=color:#e6db74>&#34;&#34;</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Your password is: </span>$masked_password<span style=color:#e6db74>&#34;</span>
</code></pre></div><p>The output of this script will be something like the below:</p><pre><code>Enter a new password:
Your password is: ********
</code></pre><p>This uses the same trick as before to mask the characters. Note that when we use the <code>-s</code> flag, the read command does not print what we've typed - meaning we don't print the &lsquo;enter&rsquo; symbol that the user presses to finish entering text. This means we don't see a new line after the <code>read</code> command. So we use <code>echo ""</code> to write a newline before we show the output.</p><h3 id=limiting-the-input>Limiting the Input</h3><p>There may be times where you don't want to have the user press &lsquo;enter&rsquo; to indicate that they have finished writing input.</p><p>There are a couple of ways we can limit the input. The first is to use the <code>-n</code> (<em>number of characters</em>) parameter to limit the number of characters that are read:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>read -n <span style=color:#ae81ff>1</span> -p <span style=color:#e6db74>&#34;Continue? (y/n): &#34;</span> yesorno
echo <span style=color:#e6db74>&#34;&#34;</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>You typed: </span><span style=color:#e6db74>${</span>yesorno<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</code></pre></div><p>This script will only wait for the user to type a single character as we used the <code>-n</code> flag with the value <code>1</code> to specify that we want to read a single character only.</p><p>Because the user doesn't press &lsquo;enter&rsquo; at the end of their input, we need to add a blank newline before we show the output - otherwise it would look like this:</p><pre><code>Continue? (y/n): nYou typed: n
</code></pre><p>It's only when we read a full line of text that we don't need to write an empty line. That's because when we read a full line of text we finish by pressing &lsquo;enter&rsquo;, which moves the cursor down to the next line for us.</p><p>The other way to limit the input is to specify a character that is to use a <em>delimiter</em> to indicate when <code>read</code> should stop reading input:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>read -d <span style=color:#e6db74>&#39; &#39;</span> -p <span style=color:#e6db74>&#34;Enter your favourite word (then a space): &#34;</span> word
echo <span style=color:#e6db74>&#34;&#34;</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Your favourite word is: </span><span style=color:#e6db74>${</span>word<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</code></pre></div><p>Because we used the <code>-d ' '</code> parameter, the read command will read up until it finds a &lsquo;space&rsquo; symbol. This can be confusing for users however - if they press enter then <code>read</code> will read it as a newline and continue waiting for a space. So you should let the user know to finish input with the delimiter you have chosen!</p><p>In general using another anything than a newline as the delimiter may be confusing to the user, and also causes some problems when the user wants to type special characters such as backspace, so I would suggest that you avoid this trick. Instead, let the user type their input and then use something like <code>sed</code> to extract everything up to the point that you want.</p><p>There are a number of other options for the <code>read</code> command that you can read about by typing <code>help read</code>. But these are the ones that I think you will see most commonly used.</p><h1 id=mathematics>Mathematics</h1><p>The shell has some built in features that let you perform mathematical operations. You will commonly perform these operations on variables.</p><p>You might assume that you can use symbols like <code>+</code> directly in the your scripts to perform mathematical operations - but they may not perform as expected. For example, here's what happens if you try to add two numbers together with the <code>+</code> plus symbol:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>read -p <span style=color:#e6db74>&#34;Enter a number: &#34;</span> number1
read -p <span style=color:#e6db74>&#34;Enter another number: &#34;</span> number2
sum<span style=color:#f92672>=</span>$number1+$number2
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>The sum of </span>$number1<span style=color:#e6db74> and </span>$number2<span style=color:#e6db74> is </span>$sum<span style=color:#e6db74>&#34;</span>
</code></pre></div><p>If you run this script you'll see something like this:</p><pre><code>Enter a number: 23
Enter another number: 34
The sum of 23 and 34 is 23+34
</code></pre><p>The result we see is not the sum of the two numbers - it is the two numbers with the literal <code>+</code> plus symbol between them.</p><p>To tell the shell that we want to perform an arithmetic operation, rather than just write out a mathematical operator, we use the &lsquo;double parenthesis&rsquo; syntax shown below:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>read -p <span style=color:#e6db74>&#34;Enter a number: &#34;</span> number1
read -p <span style=color:#e6db74>&#34;Enter another number: &#34;</span> number2
sum<span style=color:#f92672>=</span><span style=color:#66d9ef>$((</span>$number1 <span style=color:#f92672>+</span> $number2<span style=color:#66d9ef>))</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>The sum of </span>$number1<span style=color:#e6db74> and </span>$number2<span style=color:#e6db74> is </span>$sum<span style=color:#e6db74>&#34;</span>
</code></pre></div><p>The output of this script will be something like the below:</p><pre><code>Enter a number: 23
Enter another number: 34
The sum of 23 and 34 is 57
</code></pre><p>There is an alternative syntax - we can use the <code>let</code> keyword to indicate to the shell that we want to perform an arithmetic operation. This would look like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>let sum<span style=color:#f92672>=</span>$number1 + $number2
</code></pre></div><p>I've included the <code>let</code> keyword here for completeness, but I would recommend that you use the double-parenthesis where possible as I think that it is probably the more commonly used construct.</p><p>There are many arithmetic operators available. Here's a table showing a few common ones and how they are used:</p><table><thead><tr><th>Operator</th><th>Meaning</th><th>Example</th></tr></thead><tbody><tr><td><code>+</code></td><td>Addition</td><td><code>echo $((3+4)) # prints 7</code></td></tr><tr><td><code>-</code></td><td>Subtraction</td><td><code>echo $((4-2)) # prints 2</code></td></tr><tr><td><code>*</code></td><td>Multiplication</td><td><code>echo $((4*2)) # prints 8</code></td></tr><tr><td><code>/</code></td><td>Division</td><td><code>echo $((4/2)) # prints 2</code></td></tr><tr><td><code>**</code></td><td>Exponent</td><td><code>echo $((4**3)) # prints 64</code></td></tr><tr><td><code>%</code></td><td>Modulus</td><td><code>echo $((7%3)) # prints 1</code></td></tr><tr><td><code>++i</code></td><td>Prefix Increment</td><td><code>i=1; echo $((++i)) # prints 1, i is set to 2</code></td></tr><tr><td><code>i++</code></td><td>Postfix Increment</td><td><code>i=1; echo $((i++)) # prints 2, i is set to 2</code></td></tr><tr><td><code>--i</code></td><td>Prefix Decrement</td><td><code>i=3; echo $((--i)) # prints 3, i is set to 2</code></td></tr><tr><td><code>i--</code></td><td>Postfix Decrement</td><td><code>i=3; echo $((i--)) # prints 2, i is set to 2</code></td></tr><tr><td><code>i+=n</code></td><td>Increment</td><td><code>i=3; echo $((i+=3)) # prints 6, i is set to 6</code></td></tr><tr><td><code>i-=n</code></td><td>Decrement</td><td><code>i=3; echo $((i-=2)) # prints 1, i is set to 1</code></td></tr></tbody></table><p>If you want to find the complete set of arithmetic operators available or find more details on how arithmetic works in the shell, use <code>man bash</code> and search for the text <code>ARITHMETIC\ EVALUATION</code> (the backslash is needed to escape the space between the words when searching in the manual).</p><p>The script below shows how you can use a combination of operators to convert a value in degrees Celsius to Fahrenheit:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>read -p <span style=color:#e6db74>&#34;Enter a value in Celsius: &#34;</span> celcius
fahrenheit<span style=color:#f92672>=</span><span style=color:#66d9ef>$((</span> <span style=color:#f92672>(</span>celcius <span style=color:#f92672>*</span> <span style=color:#ae81ff>9</span><span style=color:#f92672>/</span><span style=color:#ae81ff>5</span><span style=color:#f92672>)</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>32</span> <span style=color:#66d9ef>))</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>celcius<span style=color:#e6db74>}</span><span style=color:#e6db74> degrees Celsius is </span><span style=color:#e6db74>${</span>fahrenheit<span style=color:#e6db74>}</span><span style=color:#e6db74> degrees Fahrenheit</span><span style=color:#e6db74>&#34;</span>
</code></pre></div><p>Note that you can use brackets in your arithmetic expressions to be explicit about the order in which the calculations should be performed. The order that is used if you don't use brackets is detailed in the manual page, but in general using brackets will make things clearer to the reader.</p><h1 id=updating-the-common-command>Updating the &lsquo;Common&rsquo; Command</h1><p>With our new understanding of variables, we can improve the &lsquo;common&rsquo; command we created in the previous chapter by extracting certain values into variables so that they can be more easily changed.</p><p>Let's look at our original &lsquo;common&rsquo; command:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Write the title of our command.</span>
echo <span style=color:#e6db74>&#34;common commands:&#34;</span>

<span style=color:#75715e># Show the most commonly used commands.</span>
tail ~/.bash_history -n <span style=color:#ae81ff>1000</span> | sort | uniq -c | sed <span style=color:#e6db74>&#39;s/^ *//&#39;</span> | sort -n | tail -n <span style=color:#ae81ff>10</span>
</code></pre></div><p>We could improve on this by making the number of lines of text in the history we search through and the number of commands to show variables, so that they can be more easily changed.</p><p>Create a copy of the <code>common.v1.sh</code> script and call it <code>common.v2.sh</code> and update it like so:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Write the title of our command.</span>
echo <span style=color:#e6db74>&#34;common commands:&#34;</span>

<span style=color:#75715e># The following variables control how the command runs.</span>
history_lines<span style=color:#f92672>=</span><span style=color:#ae81ff>1000</span> <span style=color:#75715e># The number of lines of history to search through</span>
command_count<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span>   <span style=color:#75715e># The number of common commands to show.</span>

<span style=color:#75715e># Show the most commonly used commands.</span>
tail ~/.bash_history -n <span style=color:#e6db74>${</span>history_lines<span style=color:#e6db74>}</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    | sort <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    | uniq -c <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    | sed <span style=color:#e6db74>&#39;s/^ *//&#39;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    | sort -n -r <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    | head -n <span style=color:#e6db74>${</span>command_count<span style=color:#e6db74>}</span>
</code></pre></div><p>We have replaced two &lsquo;hard-coded&rsquo; values (the number of lines of history to search and the number of common commands to show) with variables, which are now easier to find and change. We have also split the command into multiple lines so that it is easier to read (as the line is quite long otherwise).</p><p>If you want to replace the installed <code>common</code> command with this new one, update the symlink in your <em>/usr/local/bin</em> folder:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>ln -sf $HOME/effective-shell/scripts/common.v2.sh /usr/local/bin/common
</code></pre></div><p>Note that in this command we use the <code>-f</code> flag to force the creation of the symlink even if one already exists in the given location.</p><h1 id=summary>Summary</h1><p>In this chapter we looked at how environment variables work and how we can use our own variables. We saw how to read input from the user and how to perform arithmetic operations.</p><p>We've seen a few new constructs in this chapter that will appear again and again, these are summarised below so that you can recognise them!</p><ul><li><code>${variable}</code> gets the value of <code>variable</code> - the braces surround the variable name</li><li><code>$(echo "$PAGER")</code> runs the <code>echo</code> command in a subshell - the single parenthesis indicates we are running a subshell</li><li><code>$(($left + $right))</code> adds the values in the variables <code>left</code> and <code>right</code> - the double parenthesis indicate that we are performing arithmetic</li></ul><p>In the next chapter we are going to see how to perform <em>logic</em> in scripts - running commands only when certain conditions are met. This is an incredibly powerful technique and will let you create much more sophisticated scripts!</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>There is also a very good discussion on the differences in quoting options in the following Stack Overflow thread: <a href=https://stackoverflow.com/questions/10067266/when-to-wrap-quotes-around-a-shell-variable>https://stackoverflow.com/questions/10067266/when-to-wrap-quotes-around-a-shell-variable</a> <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></article><div class="book-footer justify-between"><div><a class="flex align-center" href=https://github.com/dwmkerr/effective-shell/commit/1bca26c4aff39ab3f7d3d6ebf304980b9de95e40 title="Last modified by github-actions[bot] | Jun 10, 2021" target=_blank><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>Jun 10, 2021</span></a></div><div><a class="flex align-center" href=https://github.com/dwmkerr/effective-shell/edit/master/website/content/docs/part-4-shell-scripting/variables-reading-input-and-mathematics/_index.md target=_blank><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"effective-shell"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><p>Copyright &copy; <script>document.write(new Date().getFullYear())</script>, Dave Kerr</p></div><aside class="book-toc levels-3 fixed"><nav id=TableOfContents><ul><li><a href=#chapter-19---variables-reading-input-and-mathematics>Chapter 19 - Variables, Reading Input, and Mathematics</a></li><li><a href=#variables>Variables</a><ul><li><a href=#setting-variables>Setting Variables</a></li><li><a href=#storing-the-output-of-a-command-into-a-variable>Storing the Output of a Command into a Variable</a></li><li><a href=#being-explicit-with-variable-names>Being Explicit with Variable Names</a></li></ul></li><li><a href=#arrays>Arrays</a><ul><li><a href=#associative-arrays>Associative Arrays</a></li></ul></li><li><a href=#quoting-variables-and-values>Quoting Variables and Values</a><ul><li><a href=#single-quotes---literal-values>Single Quotes - Literal Values</a></li><li><a href=#single-quotes---ansi-c-quoting>Single Quotes - ANSI C Quoting</a></li><li><a href=#double-quotes---parameter-expansion>Double Quotes - Parameter Expansion</a></li><li><a href=#no-quotes---shell-expansion>No Quotes - Shell Expansion</a></li><li><a href=#quoting-tips>Quoting Tips</a></li></ul></li><li><a href=#shell-parameter-expansion>Shell Parameter Expansion</a></li><li><a href=#the-read-command>The Read Command</a><ul><li><ul><li><a href=#reading-into-a-variable>Reading into a Variable</a></li><li><a href=#prompting-for-input>Prompting for Input</a></li><li><a href=#reading-secrets>Reading Secrets</a></li><li><a href=#limiting-the-input>Limiting the Input</a></li></ul></li></ul></li><li><a href=#mathematics>Mathematics</a></li><li><a href=#updating-the-common-command>Updating the &lsquo;Common&rsquo; Command</a></li><li><a href=#summary>Summary</a></li></ul></nav></aside></main></body></html>