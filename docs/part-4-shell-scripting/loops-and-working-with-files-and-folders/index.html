<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Loops and working with Files and Folders"><meta property="og:title" content="Loops and working with Files and Folders"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://effective-shell.com/docs/part-4-shell-scripting/loops-and-working-with-files-and-folders/"><title>Loops and working with Files and Folders | Effective Shell</title><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.f8520695a602b532b093067e25561bfe6fa10ca8c25171b97142acf58fa8f13c.css integrity="sha256-+FIGlaYCtTKwkwZ+JVYb/m+hDKjCUXG5cUKs9Y+o8Tw="><script defer src=/en.search.min.901d4b22032222a6f8db08efa32b2ce89f2b7affb9b504a133dbe52ece751a89.js integrity="sha256-kB1LIgMiIqb42wjvoyss6J8rev+5tQShM9vlLs51Gok="></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-155335600-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><link rel=alternate type=application/rss+xml href=https://effective-shell.com/docs/part-4-shell-scripting/loops-and-working-with-files-and-folders/index.xml title="Effective Shell"><script id=mcjs>!function(c,h,i,m,p){m=c.createElement(h),p=c.getElementsByTagName(h)[0],m.async=1,m.src=i,p.parentNode.insertBefore(m,p)}(document,"script","https://chimpstatic.com/mcjs-connected/js/users/eac1a082b6db34d40aaff2caf/a2aaca5a8358c2e12d3f43f1a.js");</script></head><body><input type=checkbox class=hidden id=menu-control><main class="flex container"><aside class="book-menu fixed"><nav><h2 class=book-brand><a href=https://effective-shell.com/><span>Effective Shell</span></a></h2><h2 class=book-subtitle><span>By Dave Kerr</span></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/docs/introduction/><strong>Introduction</strong></a></li><li><a href=/docs/getting-started/><strong>Getting Started</strong></a></li><li><a href=/docs/part-1-transitioning-to-the-shell/><strong>Part 1 - Transitioning to the Shell</strong></a><ul><li><a href=/docs/part-1-transitioning-to-the-shell/navigating-your-system/>Navigating Your System</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/managing-your-files/>Managing Your Files</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/clipboard-gymnastics/>Clipboard Gymnastics</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/getting-help/>Getting Help</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/the-renaissance-of-the-shell/>The Renaissance of the Shell</a></li></ul></li><li><a href=/docs/part-2-core-skills/><strong>Part 2 - Core Skills</strong></a><ul><li><a href=/docs/part-2-core-skills/thinking-in-pipelines/>Thinking in Pipelines</a></li><li><a href=/docs/part-2-core-skills/fly-on-the-command-line/>Fly on the Command Line</a></li><li><a href=/docs/part-2-core-skills/job-control/>Job Control</a></li><li><a href=/docs/part-2-core-skills/understanding-commands/>Understanding Commands</a></li><li><a href=/docs/part-2-core-skills/finding-files/>Finding Files</a></li><li><a href=/docs/part-2-core-skills/what-is-a-shell/>What is a Shell?</a></li></ul></li><li><a href=/docs/part-3-manipulating-text/><strong>Part 3 - Manipulating Text</strong></a><ul><li><a href=/docs/part-3-manipulating-text/regex-essentials/>Regex Essentials</a></li><li><a href=/docs/part-3-manipulating-text/get-to-grips-with-grep/>Get to Grips with Grep</a></li><li><a href=/docs/part-3-manipulating-text/slice-and-dice-text/>Slice and Dice Text</a></li><li><a href=/docs/part-3-manipulating-text/advanced-text-manipulation/>Advanced Text Manipulation with Sed</a></li><li><a href=/docs/part-3-manipulating-text/build-commands-on-the-fly/>Build Commands on the Fly with Xargs</a></li></ul></li><li><a href=/docs/part-4-shell-scripting/><strong>Part 4 - Shell Scripting</strong></a><ul><li><a href=/docs/part-4-shell-scripting/shell-script-essentials/>Shell Script Essentials</a></li><li><a href=/docs/part-4-shell-scripting/variables-reading-input-and-mathematics/>Variables, Reading Input, and Mathematics</a></li><li><a href=/docs/part-4-shell-scripting/mastering-conditional-logic/>Mastering Conditional Logic</a></li><li><a href=/docs/part-4-shell-scripting/loops-and-working-with-files-and-folders/ class=active>Loops and working with Files and Folders</a></li><li><a href=/docs/part-4-shell-scripting/functions-parameters-and-error-handling/>Functions, Parameters and Error Handling</a></li><li><a href=/docs/part-4-shell-scripting/useful-patterns-for-shell-scripts/>Useful Patterns for Shell Scripts</a></li></ul></li><li><a href=/docs/part-5-building-your-toolkit/><strong>Part 5 - Building Your Toolkit</strong></a><ul><li><a href=/docs/part-5-building-your-toolkit/configuring-the-shell/>Configuring the Shell</a></li><li><a href=/docs/part-5-building-your-toolkit/customising-your-command-prompt/>Customising Your Command Prompt</a></li><li><a href=/docs/part-5-building-your-toolkit/managing-your-dotfiles/>Managing Your Dotfiles</a></li><li><a href=/docs/part-5-building-your-toolkit/controlling-changes-with-git/>Controlling Changes with Git</a></li><li><a href=/docs/part-5-building-your-toolkit/managing-remote-git-repositories/>Managing Remote Git Repositories and Sharing Your Dotfiles</a></li></ul></li><li><a href=/docs/part-6-advanced-techniques/><strong>Part 6 - Advanced Techniques</strong></a><ul><li><a href=/docs/part-6-advanced-techniques/understanding-shell-expansion/>Understanding Shell Expansion</a></li></ul></li><li><a href=/docs/work-in-progress/><strong>Work in Progress</strong></a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class="flex align-center justify-between book-header"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Loops and working with Files and Folders</strong></header><article class=markdown><h1 id=chapter-21---loops-and-working-with-files-and-folders>Chapter 21 - Loops and working with Files and Folders</h1><p>Loops allow us to perform a set of operations over multiple items, such as a set of files or folders or the results of a command. In this chapter we'll look at loops and how to operate on many files and folders.</p><h1 id=the-for-loop---index--->The For Loop</h1><p>We can use the <em>for loop</em> to run a set of commands for each item in a list.</p><p>The <em>for loop</em> has the following structure:</p><pre><code>for &lt;name&gt; in &lt;words&gt;
do
    &lt;conditional-command 1&gt;
    &lt;conditional-command 2&gt;
    &lt;conditional-command n&gt;
done
</code></pre><p>The <em>for loop</em> executes a sequence of commands for every item in a list. In the documentation you will see that this list is called &lsquo;words&rsquo;. There's a technical (and complex) reason for this that we'll discuss in the end of the chapter.</p><p>Let's see how the <em>for loop</em> works by showing a simple example. We will loop through every item in a folder and print its name to the screen:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#66d9ef>for</span> item in ~/effective-shell/*
<span style=color:#66d9ef>do</span>
    echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Found: </span>$item<span style=color:#e6db74>&#34;</span>
<span style=color:#66d9ef>done</span>
</code></pre></div><p>As long as you have the <em>effective-shell</em> folder in your home directory, you will see output that looks like this:</p><pre><code>Found: /home/dwmkerr/effective-shell/data
Found: /home/dwmkerr/effective-shell/docs
Found: /home/dwmkerr/effective-shell/logs
Found: /home/dwmkerr/effective-shell/pictures
Found: /home/dwmkerr/effective-shell/programs
Found: /home/dwmkerr/effective-shell/quotes
Found: /home/dwmkerr/effective-shell/scripts
Found: /home/dwmkerr/effective-shell/templates
Found: /home/dwmkerr/effective-shell/text
Found: /home/dwmkerr/effective-shell/websites
</code></pre><p>Notice how the shell is smart enough to <em>expand</em> the wildcard expression that we have included in the <em>for loop</em>. In just the same way we can use wildcards in commands such as <code>ls</code> or <code>cp</code> or <code>mv</code>, we can also use them in for loops - or in fact any statement<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>!</p><p>You will also see that when we specify the name of the variable to use in the loop (which in this example was <em>item</em>) we don't need to use a dollar symbol. Remember - when we are <em>setting</em> a variable, we don't use a dollar symbol, we only use the dollar symbol when we want to get the value of the variable.</p><p>The <em>for loop</em> is closed with the <code>done</code> keyword. Here we can also see an inconsistency with the shell syntax - for the <code>if</code> statement, the statement is closed with <code>if</code> backwards (<code>fi</code>). But the <code>for</code> loop is closed with <code>done</code>. The shell is an old platform and there are some oddities like that that you might not see in more modern programming languages.</p><h2 id=for-loops---arrays>For Loops - Arrays</h2><p>In <a href=/docs/part-4-shell-scripting/variables-reading-input-and-mathematics/>Chapter 19 - Variables, Reading Input, and Mathematics</a> we saw how to create arrays. We can easily loop through the items in an array with a for loop. Here's an example:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>days<span style=color:#f92672>=</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Monday&#34;</span> <span style=color:#e6db74>&#34;Tuesday&#34;</span> <span style=color:#e6db74>&#34;Wednesday&#34;</span> <span style=color:#e6db74>&#34;Thursday&#34;</span> <span style=color:#e6db74>&#34;Friday&#34;</span> <span style=color:#e6db74>&#34;Saturday&#34;</span> <span style=color:#e6db74>&#34;Sunday&#34;</span><span style=color:#f92672>)</span>
<span style=color:#66d9ef>for</span> day in <span style=color:#e6db74>${</span>days[@]<span style=color:#e6db74>}</span>
<span style=color:#66d9ef>do</span>
    echo -n <span style=color:#e6db74>&#34;</span>$day<span style=color:#e6db74>, </span><span style=color:#e6db74>&#34;</span>
<span style=color:#66d9ef>done</span>
echo <span style=color:#e6db74>&#34;happy days!&#34;</span>
</code></pre></div><p>If we run this script we'll see the following output:</p><pre><code>Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, happy days!
</code></pre><p>It's important to remember that we want to go through every item in the array, so we have to use the <code>${days[@]}</code> syntax. This is the syntax that means &lsquo;all of the members of the array&rsquo;.</p><p>The <code>-n</code> (<em>don't output a trailing newline</em>) flag of the <code>echo</code> command is used inside the for loop so that we don't write each day on its own line.</p><h2 id=for-loops---words>For Loops - Words</h2><p>The <em>for loop</em> documentation names the input to the loop as &lsquo;words&rsquo;. We can see this by running <code>help for</code>:</p><pre><code>$ help for
for: for NAME [in WORDS ... ] ; do COMMANDS; done
    Execute commands for each member in a list.
...
</code></pre><p>The reason that the items are called &lsquo;words&rsquo; is that the shell splits up the input into a set of words and loops though each - this can be a real surprise if you come from a programming background.</p><p>Let's see what this means with an example:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>sentence<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;What can the harvest hope for, if not for the care of the Reaper Man?&#34;</span>
<span style=color:#66d9ef>for</span> word in $sentence
<span style=color:#66d9ef>do</span>
    echo <span style=color:#e6db74>&#34;</span>$word<span style=color:#e6db74>&#34;</span>
<span style=color:#66d9ef>done</span>
</code></pre></div><p>The output of this will be:</p><pre><code>What
can
the
harvest
hope
for,
if
not
for
the
care
of
the
reaper
man?
</code></pre><p><strong>Z-Shell</strong> - if you are using Z-Shell then the sentence will <em>not</em> be split up into words. There is an appendix at the end of the chapter that describes the differences between Z-Shell and Bash-like shells (which tend to be closer to the Posix standard).</p><p>The <em>for loop</em> has split up the sentence variable into a set of words. This might seem illogical, as the shell is making quite a big assumption (that the operator <em>wants</em> their input split up), but we'll see with a few examples how this is often what is needed.</p><p>This is not how most programming languages would work, so why does the shell do this?</p><p>The reason is that the shell is a <em>text based environment</em> and the designers have taken this into account. Most of the time when we are running shell commands in a terminal we are running commands that <em>simply output text</em>. If we want to be able to use the output of these commands in constructs like loops, the shell has to decide how to split the output up.</p><p>For example, let's see how the <code>ls</code> command would write its output:</p><pre><code>$ ls ~/effective-shell
data  docs  logs  pictures  programs  quotes  scripts  templates  text  websites
</code></pre><p>The output that the <code>ls</code> program has written is plain text. It is not an array, it is just a set of files separated by spaces. What would we expect the shell to do if we ran the following command?</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>files<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>ls ~/effective-shell<span style=color:#66d9ef>)</span>
<span style=color:#66d9ef>for</span> file in $files
<span style=color:#66d9ef>do</span>
    echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Found: </span>$file<span style=color:#e6db74>&#34;</span>
<span style=color:#66d9ef>done</span>
</code></pre></div><p>The output is:</p><pre><code>Found: data
Found: docs
Found: logs
Found: pictures
Found: programs
Found: quotes
Found: scripts
Found: templates
Found: text
Found: websites
</code></pre><p>Here we see why the shell splits up words in a sentence. It is making a best effort with plain text - trying to split plain text up into sensible &lsquo;chunks&rsquo;.</p><p>When we operate in a shell for day to day work we don't have to use the more specific syntax that would be used in a programming language - the shell has more of an emphasis on terseness of statements and the ability to quickly work with files. It is not designed as a general purpose programming tool, so it makes assumptions like this.</p><p>We go into detail in word splitting nearer the end of this chapter.</p><h2 id=for-loops---files-with-wildcards>For Loops - Files with Wildcards</h2><p>One of the most common scenarios for using a <em>for loop</em> is to loop through a set of files or folders.</p><p>The most simple way to do this is to use a simple wildcard pattern in the <em>for loop</em> statement, like so:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#66d9ef>for</span> script in ~/effective-shell/scripts/*.sh
<span style=color:#66d9ef>do</span>
    echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Found script: </span>$script<span style=color:#e6db74>&#34;</span>
<span style=color:#66d9ef>done</span>
</code></pre></div><p>We will see output that looks like this:</p><pre><code>Found script: /home/dwmkerr/effective-shell/scripts/common.mac.sh
Found script: /home/dwmkerr/effective-shell/scripts/common.sh
Found script: /home/dwmkerr/effective-shell/scripts/common.v1.sh
Found script: /home/dwmkerr/effective-shell/scripts/common.v2.sh
Found script: /home/dwmkerr/effective-shell/scripts/common.v3.sh
Found script: /home/dwmkerr/effective-shell/scripts/show-info.sh
</code></pre><p>We have to be careful with scripts like this - there is a bug.</p><p>By default, if the shell doesn't find anything with a wildcard pattern <em>it does not expand it</em>. This is very confusing - so let's see an example.</p><p>Take a look at the sample below - what would you expect it to show?</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#66d9ef>for</span> script in ~/bad-shell/scripts/*.sh
<span style=color:#66d9ef>do</span>
    echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Found: </span>$script<span style=color:#e6db74>&#34;</span>
<span style=color:#66d9ef>done</span>
</code></pre></div><p>You might think the logical result is that nothing is printed - there is not <em>bad shell</em> folder, so the pattern should not find any files. But instead, we see the following output:</p><pre><code>Found: ~/bad-shell/scripts/*.sh
</code></pre><p>By default, if a shell &lsquo;glob&rsquo; (a pattern that includes a wildcard) does not match any files, the shell simply leaves the pattern as-is.</p><p>There are two ways we can deal with this problem. The first way is to enable the &lsquo;nullglob&rsquo; (<em>return null for unmatched globs</em>) option:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>shopt -s nullglob
<span style=color:#66d9ef>for</span> script in ~/bad-shell/scripts/*.sh
<span style=color:#66d9ef>do</span>
    echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Found: </span>$script<span style=color:#e6db74>&#34;</span>
<span style=color:#66d9ef>done</span>
</code></pre></div><p>The <code>shopt</code> (<em>set and unset shell option</em>) command is used to configure shell options. We will be looking at shell options in detail in Part 5. The &lsquo;nullglob&rsquo; option changes the shell behaviour so that if a wildcard pattern does not match any results, it is set to null string<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><p>The second way we can deal with this problem is to just use a <code>test</code> command. I think that this is actually far more readable than the <code>shopt</code> solution. Here's how it would look:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#66d9ef>for</span> script in ~/bad-shell/scripts/*.sh
<span style=color:#66d9ef>do</span>
    <span style=color:#75715e># If the file / folder doesn&#39;t exist, skip it.</span>
    <span style=color:#66d9ef>if</span> ! <span style=color:#f92672>[</span> -e <span style=color:#e6db74>&#34;</span>$script<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>continue</span>; <span style=color:#66d9ef>fi</span>
    echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Found: </span>$script<span style=color:#e6db74>&#34;</span>
<span style=color:#66d9ef>done</span>
</code></pre></div><p>Here we use the <code>-e</code> (<em>exists</em>) operator in a <code>test</code> command to check whether the file exists. If it does <em>not</em> exist, we run the <code>continue</code> statement.</p><p>The <code>continue</code> statement &lsquo;skips&rsquo; the current item in the loop and moves to the next one. We will see it a little more later on.</p><h2 id=for-loops---files-with-find>For Loops - Files with Find</h2><p>If the files that you are trying to loop through are too complex to match with a shell pattern, you can use the <code>find</code> command to search for files, then loop through the results.</p><p>If you are not familiar with the <code>find</code> command, check <a href=/docs/part-2-core-skills/finding-files/>Chapter 11 - Finding Files</a>.</p><p>Let's use the <code>find</code> command to run a loop that prints every symlink in the user's home directory. But before we run the loop we'll create a symlink with a space - this will cause some interesting output in our script:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Create a symlink to &#39;effective-shell&#39; that has a space in it...</span>
ln -s ~/effective shell ~/effective<span style=color:#ae81ff>\ </span>shell

<span style=color:#75715e># Find all symlinks and print each one.</span>
links<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>find ~ -type l<span style=color:#66d9ef>)</span>
<span style=color:#66d9ef>for</span> link in $links
<span style=color:#66d9ef>do</span>
    echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Found Link: </span>$link<span style=color:#e6db74>&#34;</span>
<span style=color:#66d9ef>done</span>
</code></pre></div><p>You will see a few different links shown when you run this script, depending on how your system is set up. But you will also certainly see the results below:</p><pre><code>...
Found Link: /home/dwmkerr/effective-shell/effective
Found Link: shell
...
</code></pre><p>This is clearly a problem - the shell has taken the path that has a space - <em>/home/dwmkerr/effective-shell/effective shell</em> and performed <em>word splitting</em> and turned it into two separate items.</p><p>This is a persistent headache for anyone who needs to build shell scripts. There are a large number of ways to solve this problem, and none of them are particularly intuitive. I am going to demonstrate one common solution, which is not perfect but should cover most cases. I'll then suggest a better work-around.</p><p>The solution that we will use is to temporarily change the values that the shell uses to split text into words. We will set it to <em>only</em> split on newlines. The <code>find</code> command puts each file it finds on its own line. This means we will <em>not</em> split up files with spaces or other whitespace in the name:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Save the current value of IFS - so we can restore it later. Split on newlines.</span>
old_ifs<span style=color:#f92672>=</span>$IFS
IFS<span style=color:#f92672>=</span><span style=color:#e6db74>$&#39;\n&#39;</span>

<span style=color:#75715e># Find all symlinks and print each one.</span>
links<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>find ~ -type l<span style=color:#66d9ef>)</span>
<span style=color:#66d9ef>for</span> link in $links
<span style=color:#66d9ef>do</span>
    echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Found Link: </span>$link<span style=color:#e6db74>&#34;</span>
<span style=color:#66d9ef>done</span>

<span style=color:#75715e># Restore the original value of IFS.</span>
IFS<span style=color:#f92672>=</span>$old_ifs
</code></pre></div><p>If you run this command now you will see the correct output:</p><pre><code>...
Found Link: /home/dwmkerr/effective-shell/effective shell
...
</code></pre><p>This will cover you in most cases. However, this method is not ideal for a number of reasons:</p><ol><li>It is quite verbose - we have to store the current value of <code>$IFS</code> and then reset it later</li><li>It is not quite foolproof - filenames on some systems can have a newline character and this script would fail for those files</li><li>We have to use the complex looking &lsquo;ANSI C Quoting&rsquo; syntax to set <code>$IFS</code> to a newline<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup></li><li>If the reader doesn't know what <code>$IFS</code> is then the entire script will be difficult to follow</li></ol><p>The <code>$IFS</code> variable can be complex to work with and discussed at the end of the chapter.</p><p>I believe that in this case it is probably best to not use a shell script. There is <em>no</em> solution that is particularly clean or simple. In this case I think you might be better off using a programming language. Check the <a href=/docs/work-in-progress/>How to avoid scripting!</a> Chapter for more details on this.</p><h2 id=for-loops---c-style-loops>For Loops - C Style Loops</h2><p>If you have used programming languages like C, C++, Python, Java and others, you may well be familiar with the &lsquo;C style loop&rsquo; structure that is shown below:</p><pre><code>for (( expression1 ; expression2 ; expression3 ))
do
    &lt;command 1&gt;
    &lt;command 2&gt;
    &lt;command n&gt;
done
</code></pre><p>This loop structure uses three arithmetic expressions to run the loop. The first is in &lsquo;initialise&rsquo; expression, this is typically used to setup the initial state of the loop. The second is the &lsquo;conditional&rsquo; expression, this is used to check whether the loop is complex. The third is the &lsquo;iterate&rsquo; expression, this is evaluated after the loop commands are completed.</p><p>Here's how we can use a C style for loop to iterate through five numbers:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#f92672>(</span> i <span style=color:#f92672>=</span> 1; i &lt;<span style=color:#f92672>=</span> 5; i++ <span style=color:#f92672>)</span><span style=color:#f92672>)</span>
<span style=color:#66d9ef>do</span>
    echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Loop </span><span style=color:#e6db74>${</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
<span style=color:#66d9ef>done</span>
</code></pre></div><p>The output of this script is:</p><pre><code>Loop 1
Loop 2
Loop 3
Loop 4
Loop 5
</code></pre><h2 id=for-loops---looping-over-sequences>For Loops - Looping over Sequences</h2><p>Another common way to use a for loop is with <em>brace expansion</em>. Brace expansion we have already seen a number of times so far - we can use it to generate a sequence of values. Here is how we might create three files using brace expansion:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>touch <span style=color:#f92672>{</span>coffee,tea,milkshake<span style=color:#f92672>}</span>-menu.txt
</code></pre></div><p>This will create three files:</p><pre><code>$ ls -1 *-menu.txt
coffee-menu.txt
milkshake-menu.txt
tea-menu.txt
</code></pre><p>Brace expansion can be use in for loops, and brace expansion can be used to create sequences. For example, the loop below could be used as a way to loop through the numbers from one to ten:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#66d9ef>for</span> i in <span style=color:#f92672>{</span>1..10<span style=color:#f92672>}</span>
<span style=color:#66d9ef>do</span>
    echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Loop </span><span style=color:#e6db74>${</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
<span style=color:#66d9ef>done</span>
</code></pre></div><p>Brace expansion can be used to loop through a sequence of values or a range of numbers. You can even specify the &lsquo;increment&rsquo; used in a sequence. For example, this loop iterates through a sequence of numbers adding five each time:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#66d9ef>for</span> i in <span style=color:#f92672>{</span>0..25..5<span style=color:#f92672>}</span>
<span style=color:#66d9ef>do</span>
    echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Loop </span><span style=color:#e6db74>${</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
<span style=color:#66d9ef>done</span>
</code></pre></div><p>The output of this loop would be:</p><pre><code>Loop 0
Loop 5
Loop 10
Loop 15
Loop 20
Loop 25
</code></pre><h1 id=the-while-loop>The While Loop</h1><p>The <em>while loop</em> is a loop that executes commands until a certain condition is met.</p><p>The <em>while loop</em> has the following structure:</p><pre><code>while &lt;test-commands&gt;
do
    &lt;conditional-command 1&gt;
    &lt;conditional-command 2&gt;
    &lt;conditional-command n&gt;
done
</code></pre><p>As long as the <em>test commands</em> return success, the loop will run the <em>conditional commands</em>. After the <em>conditional commands</em> have been run, the loop goes &lsquo;back to the start&rsquo; and evaluates the test commands again.</p><p>Here's an example of how a while loop can be used to generate a list of random numbers:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Create an empty array of random numbers.</span>
random_numbers<span style=color:#f92672>=</span><span style=color:#f92672>(</span><span style=color:#f92672>)</span>

<span style=color:#75715e># As long as the length of the array is less than five, continue to loop.</span>
<span style=color:#66d9ef>while</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>${#</span>random_numbers[@]<span style=color:#e6db74>}</span> -lt <span style=color:#ae81ff>5</span> <span style=color:#f92672>]</span>
<span style=color:#66d9ef>do</span>
    <span style=color:#75715e># Get a random number, ask the user if they want to add it to the array.</span>
    random_number<span style=color:#f92672>=</span>$RANDOM
    read -p <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Add </span>$random_number<span style=color:#e6db74> to the list? (y/n): </span><span style=color:#e6db74>&#34;</span> choice
    
    <span style=color:#75715e># If the user chose &#39;y&#39; add the random number to the array.</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;</span>$choice<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;y&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span> random_numbers<span style=color:#f92672>+=</span><span style=color:#f92672>(</span>$random_number<span style=color:#f92672>)</span>; <span style=color:#66d9ef>fi</span>
<span style=color:#66d9ef>done</span>

<span style=color:#75715e># Show the contents of the array.</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Random Numbers: </span><span style=color:#e6db74>${</span>random_numbers[@]<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</code></pre></div><p>When you run this script, you can choose to add a number to the list by typing &lsquo;y&rsquo; - once there are five items in the list the while loop condition fails and the loop ends:</p><pre><code>Add 14718 to the list? (y/n): y
Add 2646 to the list? (y/n): n
Add 11898 to the list? (y/n): y
Add 31506 to the list? (y/n): y
Add 32436 to the list? (y/n): y
Add 6803 to the list? (y/n): n
Add 25811 to the list? (y/n): y
Random Numbers: 14718 11898 31506 32436 25811
</code></pre><p>The <code>$RANDOM</code> variable is a built-in variable in the shell that returns a random number.</p><p>You would typically use a while loop when you don't know how many iterations you will perform and you need to re-evaluate at each iteration whether you should continue to loop.</p><h2 id=while-loops---looping-through-the-lines-in-a-file>While Loops - Looping through the lines in a file</h2><p>You can use a while loop to iterate through each line in a file, without having to load the entire file into memory.</p><p>Here's an example of how to iterate through the lines of a file:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#66d9ef>while</span> read line; <span style=color:#66d9ef>do</span>
    echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Read: </span>$line<span style=color:#e6db74>&#34;</span>
<span style=color:#66d9ef>done</span> &lt; ~/effective-shell/data/top100.csv
</code></pre></div><p>The output will look like this:</p><pre><code>Read: &quot;Rank&quot;,&quot;Rating&quot;,&quot;Title&quot;,&quot;Reviews&quot;
Read: &quot;1&quot;,&quot;97&quot;,&quot;Black Panther (2018)&quot;,&quot;515&quot;
Read: &quot;2&quot;,&quot;94&quot;,&quot;Avengers: Endgame (2019)&quot;,&quot;531&quot;
...
</code></pre><p>This uses shell redirection to redirect the contents of the <em>~/effective-shell/data/top100.csv</em> file into the <code>read</code> command in the while loop. The <code>read</code> command will read the file, line by line, until it finds the final line.</p><p>This script has some issues:</p><ul><li>If the last line is does not end with a newline, then it is not read</li><li>Backlashes will be treated as escape sequences and lead to broken output</li><li>Leading whitespace will be removed</li></ul><p>It is possible to avoid these issues, but the resulting script is a lot harder to read:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#66d9ef>while</span> IFS<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span> read -r line <span style=color:#f92672>||</span> <span style=color:#f92672>[</span> -n <span style=color:#e6db74>&#34;</span>$line<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>do</span>
    echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Read: </span>$line<span style=color:#e6db74>&#34;</span>
<span style=color:#66d9ef>done</span> &lt; ~/effective-shell/data/top100.csv
</code></pre></div><p>In this case we've had to use some complex tricks to avoid each issue:</p><ul><li>The <code>|| [ -n "$line"]</code> test ensures that the loop iterates as long as the line read is not zero-length, ensuring we read the last line even if it doesn't have a newline</li><li>The <code>-r</code> (<em>do not escape</em>) option for <code>read</code> ensures that backlashes are not interpreted as escape sequences</li><li>The <code>IFS=""</code> temporarily disables <em>any</em> word splitting in the loop, meaning that we do not lose leading whitespace</li></ul><p>However this <em>still</em> has issues - if commands in the loop read from standard input then the loop will still have errors. For this reason, I would again suggest you follow the advice in the <a href=/docs/work-in-progress/>How to avoid scripting!</a> Chapter to see better ways to read files!</p><p>Even though I would recommend using a programming language to read the lines of a file, I have kept this example here because it is something you are likely to come across if you see scripts written by others. And for simple scenarios, where you are fairly sure of structure of a file, it might be useful. But this is definitely a case where you should consider using a programming language if you want to create more maintainable solutions to problems!</p><h2 id=while-loops---the-infinite-loop>While Loops - The Infinite Loop</h2><p>There are times that you may want to loop forever. For example you might be writing a script that reads an option from the user, processes it, and then starts again.</p><p>Here's an example of an infinite loop - we use the <code>true</code> command, which always returns success:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#66d9ef>while</span> true
<span style=color:#66d9ef>do</span>
    echo <span style=color:#e6db74>&#34;1) Move forwards&#34;</span>
    echo <span style=color:#e6db74>&#34;2) Move backwards&#34;</span>
    echo <span style=color:#e6db74>&#34;3) Turn Left&#34;</span>
    echo <span style=color:#e6db74>&#34;4) Turn Right&#34;</span>
    echo <span style=color:#e6db74>&#34;5) Explore&#34;</span>
    echo <span style=color:#e6db74>&#34;0) Quit&#34;</span>
    
    read -p <span style=color:#e6db74>&#34;What will you do: &#34;</span> choice
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> $choice -eq <span style=color:#ae81ff>0</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
        exit
    <span style=color:#66d9ef>fi</span>
    <span style=color:#75715e># The rest of the game logic would go here!</span>
    <span style=color:#75715e># ...</span>
<span style=color:#66d9ef>done</span>
</code></pre></div><p>This example shows a common pattern for an infinite loop - offering a menu of options which the user can call repeatedly until they decide to quit.</p><h1 id=the-until-loop>The Until Loop</h1><p>The <em>until loop</em> operates just like the while loop, except that it runs <em>until</em> the test commands return success.</p><p>The structure of the <em>until loop</em> is just like the while loop:</p><pre><code>until &lt;test-commands&gt;
do
    &lt;conditional-command 1&gt;
    &lt;conditional-command 2&gt;
    &lt;conditional-command n&gt;
done
</code></pre><p>As long as the <em>test commands</em> do not return success, the loop will run the <em>conditional commands</em>. After the <em>conditional commands</em> have been run, the loop goes &lsquo;back to the start&rsquo; and evaluates the test commands again.</p><p>Here's an example of an <em>until</em> loop that builds a random number that is at least 15 characters long:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Create an empty random number string - we&#39;re going to build it up in the loop.</span>
random_number<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span>

<span style=color:#75715e># Keep on looping until the random number is at least 15 characters long.</span>
<span style=color:#66d9ef>until</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${#</span>random_number<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> -ge <span style=color:#ae81ff>15</span> <span style=color:#f92672>]</span>
<span style=color:#66d9ef>do</span>
    random_number<span style=color:#f92672>+=</span>$RANDOM
<span style=color:#66d9ef>done</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Random Number: </span><span style=color:#e6db74>${</span>random_number<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</code></pre></div><p>When you run this script you will see something like this:</p><pre><code>Random Number: 364272371462227929
</code></pre><p>Note that we've used the string-length parameter expansion function to get the length of the <code>random_number_</code> variable here. If this is not familiar, check <a href=/docs/part-4-shell-scripting/variables-reading-input-and-mathematics/>Chapter 19 - Variables, Reading Input, and Mathematics</a>.</p><p>In general I would recommend using while loops rather than until loops. While loops are going to be more familiar to readers as they exist in many programming languages - until loops are a little more rare. And you can easily turn any until loop into a while loop by simply inverting the test commands you are running.</p><p>For example, we could re-write the loop created before like so:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>random_number<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span>
<span style=color:#66d9ef>while</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${#</span>random_number<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> -lt <span style=color:#ae81ff>15</span> <span style=color:#f92672>]</span>
<span style=color:#66d9ef>do</span>
    random_number<span style=color:#f92672>+=</span>$RANDOM
<span style=color:#66d9ef>done</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Random Number: </span><span style=color:#e6db74>${</span>random_number<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</code></pre></div><p>In this case we've changed the condition from <code>-ge 15</code> (greater than or equal to fifteen) to <code>-lt 15</code> (less than fifteen). The while loop version of the script will probably be a little easier for most readers to parse.</p><h1 id=continue-and-break>Continue and Break</h1><p>We briefly saw that the <code>continue</code> (<em>resume loop</em>) statement can be used to &lsquo;skip&rsquo; an iteration in a loop. <code>break</code> (<em>exit loop</em>) statement that can be used to stop running the loop.</p><p>When we use the <code>continue</code> statement, we are telling the shell that we want to <em>stop</em> processing the current &lsquo;iteration&rsquo; of the loop and move onto the next item. You can use as many <code>continue</code> statements as you like in a loop.</p><p>Here's an example of a script that let's the users show the contents of a directory. If the directory is empty it uses the <code>continue</code> statement to skip to the next directory. If the users chooses to cancel the operation, it uses the <code>break</code> statement to stop iterating:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>echo <span style=color:#e6db74>&#34;For each folder, choose y/n to show contents, or c to cancel.&#34;</span>
<span style=color:#66d9ef>for</span> file in ~/*
<span style=color:#66d9ef>do</span>
    <span style=color:#75715e># If the file is not a directory, or it cannot be searched, skip it.</span>
    <span style=color:#66d9ef>if</span> ! <span style=color:#f92672>[</span> -d <span style=color:#e6db74>&#34;</span>$file<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span> <span style=color:#f92672>||</span> ! <span style=color:#f92672>[</span> -x <span style=color:#e6db74>&#34;</span>$file<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>continue</span>; <span style=color:#66d9ef>fi</span>

    <span style=color:#75715e># Ask the user if they want to see the contents.</span>
    read -p <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Show: </span>$file<span style=color:#e6db74>? [y/n/c]: </span><span style=color:#e6db74>&#34;</span> choice

    <span style=color:#75715e># If the user chose &#39;c&#39; for cancel, break.</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;</span>$choice<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;c&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span> break; <span style=color:#66d9ef>fi</span>

    <span style=color:#75715e># If the user choice &#39;y&#39; to show contents, list them.</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;</span>$choice<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;y&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span> ls <span style=color:#e6db74>&#34;</span>$file<span style=color:#e6db74>&#34;</span>; <span style=color:#66d9ef>fi</span>
<span style=color:#66d9ef>done</span>
</code></pre></div><p>Using <code>break</code> and <code>continue</code> can simplify our loops - if we it would be much harder to write the loop above.</p><h1 id=creating-compact-loops>Creating Compact Loops</h1><p>In each example in this chapter we have split the loop constructs so that there is one statement per line. But just as with the <code>if</code> statement, we can combine any of these lines, as long as we use a semi-colon to let the shell know where each statement ends.</p><p>A common pattern you will see is the <code>do</code> keyword on the same line as the <code>for</code> or <code>while</code> statement:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>numbers<span style=color:#f92672>=</span><span style=color:#f92672>(</span><span style=color:#ae81ff>0</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> 5<span style=color:#f92672>)</span>
<span style=color:#66d9ef>for</span> num in <span style=color:#e6db74>${</span>numbers[@]<span style=color:#e6db74>}</span>; <span style=color:#66d9ef>do</span>
    echo <span style=color:#e6db74>&#34;</span>$num<span style=color:#e6db74>&#34;</span>
<span style=color:#66d9ef>done</span>
</code></pre></div><p>If you are simply typing in the shell in a terminal, rather than writing a script, you might write the loop on a single line:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#66d9ef>for</span> script in *.sh; <span style=color:#66d9ef>do</span> touch <span style=color:#e6db74>&#34;</span>$script<span style=color:#e6db74>&#34;</span>; <span style=color:#66d9ef>done</span>
</code></pre></div><p>This one-liner updates the last access and modified of all files that end with <em>*.sh</em> in the current folder.</p><p>Just like with the <em>if statement</em> I would recommend that you keep each statement on its own line until you are 100% familiar with the syntax. Then when it is second-nature to be able to write a loop, you can use the more compact syntax if it is appropriate.</p><p>When you are running the shell <em>interactively</em>, i.e. actually typing in the shell rather than writing a shell script, you can still use multiple lines. If you type <code>for script in *.sh</code> and press enter, the shell will let you type the next line. You can keep on adding lines until you type <code>done</code> and press enter.</p><p>If you want to make a <em>really</em> compact for loop, you can actually skip the <code>in &lt;words></code> part. If <code>in &lt;words></code> is omitted then the special &lsquo;all parameters&rsquo; variable <code>$@</code> is used. We will look at this special parameter in the next chapter. But this will be confusing to readers so I would recommend that you are always explicit with the <code>in &lt;words</code> part of a for loop.</p><h1 id=word-splitting-and-ifs--index-->Word Splitting and IFS</h1><p>At a number of points in this chapter we have touched on the concept of &lsquo;word-splitting' and the <code>$IFS</code> variable. Before we close out the chapter with an update to the <code>common</code> script, let's talk about these concepts in more detail.</p><p>If you are not expecting to use shell scripts as a regular part of your work you can safely skip this section. If you think that you are likely to come across shell scripts, loops and similar constructs, it might be worth reading this section.</p><h2 id=word-splitting>Word Splitting</h2><p>Word splitting is the process by which the shell splits text up into a set of words.</p><p>We saw that the shell will split the words in a loop, which we can see with the example below:</p><pre><code>$ sentence=&quot;Here are some words&quot;
for word in $sentence; do echo &quot;$word&quot;; done
Here
are
some
words
</code></pre><p>But why is it that wrapping the <code>$sentence</code> variable in quotes stops the word splitting from happening?</p><pre><code>$ sentence=&quot;Here are some words&quot;
for word in &quot;$sentence&quot;; do echo &quot;$word&quot;; done
Here are some words
</code></pre><p>The reason for this has been touched on in <a href=/docs/part-4-shell-scripting/variables-reading-input-and-mathematics/>Chapter 19 - Variables, Reading Input, and Mathematics</a> and also partly in this chapter.</p><p>In the first example the loop iterates over the <code>$sentence</code> variable. Note that this variable is <em>not</em> quoted. This means that it follows the standard rules for &lsquo;expansion&rsquo; in the shell. This means that as well as all of the usual features such as wildcard expansion, <em>word expansion</em> will occur.</p><p>In the second example, the loop iterates over the <code>"$sentence"</code> variable. Note that this variable <em>is</em> quoted. As we saw in <a href=/docs/part-4-shell-scripting/variables-reading-input-and-mathematics/>Chapter 19</a> quoting a variable means that it is treated literally, expect for parameter expansion.</p><p>This means that in most circumstances you probably want to quote your variables - otherwise the shell is going to perform word splitting on them. But if you <em>do</em> want expansion and splitting to occur, then you should <em>not</em> quote text. For example, if we run the following we see invalid output:</p><pre><code>$ for file in &quot;*&quot;; do echo &quot;Found: $file&quot;; done
Found: *
</code></pre><p>Because we have quoted the asterisks, the shell does not treat it as a special character and expand it into a list of files.</p><p>What about this example, when we use wildcard expansion to list files, but the results do <em>not</em> have word splitting applied?</p><pre><code>$ touch file\ with\ spaces.test
$ for file in *.test; do echo &quot;Found: $file&quot;; done
Found: file with spaces.test
</code></pre><p>The <code>*.test</code> is not surrounded in quotes, so it is expanded. But why does word splitting not happen?</p><p>The reason is that the shell applies these &lsquo;expansions&rsquo; in a certain order, which is as follows:</p><ul><li>Brace expansion</li><li>Tilde expansion</li><li>Parameter and variable expansion</li><li>Command substitution</li><li>Arithmetic expansion</li><li>Word splitting</li><li>Pathname expansion</li></ul><p>Word splitting happens <em>before</em> pathname expansion, and it is pathname expansion that turns the asterisks wildcard into the list of files. At the point that this happens, word splitting has already been applied and won't be applied again.</p><p>Each of these types of expansion we have actually already seen in the book, but we're going to review them in detail in the final section on advanced techniques. You can find the appropriate section of the Bash manual for this topic by searching for <code>EXPANSION</code>.</p><h2 id=the-ifs-variable>The IFS Variable</h2><p>The <code>$IFS</code> variable is the &lsquo;internal field separator&rsquo; variable. It is what the shell uses to decide what characters should be used to split up text into words. By default, this variable includes the space character, the tab character and the newline character.</p><p>Whenever you see a script or a command that <em>changes</em> the value of the <code>$IFS</code> variable, the operator is modifying the behaviour of subsequent commands so that they do not split words in the same way.</p><p>Here's an example of how we could change the IFS variable to split text using commas:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>text<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;mother,danzig,1988&#34;</span>
IFS<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;,&#34;</span>
<span style=color:#66d9ef>for</span> word in $text
<span style=color:#66d9ef>do</span>
    echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Word: </span>$word<span style=color:#e6db74>&#34;</span>
<span style=color:#66d9ef>done</span>
</code></pre></div><p>This script will split text using the comma symbol and output:</p><pre><code>Word: mother
Word: danzig
Word: 1988
</code></pre><p>Be careful when changing the <code>IFS</code> variable - it could cause subsequent commands to behave in unexpected ways. You should normally first copy current value into a variable, then change it, then set it back, like so:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>old_ifs<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$IFS<span style=color:#e6db74>&#34;</span>
IFS<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;:&#34;</span>
<span style=color:#75715e># Do some stuff</span>
IFS<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$IFS<span style=color:#e6db74>&#34;</span>
</code></pre></div><p>In general if you are changing <code>IFS</code> you might be doing something that would be better done with a programming language.</p><h1 id=updating-the-common-command>Updating the &lsquo;common&rsquo; Command</h1><p>In the previous chapter we created the <code>common.v3.sh</code> command, that shows common commands from the users shell history.</p><p>If you need a refresher on what is in the script, you can view it in your pager with:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>less ~/effective-shell/scripts/common.v3.sh
</code></pre></div><p>Let's add a loop to our common, that let's use show a number next to each command so that we can see the order of the commands.</p><p>As the file is a little larger now, I am not going to show the entire file, only the key changes we will make.</p><p>First, in each of the sections that performs the command to get the common commands we will use Shell Parameter Expansion to run a sub-shell and store the results in a variable:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Store the most recently used commands in the &#39;commands&#39; variable.</span>
commands<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>tail ~/.bash_history -n <span style=color:#e6db74>${</span>history_lines<span style=color:#e6db74>}</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    | sort <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    | uniq -c <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    | sed <span style=color:#e6db74>&#39;s/^ *//&#39;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    | sort -n -r <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    | head -n <span style=color:#e6db74>${</span>command_count<span style=color:#e6db74>}</span><span style=color:#66d9ef>)</span>
</code></pre></div><p>There are two places we have to make this change - the first is for the Bash Shell and the second is for the Z-Shell. Now that we have stored our commands in a variable, we can loop through it at the end of the script and show a number that gives the order of each command:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Print each command, showing what its order is in the list.</span>
<span style=color:#75715e># Commands are separated by newlines, so temporarily change IFS to loop over</span>
<span style=color:#75715e># each line of the commands.</span>
counter<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>
old_ifs<span style=color:#f92672>=</span>$IFS
IFS<span style=color:#f92672>=</span><span style=color:#e6db74>$&#39;\n&#39;</span>
<span style=color:#66d9ef>for</span> command in $commands
<span style=color:#66d9ef>do</span>
    echo <span style=color:#e6db74>&#34;</span>$counter<span style=color:#e6db74>: </span>$comand<span style=color:#e6db74>&#34;</span>
    counter<span style=color:#f92672>=</span><span style=color:#66d9ef>$((</span>counter <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span><span style=color:#66d9ef>))</span>
<span style=color:#66d9ef>done</span>
IFS<span style=color:#f92672>=</span>$old_ifs
</code></pre></div><p>The updated script is in the samples folder at <em>~/effective-shell/scripts/common.v4.sh</em>, you can update your link to point to this version by running the <code>ln</code> command:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>ln -s ~/effective-shell/scripts/common.v4.sh /usr/local/bin/common
</code></pre></div><p>Now when we run this command, each of our common commands is printed with its order shown:</p><pre><code>$ common
1: 135 gst
2: 73 vi
3: 47 gc
4: 40 ls
5: 37 ga .
6: 27 gpo
7: 25 gl
8: 24 gpr
9: 21 gcm
10: 17 make dev
</code></pre><h1 id=summary>Summary</h1><p>In this chapter we looked at how to use different types of loops in the shell, to iterate over values in an array, words in a sentence, files and folders or even the results of commands.</p><p>We also looked in detail at how &lsquo;word-splitting&rsquo; works, as well as the <code>$IFS</code> variables. In the next chapter we'll look at functions and parameters.</p><h2 id=appendix---loops-and-the-z-shell>Appendix - Loops and the Z-Shell</h2><p>The Z-Shell does <em>not</em> perform word-splitting on unquoted variables. This is a deliberate choice by the designers, to avoid what can often be confusing behaviour.</p><p>We can see this behaviour below:</p><pre><code>% sentence=&quot;one two three&quot;
% for word in $sentence; do echo &quot;Word: $word&quot;; done
Word: one two three
</code></pre><p>If you want to use more Posix-like functionality then you can set the <code>SH_WORD_SPLIT</code> parameter. You can find out more about this parameter by running <code>man zsh</code> and searching for <code>SH_WORD_SPLIT</code>.</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>If we had put quotes around the wildcard text it would <em>not</em> be expanded - check the section on &lsquo;Quoting&rsquo; in <a href=/docs/part-4-shell-scripting/variables-reading-input-and-mathematics/>Chapter 19 - Variables, Reading Input, and Mathematics</a> if you need a refresher on this. <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>ANSI C Quoting is described in the &lsquo;Quoting&rsquo; section in <a href=/docs/part-4-shell-scripting/variables-reading-input-and-mathematics/>Chapter 19 - Variables, Reading Input, and Mathematics</a> <a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></article><div class="book-footer justify-between"><div><a class="flex align-center" href=https://github.com/dwmkerr/effective-shell/commit/e0fd07494ca0274a6d6bf16ac5df5d976eaebcc2 title="Last modified by Dave Kerr | Jan 18, 2022" target=_blank><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>Jan 18, 2022</span></a></div><div><a class="flex align-center" href=https://github.com/dwmkerr/effective-shell/edit/master/website/content/docs/part-4-shell-scripting/loops-and-working-with-files-and-folders/_index.md target=_blank><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"effective-shell"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><p>Copyright &copy; <script>document.write(new Date().getFullYear())</script>, Dave Kerr</p></div><aside class="book-toc levels-3 fixed"><nav id=TableOfContents><ul><li><a href=#chapter-21---loops-and-working-with-files-and-folders>Chapter 21 - Loops and working with Files and Folders</a></li><li><a href=#the-for-loop---index--->The For Loop</a><ul><li><a href=#for-loops---arrays>For Loops - Arrays</a></li><li><a href=#for-loops---words>For Loops - Words</a></li><li><a href=#for-loops---files-with-wildcards>For Loops - Files with Wildcards</a></li><li><a href=#for-loops---files-with-find>For Loops - Files with Find</a></li><li><a href=#for-loops---c-style-loops>For Loops - C Style Loops</a></li><li><a href=#for-loops---looping-over-sequences>For Loops - Looping over Sequences</a></li></ul></li><li><a href=#the-while-loop>The While Loop</a><ul><li><a href=#while-loops---looping-through-the-lines-in-a-file>While Loops - Looping through the lines in a file</a></li><li><a href=#while-loops---the-infinite-loop>While Loops - The Infinite Loop</a></li></ul></li><li><a href=#the-until-loop>The Until Loop</a></li><li><a href=#continue-and-break>Continue and Break</a></li><li><a href=#creating-compact-loops>Creating Compact Loops</a></li><li><a href=#word-splitting-and-ifs--index-->Word Splitting and IFS</a><ul><li><a href=#word-splitting>Word Splitting</a></li><li><a href=#the-ifs-variable>The IFS Variable</a></li></ul></li><li><a href=#updating-the-common-command>Updating the &lsquo;common&rsquo; Command</a></li><li><a href=#summary>Summary</a><ul><li><a href=#appendix---loops-and-the-z-shell>Appendix - Loops and the Z-Shell</a></li></ul></li></ul></nav></aside></main></body></html>