<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Shell Script Essentials"><meta property="og:title" content="Shell Script Essentials"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://effective-shell.com/docs/part-4-shell-scripting/shell-script-essentials/"><title>Shell Script Essentials | Effective Shell</title><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.f8520695a602b532b093067e25561bfe6fa10ca8c25171b97142acf58fa8f13c.css integrity="sha256-+FIGlaYCtTKwkwZ+JVYb/m+hDKjCUXG5cUKs9Y+o8Tw="><script defer src=/en.search.min.980bbc4b30781a9ff297004996a49900ec9265c2796852baa08c54f1335f3af5.js integrity="sha256-mAu8SzB4Gp/ylwBJlqSZAOySZcJ5aFK6oIxU8TNfOvU="></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-155335600-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><link rel=alternate type=application/rss+xml href=https://effective-shell.com/docs/part-4-shell-scripting/shell-script-essentials/index.xml title="Effective Shell"><script id=mcjs>!function(c,h,i,m,p){m=c.createElement(h),p=c.getElementsByTagName(h)[0],m.async=1,m.src=i,p.parentNode.insertBefore(m,p)}(document,"script","https://chimpstatic.com/mcjs-connected/js/users/eac1a082b6db34d40aaff2caf/a2aaca5a8358c2e12d3f43f1a.js");</script></head><body><input type=checkbox class=hidden id=menu-control><main class="flex container"><aside class="book-menu fixed"><nav><h2 class=book-brand><a href=https://effective-shell.com/><span>Effective Shell</span></a></h2><h2 class=book-subtitle><span>By Dave Kerr</span></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/docs/introduction/><strong>Introduction</strong></a></li><li><a href=/docs/getting-started/><strong>Getting Started</strong></a></li><li><a href=/docs/part-1-transitioning-to-the-shell/><strong>Part 1 - Transitioning to the Shell</strong></a><ul><li><a href=/docs/part-1-transitioning-to-the-shell/navigating-your-system/>Navigating Your System</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/managing-your-files/>Managing Your Files</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/clipboard-gymnastics/>Clipboard Gymnastics</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/getting-help/>Getting Help</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/the-renaissance-of-the-shell/>The Renaissance of the Shell</a></li></ul></li><li><a href=/docs/part-2-core-skills/><strong>Part 2 - Core Skills</strong></a><ul><li><a href=/docs/part-2-core-skills/thinking-in-pipelines/>Thinking in Pipelines</a></li><li><a href=/docs/part-2-core-skills/fly-on-the-command-line/>Fly on the Command Line</a></li><li><a href=/docs/part-2-core-skills/job-control/>Job Control</a></li><li><a href=/docs/part-2-core-skills/understanding-commands/>Understanding Commands</a></li><li><a href=/docs/part-2-core-skills/finding-files/>Finding Files</a></li><li><a href=/docs/part-2-core-skills/what-is-a-shell/>What is a Shell?</a></li></ul></li><li><a href=/docs/part-3-manipulating-text/><strong>Part 3 - Manipulating Text</strong></a><ul><li><a href=/docs/part-3-manipulating-text/regex-essentials/>Regex Essentials</a></li><li><a href=/docs/part-3-manipulating-text/get-to-grips-with-grep/>Get to Grips with Grep</a></li><li><a href=/docs/part-3-manipulating-text/slice-and-dice-text/>Slice and Dice Text</a></li><li><a href=/docs/part-3-manipulating-text/advanced-text-manipulation/>Advanced Text Manipulation with Sed</a></li><li><a href=/docs/part-3-manipulating-text/build-commands-on-the-fly/>Build Commands on the Fly with Xargs</a></li></ul></li><li><a href=/docs/part-4-shell-scripting/><strong>Part 4 - Shell Scripting</strong></a><ul><li><a href=/docs/part-4-shell-scripting/shell-script-essentials/ class=active>Shell Script Essentials</a></li><li><a href=/docs/part-4-shell-scripting/variables-reading-input-and-mathematics/>Variables, Reading Input, and Mathematics</a></li><li><a href=/docs/part-4-shell-scripting/mastering-conditional-logic/>Mastering Conditional Logic</a></li><li><a href=/docs/part-4-shell-scripting/loops-and-working-with-files-and-folders/>Loops and working with Files and Folders</a></li><li><a href=/docs/part-4-shell-scripting/functions-parameters-and-error-handling/>Functions, Parameters and Error Handling</a></li><li><a href=/docs/part-4-shell-scripting/useful-patterns-for-shell-scripts/>Useful Patterns for Shell Scripts</a></li></ul></li><li><a href=/docs/part-5-building-your-toolkit/><strong>Part 5 - Building Your Toolkit</strong></a><ul><li><a href=/docs/part-5-building-your-toolkit/configuring-the-shell/>Configuring the Shell</a></li><li><a href=/docs/part-5-building-your-toolkit/customising-your-command-prompt/>Customising Your Command Prompt</a></li><li><a href=/docs/part-5-building-your-toolkit/managing-your-dotfiles/>Managing Your Dotfiles</a></li><li><a href=/docs/part-5-building-your-toolkit/controlling-changes-with-git/>Controlling Changes with Git</a></li><li><a href=/docs/part-5-building-your-toolkit/managing-remote-git-repositories/>Managing Remote Git Repositories and Sharing Your Dotfiles</a></li></ul></li><li><a href=/docs/part-6-advanced-techniques/><strong>Part 6 - Advanced Techniques</strong></a></li><li><a href=/docs/work-in-progress/><strong>Work in Progress</strong></a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class="flex align-center justify-between book-header"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Shell Script Essentials</strong></header><article class=markdown><h1 id=chapter-18---shell-script-essentials>Chapter 18 - Shell Script Essentials</h1><p>First we're going to look at how to write shell scripts as well as the different ways to execute them. We'll look at how shell script files should be structured and how to use &lsquo;shebangs&rsquo; to define how a shell script will run.</p><p>These will be essential techniques to have as a foundation for building your own scripts. Even if you are familiar with shell scripts I would suggest skimming this chapter to make sure you understand each of the concepts, particularly the later section where we talk about using the <code>env</code> command in shebangs.</p><h1 id=what-is-a-shell-script>What is a Shell Script?</h1><p>A shell script is just a text file which contains a set of commands. As soon as you find yourself repeating the same sequence of commands in a shell, it might be worth saving these commands to a file and running the file instead.</p><p>Saving your commands to a file has a number of benefits. It saves time - you don't need to type the commands out each time you want to run them! You can use your favourite editor to build the script file, and you can add &lsquo;comments&rsquo; to describe what you are trying to achieve (which will make it far easier to update the script over time). Files can also easily be shared - meaning you can copy these scripts to other machines or share them with others who might find them useful.</p><h1 id=creating-a-basic-shell-script>Creating a Basic Shell Script</h1><p>Let's create a simple shell script that shows us our most commonly used shell commands.</p><p>Almost every command that is needed to build the script has been discussed in the book already, so it shouldn't be too unfamiliar. But I'll still break it down blow-by-blow to help us understand it.</p><p>As we go through this section of the book we're going to extend this script and make it more useful!</p><h2 id=the-common-command>The &lsquo;common&rsquo; Command</h2><p>We're going to create a new command, called &lsquo;common&rsquo;, that shows the most commonly used shell commands.</p><p>We should be able to do this using techniques we've seen so far. We'll do it like this:</p><ol><li>Read a large number of commands from the history</li><li>Sort the commands, then count the number of duplicates</li><li>Sort the commands, by the number of duplicates (i.e. ordering by &lsquo;most commonly used&rsquo;)</li><li>Print the results to the screen.</li></ol><p>Let's get started!</p><h2 id=creating-a-simple-script>Creating a Simple Script</h2><p>It's going to take some trial and error to get our commands right. So let's start by creating a shell script, which we'll run again and again.</p><p>In your favourite editor, create a file called <code>common.v1.sh</code> and put it somewhere on your system. As an example, I'm going to create a folder called <code>scripts</code> in my home directory and create the <code>common.v1.sh</code> file there:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Create a directory called &#39;scripts&#39;.</span>
<span style=color:#75715e># Using the &#39;-p&#39; flag means we won&#39;t get an error if the folder exists.</span>
mkdir -p ~/scripts 

<span style=color:#75715e># Create the script file.</span>
touch ~/scripts/common.v1.sh

<span style=color:#75715e># Open the script file in my favourite editor.</span>
vi ~/scripts.sh
</code></pre></div><p>I have called the script <code>common.v1.sh</code> rather than <code>common.sh</code> because in each chapter of this section we are going to improve upon the script and change the version number. So in later chapters we will create <code>common.v2.sh</code>, <code>common.v3.sh</code> and so on.</p><p>These commands should be familiar. The <code>mkdir</code> command creates a directory. The <code>-p</code> (create parent directories if needed) flag stops the command from returning an error if the directory already exist.</p><p>The <code>touch</code> command creates an empty file with the given name. Finally, I open the file in an editor. I am using Vim, but you can open this file in any editor you like.</p><p>Before we build the script, let's quickly talk about <em>comments</em>.</p><h1 id=comments--index>Comments&lt;!&ndash;index..></h1><p>The shell ignores any text which follows a <code>#</code> hash symbol. Whether this is text you type into a shell, or text in a shell script, the shell will ignore the content.</p><p>This is extremely useful - it means we can use the hash symbol to add <em>comments</em> to our scripts and commands. These comments are not interpreted by the shell, they are added just to make it easier for us to describe what is going on. If you come from a programming background you will likely be familiar with comments.</p><p>Here are a few examples:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># This is a comment - we can use this to describe what we&#39;re trying to do.</span>

echo <span style=color:#e6db74>&#34;Hello Shell&#34;</span> <span style=color:#75715e># Comments can go at the end of a line...</span>

<span style=color:#75715e># You can also use a comment symbol to &#39;comment out&#39; a line:</span>
<span style=color:#75715e># echo &#34;Goodbye Shell&#34;</span>
</code></pre></div><p>From this point on we'll use comments a lot to explain what we are trying to accomplish with each section of a script. It is generally good practice to use comments to describe your <em>intent</em> - why you are doing something. This is far more useful for the reader than <em>what</em> you are doing. The &lsquo;what&rsquo; should be clear from the commands - the &lsquo;why&rsquo; is the thing readers will likely want to understand.</p><p>Here's an example of a bad comment:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Write the CSV file, reverse it, cut it, reverse it.</span>
cat ~/effective-shell/data/top100.csv | rev | cut -d<span style=color:#e6db74>&#39;,&#39;</span> -f1 | rev
</code></pre></div><p>The comment just describes what the script is doing. But it doesn't explain <em>why</em>. A better comment would be:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># We want to extract the last field (the number of reviews) for each film.</span>
<span style=color:#75715e># Because we don&#39;t know how many fields there are we can reverse the text before</span>
<span style=color:#75715e># we cut it - then the last field becomes the first, which we extract and then</span>
<span style=color:#75715e># put back into the correct order by reversing it again.</span>
cat ~/effective-shell/data/top100.csv | rev | cut -d<span style=color:#e6db74>&#39;,&#39;</span> -f1 | rev
</code></pre></div><p>If you <em>don't</em> come from a programming background you might think that many of these comments are a little obvious. But as you write more and more code you'll realise that something that seemed obvious when you wrote it a while ago can look surprisingly baffling even just a few days later!</p><p>Now that we've discussed comments, we'll build our <code>common.v1.sh</code> shell script.</p><h1 id=building-and-testing-the-script>Building and Testing the Script</h1><p>Add the following commands to the <code>common.v1.sh</code> file:</p><pre><code># Write the title of our command.
echo &quot;common commands:&quot;

# Show the most commonly used commands.
tail ~/.bash_history -n 1000 | sort | uniq -c | sed 's/^ *//' | sort -n -r | head -n 10
</code></pre><p>This is a short script, but there is quite a lot going on. Let's look at it blow-by-blow:</p><ol><li>First we take the last 1000 lines of the <code>~/.bash_history</code> file using the <code>tail</code> command<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></li><li>Then we sort the commands. This will put all of the duplicates next to each other</li><li>Then we remove all duplicates and use the <code>-c</code> (<em>show count</em>) flag to count the duplicates</li><li>Then we remove the leading spaces from the output (which we need to do so that we can sort properly)</li><li>Then we sort <em>numerically</em> and in reverse - the highest count first</li><li>Finally, we limit the results to the first ten items</li></ol><p>If you need a refresher on the shell history, <code>sort</code> or <code>uniq</code> the check the <a href=/docs/part-3-manipulating-text/slice-and-dice-text/>Slice and Dice Text</a> chapter. If the <code>sed</code> command doesn't look familiar then check the <a href=/docs/part-3-manipulating-text/advanced-text-manipulation/>Advanced Text Manipulation with Sed</a> chapter.</p><p>If you want to see a more detailed breakdown of how the script works, check <a href=#appendix-how-the-script-works>Appendix - How the Script Works</a>. But this is not necessary for you to follow the content in this chapter.</p><p>Now save the file. In your shell, run the following command to execute the file:</p><pre><code>sh ~/scripts/common.v1.sh
</code></pre><p>The <code>sh</code> (shell) command starts a new shell. When we pass the path of a shell script, the shell command will run the script and then exit. The output you see will look something like this:</p><pre><code>common commands:
463 vi
267 gc
238 ga .
212 ls
169 gpo
122 make dev
112 gl
97 gcm
96 gpr
</code></pre><p>You can see my most common commands are short aliases for Git commands (the ones that start with &lsquo;g&rsquo;), opening Vim, running a makefile command and a few others.</p><p>We now have a basic shell script. Let's look at a few different ways we can run the script.</p><h1 id=multi-line-commands>Multi-line Commands</h1><p>You can use the <code>\</code> backslash character to create a &lsquo;continuation&rsquo; that tells the shell it needs to join lines up. This allows you to break long commands into multiple lines.</p><p>As an example, we could re-write our pipeline command to look like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Show the most commonly used commands.</span>
tail ~/.bash_history -n <span style=color:#ae81ff>1000</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    | sort <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    | uniq -c <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    | sed <span style=color:#e6db74>&#39;s/^ *//&#39;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    | sort -n -r <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    | head -n <span style=color:#ae81ff>10</span>
</code></pre></div><p>This will probably look very familiar to anyone with a background in functional programming!</p><p>Be careful when you split lines up - the continuation character <em>must</em> be the last character on the line. If you add something after it (such as a comment) then the command will fail.</p><h1 id=running-a-shell-script>Running a Shell Script</h1><p>There are a few different ways we can run shell scripts.</p><p>The first is to run a shell program and pass the script as a parameter. This is what we did in the earlier example. Here's another example of how we could run the script we created:</p><pre><code>bash ~/scripts/common.v1.sh
</code></pre><p>This is a perfectly valid technique. Now let's see the other ways we can run a script.</p><p>The next way we can run a script it is make it &lsquo;executable&rsquo;. This means we change the file permissions of the script file, adding the &lsquo;executable bit&rsquo;. This tells the systems we can run the file. We use the <code>chmod</code> (<em>change file mode</em>) command to do this:</p><pre><code>chmod +x ~/scripts/common.v1.sh
</code></pre><p>If the <code>chmod</code> command looks unfamiliar then check the <a href=/docs/part-2-core-skills/understanding-commands/>Understanding Commands</a> chapter. Now that the file has been made executable, we can simply enter the path to the file and run it, as if it was any other command:</p><pre><code>~/scripts/common.v1.sh
</code></pre><p>There is a problem with this approach though. How this file is executed is going to vary depending on how your system is set up<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>. For example, if you are using Bash, then the script will run in a new instance of the Bash shell. However, if you are using the Z shell, then the script will most likely run in the <code>sh</code> program (and depending on your system, this program might just be a link to <em>another</em> type of shell).</p><p>We want to avoid any ambiguity and be explicit about <em>what</em> program should run our script. We can do this using a special construct called a <em>shebang</em>.</p><h1 id=using-shebangs>Using Shebangs</h1><p>A <em>shebang</em> is a special set of symbols at the beginning of a file that tells the system what program should be used to run the file.</p><p>If we were to add a shebang to our <code>common.v1.sh</code> file, it would look like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e>#!/usr/bin/sh
</span><span style=color:#75715e></span>
<span style=color:#75715e># Write the title of our command.</span>
echo <span style=color:#e6db74>&#34;common commands:&#34;</span>

<span style=color:#75715e># Show the most commonly used commands.</span>
tail ~/.bash_history -n <span style=color:#ae81ff>1000</span> | sort | uniq -c | sed <span style=color:#e6db74>&#39;s/^ *//&#39;</span> | sort -n -r | head -n <span style=color:#ae81ff>10</span>
</code></pre></div><p>The shebang is the two characters - <code>#!</code>. The name &lsquo;shebang&rsquo; comes from the names of the symbols. The first symbol is a &lsquo;sharp&rsquo; symbol (sometimes it is called a hash, it depends a little on context). The second symbol is an exclamation point. In programming the exclamation point is sometimes called the &lsquo;bang&rsquo; symbol. When we put the two together, we get &lsquo;sharp bang&rsquo;, which is shortened to &lsquo;shebang&rsquo;.</p><p>Immediately after the shebang you write the full path to the program which should be used to open the file.</p><p>For example, if you wanted to write a script that is run in Python, you could do this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e>#!/usr/bin/python3</span>

<span style=color:#66d9ef>print</span>(<span style=color:#e6db74></span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>Hello from Python</span><span style=color:#e6db74>&#39;</span>)
</code></pre></div><p>If we wanted to explicitly use the Bash shell to run a script, we might use a shebang like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e>#!/usr/bin/bash
</span><span style=color:#75715e></span>
echo <span style=color:#e6db74>&#34;Hello from Bash&#34;</span>
</code></pre></div><p>What about Node.js? Easy!</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#75715e>#!/usr/bin/node
</span><span style=color:#75715e></span>
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;Hello from Node.js&#34;</span>);
</code></pre></div><h2 id=shebangs---dealing-with-paths>Shebangs - Dealing with Paths</h2><p>When we use a shebang we need to provide the full path the executable that will be used to run the script.</p><p>For example, what if we want to use Ruby to run a script we could write a script like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=color:#75715e>#!/usr/bin/ruby</span>

puts <span style=color:#e6db74>&#39;Hello from Ruby&#39;</span>
</code></pre></div><p>But there is a problem here. This will only work if you have the Ruby program installed in the location specified after the shebang (i.e. <code>/usr/bin/ruby</code>). If you do not have the Ruby program in this location the script will fail to run.</p><p>How can we know where the user will have a specific program installed?</p><p>There is a common trick for dealing with this issue. We can use the <code>env</code> (<em>set environment and execute command</em>) command to run a command and it will work out the path for us.</p><p>The <code>env</code> command is often used to show environment variables, but you can also use it to execute an arbitrary command (often with a modified environment). One handy feature of the <code>env</code> command is that it looks through the <code>$PATH</code> variable to find the path of the command to execute.</p><p>You can see this by running a command like the below:</p><pre><code>$ env python3
Python 3.8.5 (default, Jan 27 2021, 15:41:15)
[GCC 9.3.0] on linux
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt;
</code></pre><p>We've used the <code>env</code> command to run the <code>python3</code> command - and it worked out the correct path for us.</p><p>To use <code>env</code> in a shebang, specify the full path to <code>env</code> (which should be the same on all Unix-like systems) and then provide the name of the command to run:</p><pre><code>#!/usr/bin/env bash

echo &quot;Hello from Bash&quot;
</code></pre><p>Or another example:</p><pre><code>#!/usr/bin/env ruby

puts 'Hello from Ruby'
</code></pre><p>Using a shebang to specify the exact command to run, and then using the <code>env</code> command to allow the <code>$PATH</code> to be searched is generally the safest and most portable way to specify how a shell script should run.</p><h1 id=sourcing-shell-scripts>Sourcing Shell Scripts</h1><p>We have discussed how to <em>run</em> shell scripts. You can also use the <em>source</em> (<em>execute commands from a file</em>) command to load the contents of a file into the <em>current</em> shell.</p><p>Remember that when we run a shell script, a new shell is created as a child process of the current shell. This means that if you change something in the environment, such as a variable, it will not affect the environment of the shell that ran the script.</p><p>Let's see an example. We'll create a script called <em>set_editor.sh</em> that sets the <code>EDITOR</code> environment variable to <code>nano</code>. The script's contents are below (can can also find it in the samples at <em>~/effective-shell/scripts/set_editor.sh</em>):</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>EDITOR<span style=color:#f92672>=</span>nano
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Editor changed to: </span>$EDITOR<span style=color:#e6db74>&#34;</span>
</code></pre></div><p>Let's run this script and see what editor looks like before and after:</p><pre><code>$ echo $EDITOR
vim
$ ~/effective-shell/scripts/set_editor.sh
Editor changed to: nano
$ echo $EDITOR
vim
</code></pre><p>Notice that although we changed the <code>EDITOR</code> environment variable in our script, the change has not persisted in the current shell. This is because each shell (and in fact, each process) gets its own <em>copy</em> of the environment.</p><p>If we want to run the commands in the file in the context of the current shell, we can use the <code>source</code> command to load the file:</p><pre><code>$ echo $EDITOR
vim
$ source ~/effective-shell/scripts/set_editor.sh
Editor changed to: nano
$ echo $EDITOR
nano
</code></pre><p>Our existing environment has been changed. When we use <code>source</code>, the commands in the file are executed in the current shell, rather than in a new shell.</p><p>We can see this even more clearly if we use the <em>showpstree.sh</em> file:</p><pre><code>$ ~/effective-shell/scripts/show-info.sh
bash
  └─sh /home/ubuntu/effective-shell/scripts/showpstree.sh
    └─pstree -l -a -s 2240
</code></pre><p>This script shows the current &lsquo;process tree&rsquo;, using the <code>pstree</code> (<em>show process tree</em>) command. We can see that the <code>pstree</code> command was run as a child of the <code>sh</code> program. This program was run with the script path, by the shell I was using, <code>bash</code>. This is a nice visualisation of what is going on - our <code>bash</code> shell has run the <em>showpstree.sh</em> script in a child shell.</p><p>If we source the same file, we'll see that we do <em>not</em> create a new shell:</p><pre><code>$ source ~/effective-shell/scripts/show-info.sh
bash
  └─pstree -l -a -s 2169
</code></pre><h2 id=dot-sourcing--index-->Dot Sourcing</h2><p>There is a slightly more concise syntax that can be used to source a script - the <em>dot sourcing</em> notation. When the shell sees a <code>.</code> dot character, it will source the file that follows:</p><pre><code>$ . ~/effective-shell/scripts/show-info.sh
bash
  └─pstree -l -a -s 2169
</code></pre><p>You may encounter this syntax as you look at things like shell configuration files, which we discuss in <a href=/docs/part-5-building-your-toolkit/configuring-the-shell/>Chapter 24 - Configuring the Shell</a>.</p><h1 id=installing-your-script>Installing Your Script</h1><p>Before we finish with our shell script fundamentals, we'll take a look at one final commonly used pattern to run shell scripts - installing them as a local binary.</p><p>Our <code>common.v1.sh</code> script (with the added shebang) looks like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e>#!/usr/bin/env sh
</span><span style=color:#75715e></span>
<span style=color:#75715e># Write the title of our command.</span>
echo <span style=color:#e6db74>&#34;common commands:&#34;</span>

<span style=color:#75715e># Show the most commonly used commands.</span>
tail ~/.bash_history -n <span style=color:#ae81ff>1000</span> | sort | uniq -c | sed <span style=color:#e6db74>&#39;s/^ *//&#39;</span> | sort -n -r | head -n <span style=color:#ae81ff>10</span>
</code></pre></div><p>If we have made the script executable with the <code>chmod</code> command, then we can run the script by simply typing the location of the script in the shell:</p><pre><code>$ ~/scripts/common.v1.sh
common commands:
97 gcm
96 gpr
...
</code></pre><p>If we want to &lsquo;install&rsquo; this script as a local command which we can run easily, we can create a <em>symbolic link</em> to the shell script in our <code>/usr/local/bin</code> folder:</p><pre><code>ln -s ~/scripts/common.v1.sh /usr/local/bin/common
</code></pre><p>The <code>ln</code> (<em>create link</em>) command creates a link (which is like a shortcut in Windows and other desktop systems) in our <code>/usr/local/bin</code> folder, with the name <code>common</code>, which points to the script we have written. We can now run the <code>common</code> command without specifying its path:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ common
common commands:
<span style=color:#ae81ff>97</span> gcm
<span style=color:#ae81ff>96</span> gpr
...
</code></pre></div><p>This works because when the shell sees a command, it searches through the folders in the $PATH environment variable to find out where the command is. And the <code>/usr/bin/local</code> folder is in this list of paths.</p><p>Why do we use the <code>/usr/bin/local</code> folder rather than the <code>/usr/bin</code> folder? This is just a convention. In general, the <code>/usr/bin</code> folder is for commands which are installed with package manager tools like <code>apt</code> or Homebrew (on MacOS). The <code>/usr/local/bin</code> folder is used for commands which you create for yourself on your local machine and manage yourself<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>.</p><h2 id=summary>Summary</h2><p>In this chapter we've covered quite a few of the fundamentals of shell scripts:</p><ul><li>How to create a shell script</li><li>How comments work in shell scripts</li><li>How to handle long lines with continuations</li><li>How to run a shell script</li><li>How to make a shell script executable</li><li>How shebangs work</li><li>How to use the <code>env</code> command to make our shebangs more portable</li><li>How to &lsquo;install&rsquo; scripts for the current user</li></ul><p>In the next chapter we'll look at how to add logic to our shell scripts.</p><hr><h2 id=appendix---how-the-script-works>Appendix - How the Script Works</h2><p>This section briefly covers how the <code>common.v1.sh</code> script works. Assuming we have a history that looks like this:</p><pre><code>vi README.md
git status
git checkout main
git status
restart-shell
git status
open .
vi README.md
open .
</code></pre><p>First we sort, putting duplicate lines next to each other:</p><pre><code>git checkout main
git status
git status
git status
open .
open .
restart-shell
vi README.md
vi README.md
</code></pre><p>Then we use <code>uniq</code> to remove duplicate adjacent lines, passing the <code>-c</code> flag to include a count:</p><pre><code>     1 git checkout main
     3 git status
     2 open .
     1 restart-shell
     2 vi README.md
</code></pre><p>Now we remove the leading whitespace:</p><pre><code>1 git checkout main
3 git status
2 open .
1 restart-shell
2 vi README.md
</code></pre><p>Finally we sort numerically (by using the <code>-n</code> flag) and in descending order (by using the <code>-r</code> flag):</p><pre><code>3 git status
2 vi README.md
2 open .
1 restart-shell
1 git checkout main
</code></pre><p>Why the numeric sort? If we didn't sort numerically and instead performed the default lexographic sort and have more than single digit results, the output would look like this:</p><pre><code>1 git checkout main
1 restart-shell
13 git status
2 open .
2 vi README.md
</code></pre><p>This is a lexographic sort - the line starting with 13 comes after the line starting with 2. We want to sort by the value of the number.</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>The path to the shell history file is normally available in the <code>$HISTFILE</code> environment variable. However, in a non-interactive shell this variable is not set (and when we run a shell script, it is run in a non-interactive shell). We'll see more about interactive and non-interactive shells later, this is just a note in case you are wondering why we don't use the <code>$HISTFILE</code> variable or <code>history</code> command! <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>Try putting the command <code>pstree -p $$</code> in a shell script and running the script - you'll see exactly what process is run. <a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p>If you want to know more about these folders and the conventions behind them then check back soon, I am going to be adding an entire section on Linux Fundamentals, and one of the chapters will specifically be on the Linux Filesystem. This will cover &lsquo;The Linux Filesystem Hierarchy Standard&rsquo; which defines how folders like this should be used. <a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></article><div class="book-footer justify-between"><div><a class="flex align-center" href=https://github.com/dwmkerr/effective-shell/commit/f3654fc0e6f5f350ce2c45628150e5117e5f139d title="Last modified by Dave Kerr | Sep 6, 2021" target=_blank><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>Sep 6, 2021</span></a></div><div><a class="flex align-center" href=https://github.com/dwmkerr/effective-shell/edit/master/website/content/docs/part-4-shell-scripting/shell-script-essentials/_index.md target=_blank><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"effective-shell"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><p>Copyright &copy; <script>document.write(new Date().getFullYear())</script>, Dave Kerr</p></div><aside class="book-toc levels-3 fixed"><nav id=TableOfContents><ul><li><a href=#chapter-18---shell-script-essentials>Chapter 18 - Shell Script Essentials</a></li><li><a href=#what-is-a-shell-script>What is a Shell Script?</a></li><li><a href=#creating-a-basic-shell-script>Creating a Basic Shell Script</a><ul><li><a href=#the-common-command>The &lsquo;common&rsquo; Command</a></li><li><a href=#creating-a-simple-script>Creating a Simple Script</a></li></ul></li><li><a href=#comments--index>Comments</a></li><li><a href=#building-and-testing-the-script>Building and Testing the Script</a></li><li><a href=#multi-line-commands>Multi-line Commands</a></li><li><a href=#running-a-shell-script>Running a Shell Script</a></li><li><a href=#using-shebangs>Using Shebangs</a><ul><li><a href=#shebangs---dealing-with-paths>Shebangs - Dealing with Paths</a></li></ul></li><li><a href=#sourcing-shell-scripts>Sourcing Shell Scripts</a><ul><li><a href=#dot-sourcing--index-->Dot Sourcing</a></li></ul></li><li><a href=#installing-your-script>Installing Your Script</a><ul><li><a href=#summary>Summary</a></li><li><a href=#appendix---how-the-script-works>Appendix - How the Script Works</a></li></ul></li></ul></nav></aside></main></body></html>