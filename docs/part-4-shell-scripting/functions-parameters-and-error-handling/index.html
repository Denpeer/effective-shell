<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Functions, Parameters and Error Handling"><meta property="og:title" content="Functions, Parameters and Error Handling"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://effective-shell.com/docs/part-4-shell-scripting/functions-parameters-and-error-handling/"><title>Functions, Parameters and Error Handling | Effective Shell</title><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.f8520695a602b532b093067e25561bfe6fa10ca8c25171b97142acf58fa8f13c.css integrity="sha256-+FIGlaYCtTKwkwZ+JVYb/m+hDKjCUXG5cUKs9Y+o8Tw="><script defer src=/en.search.min.f547da3a61204160906e8e7006bbf2ad4c7f2eedd115d39d4fb68669dc72b3ec.js integrity="sha256-9UfaOmEgQWCQbo5wBrvyrUx/Lu3RFdOdT7aGadxys+w="></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-155335600-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><link rel=alternate type=application/rss+xml href=https://effective-shell.com/docs/part-4-shell-scripting/functions-parameters-and-error-handling/index.xml title="Effective Shell"><script id=mcjs>!function(c,h,i,m,p){m=c.createElement(h),p=c.getElementsByTagName(h)[0],m.async=1,m.src=i,p.parentNode.insertBefore(m,p)}(document,"script","https://chimpstatic.com/mcjs-connected/js/users/eac1a082b6db34d40aaff2caf/a2aaca5a8358c2e12d3f43f1a.js");</script></head><body><input type=checkbox class=hidden id=menu-control><main class="flex container"><aside class="book-menu fixed"><nav><h2 class=book-brand><a href=https://effective-shell.com/><span>Effective Shell</span></a></h2><h2 class=book-subtitle><span>By Dave Kerr</span></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/docs/introduction/><strong>Introduction</strong></a></li><li><a href=/docs/getting-started/><strong>Getting Started</strong></a></li><li><a href=/docs/part-1-transitioning-to-the-shell/><strong>Part 1 - Transitioning to the Shell</strong></a><ul><li><a href=/docs/part-1-transitioning-to-the-shell/navigating-your-system/>Navigating Your System</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/managing-your-files/>Managing Your Files</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/clipboard-gymnastics/>Clipboard Gymnastics</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/getting-help/>Getting Help</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/the-renaissance-of-the-shell/>The Renaissance of the Shell</a></li></ul></li><li><a href=/docs/part-2-core-skills/><strong>Part 2 - Core Skills</strong></a><ul><li><a href=/docs/part-2-core-skills/thinking-in-pipelines/>Thinking in Pipelines</a></li><li><a href=/docs/part-2-core-skills/fly-on-the-command-line/>Fly on the Command Line</a></li><li><a href=/docs/part-2-core-skills/job-control/>Job Control</a></li><li><a href=/docs/part-2-core-skills/understanding-commands/>Understanding Commands</a></li><li><a href=/docs/part-2-core-skills/finding-files/>Finding Files</a></li><li><a href=/docs/part-2-core-skills/what-is-a-shell/>What is a Shell?</a></li></ul></li><li><a href=/docs/part-3-manipulating-text/><strong>Part 3 - Manipulating Text</strong></a><ul><li><a href=/docs/part-3-manipulating-text/regex-essentials/>Regex Essentials</a></li><li><a href=/docs/part-3-manipulating-text/get-to-grips-with-grep/>Get to Grips with Grep</a></li><li><a href=/docs/part-3-manipulating-text/slice-and-dice-text/>Slice and Dice Text</a></li><li><a href=/docs/part-3-manipulating-text/advanced-text-manipulation/>Advanced Text Manipulation with Sed</a></li><li><a href=/docs/part-3-manipulating-text/build-commands-on-the-fly/>Build Commands on the Fly with Xargs</a></li></ul></li><li><a href=/docs/part-4-shell-scripting/><strong>Part 4 - Shell Scripting</strong></a><ul><li><a href=/docs/part-4-shell-scripting/shell-script-essentials/>Shell Script Essentials</a></li><li><a href=/docs/part-4-shell-scripting/variables-reading-input-and-mathematics/>Variables, Reading Input, and Mathematics</a></li><li><a href=/docs/part-4-shell-scripting/mastering-conditional-logic/>Mastering Conditional Logic</a></li><li><a href=/docs/part-4-shell-scripting/loops-and-working-with-files-and-folders/>Loops and working with Files and Folders</a></li><li><a href=/docs/part-4-shell-scripting/functions-parameters-and-error-handling/ class=active>Functions, Parameters and Error Handling</a></li><li><a href=/docs/part-4-shell-scripting/useful-patterns-for-shell-scripts/>Useful Patterns for Shell Scripts</a></li></ul></li><li><a href=/docs/part-5-building-your-toolkit/><strong>Part 5 - Building Your Toolkit</strong></a><ul><li><a href=/docs/part-5-building-your-toolkit/configuring-the-shell/>Configuring the Shell</a></li><li><a href=/docs/part-5-building-your-toolkit/customising-your-command-prompt/>Customising Your Command Prompt</a></li></ul></li><li><a href=/docs/work-in-progress/><strong>Work in Progress</strong></a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class="flex align-center justify-between book-header"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Functions, Parameters and Error Handling</strong></header><article class=markdown><h1 id=chapter-22---functions-parameters-and-error-handling>Chapter 22 - Functions, Parameters and Error Handling</h1><p>The shell allows you to create <em>functions</em> - a set of commands that you can call at any time. In this chapter we'll see how to create functions and how function parameters and script parameters are handled. We will also look at status codes for commands and scripts and error handling.</p><h1 id=creating-a-function----index--->Creating a Function</h1><p>A <em>function</em> has the following structure:</p><pre><code>&lt;function-name&gt; {
    &lt;function-command 1&gt;
    &lt;function-command 2&gt;
    &lt;function-command n&gt;
}
</code></pre><p>First we specify the name of the function. Then between a set of opening and closing curly braces, we list the commands that should be executed when we call the function.</p><p>Let's take a look at a very simple function in action:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>title<span style=color:#f92672>(</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    echo <span style=color:#e6db74>&#34;My Script version 1.0&#34;</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>This script defines a very simple function called <em>title</em> that prints out a message. We call the function in the same way we would call any command in the shell, by simply writing the name of the command and hitting enter. Here's how we would call the function:</p><pre><code>$ title
My Script version 1.0&quot;
</code></pre><p>Easy! Functions let you structure commands into logical blocks and can help make your scripts easier to read and manage.</p><h1 id=variables-in-functions>Variables in Functions</h1><p>A function can read and write to any variables in the current shell session. Here's an example:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Set some variables.</span>
title<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;My Cool Script&#34;</span>
version<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;1.2&#34;</span>
succeeded<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>

<span style=color:#75715e># Create a function that writes a message and changes a variable.</span>
title<span style=color:#f92672>(</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#75715e># Note that we can read variables...</span>
    title_message<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>title<span style=color:#e6db74>}</span><span style=color:#e6db74> - version </span><span style=color:#e6db74>${</span>version<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
    echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>title_message<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>

    <span style=color:#75715e># ...and set them as well.</span>
    succeeded<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>
<span style=color:#f92672>}</span>

<span style=color:#75715e># Show the value of &#39;succeeded&#39; before and after the function call.</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Succeeded: </span><span style=color:#e6db74>${</span>succeeded<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
title
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Succeeded: </span><span style=color:#e6db74>${</span>succeeded<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Title Message: </span><span style=color:#e6db74>${</span>title_message<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</code></pre></div><p>The output of this script will be:</p><pre><code>Succeeded: 0
My Cool Script - version 1.2
Succeeded: 1
Title Message: My Cool Script - version 1.2
</code></pre><p>This demonstrates that functions can use the variables that are available in the shell. They can also set variables. We can also create new variables in functions.</p><h2 id=variable-scoping---index-->Variable Scoping</h2><p>If you come from a programming background you might find it odd that you can create a variable in a function and use it outside of the function. This is a feature known as <em>dynamic scoping</em>. Many common programming languages like Python, JavaScript, C, Java and others use an alternative mechanism called <em>lexical scoping</em>.</p><p>Lexical scoping is a feature that ensures that you can only use a variable from within the &lsquo;scope&rsquo; that it is defined. This can reduce errors - because it means that if you define a variable in a function you don't accidentally &lsquo;overwrite&rsquo; the value of another variable that is used elsewhere.</p><p>You can use the &lsquo;local&rsquo; keyword to define a variable that is only available in the &lsquo;local&rsquo; scope, i.e. the function that it is defined in. This allows you to use lexical scoping and can reduce the risk of errors. Here's an example:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>run_loop<span style=color:#f92672>(</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    local count<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>
    <span style=color:#66d9ef>for</span> i in <span style=color:#f92672>{</span>1..10<span style=color:#f92672>}</span>; <span style=color:#66d9ef>do</span>
        <span style=color:#75715e># Update our counter.</span>
        count<span style=color:#f92672>=</span><span style=color:#66d9ef>$((</span>count <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span><span style=color:#66d9ef>))</span>
    <span style=color:#66d9ef>done</span>
    echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Count is: </span><span style=color:#e6db74>${</span>count<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>Let's see what happens if we run function:</p><pre><code>$ run_loop
Count is: 10
$ echo &quot;Count: ${count}&quot;
Count:
</code></pre><p>Notice that because we declared the <em>count</em> variable using the &lsquo;local&rsquo; keyword, it is only available inside the <em>run_loop</em> function. If we try and access it outside of the function it is undefined.</p><p>In general, you should use &lsquo;local&rsquo; variables inside functions. This can help to avoid problems where calling a function can have an unintended side effects:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Set a count variable somewhere in our script...</span>
count<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span>

<span style=color:#75715e># Call our &#39;run_loop&#39; function.</span>
run_loop

<span style=color:#75715e># Write out the value of &#39;count&#39;.</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>The &#39;count&#39; variable is: </span><span style=color:#e6db74>${</span>count<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</code></pre></div><p>The output of this script is:</p><pre><code>Count is: 10
The 'count' variable is: 3
</code></pre><p>Notice that even though we used a variable named <em>count</em> in the <em>run_loop</em> function, we did not overwrite the value that was set outside of the function. If we were to run the same script but not use the &lsquo;local&rsquo; keyword for he count variable, we would get the following output:</p><pre><code>Count is: 10
The 'count' variable is: 10
</code></pre><p>In this case calling the function changes the &lsquo;count&rsquo; variable that is outside of the function. In most cases this is not going to be what you want and will just lead to unexpected behaviour later on.</p><h1 id=passing-parameters-to-functions>Passing Parameters to Functions</h1><p>You can pass any number of parameters to a shell function. To get the value of a parameter, we can use special built-in variables that represent each parameter. Let's take a look at an example:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>sum<span style=color:#f92672>(</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    local value1<span style=color:#f92672>=</span>$1
    local value2<span style=color:#f92672>=</span>$2
    local result<span style=color:#f92672>=</span><span style=color:#66d9ef>$((</span>value1 <span style=color:#f92672>+</span> value2<span style=color:#66d9ef>))</span>
    echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>The sum of </span><span style=color:#e6db74>${</span>value1<span style=color:#e6db74>}</span><span style=color:#e6db74> and </span><span style=color:#e6db74>${</span>value2<span style=color:#e6db74>}</span><span style=color:#e6db74> is </span><span style=color:#e6db74>${</span>result<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>Let's see how we can pass parameters to this function:</p><pre><code>$ sum 3 6
The sum of 3 and 6 is 9
$ sum 10 33
The sum of 10 and 33 is 43
</code></pre><p>In this script we have used the special <code>$1</code> and <code>$2</code> built-in variables to get the value of the first and second parameters. At the beginning of the function I have put these variables into local variables that have more descriptive names. This is purely to make the script more readable, I could also have written the function like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Create a function that calculates the sum of two numbers.</span>
sum<span style=color:#f92672>(</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>The sum of </span>$1<span style=color:#e6db74> and </span>$2<span style=color:#e6db74> is </span><span style=color:#66d9ef>$((</span>$1 <span style=color:#f92672>+</span> $2<span style=color:#66d9ef>))</span><span style=color:#e6db74>&#34;</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>For a short and simple function you might just use the special parameter variables directly like above. However for anything more complex than a one-line script I think that it is generally more readable to create a local variable with a more descriptive name.</p><h2 id=parameter-variables>Parameter Variables</h2><p>There are a number of special parameter variables that the shell provides. Let's see a few in action:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Create a function that sums a set of numbers.</span>
sum<span style=color:#f92672>(</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    local total<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>
    <span style=color:#66d9ef>for</span> value in $@; <span style=color:#66d9ef>do</span>
        total<span style=color:#f92672>=</span><span style=color:#66d9ef>$((</span>total <span style=color:#f92672>+</span> value<span style=color:#66d9ef>))</span>
    <span style=color:#66d9ef>done</span>

    <span style=color:#75715e># Write out the result.</span>
    echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Summed </span>$#<span style=color:#e6db74> values for a total of: </span><span style=color:#e6db74>${</span>total<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>We can call this function with any number of parameters:</p><pre><code>$ sum 1 2 3 4 5
Summed 5 values for a total of: 15
</code></pre><p>In this script we've used two special variables. The <code>$@</code> variable is expanded into a list of all of the function parameters. The <code>$#</code> variable contains the number of parameters provided to the function.</p><p>You might recognise that these variables look quite similar to the syntax that is used to get the members of an array or the length of an array as described in <a href=/docs/part-4-shell-scripting/variables-reading-input-and-mathematics/>Chapter 19 - Variables, Reading Input, and Mathematics</a>. You can actually use some of the array-style operators with the special parameters variable:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Show the top &#39;n&#39; values of a set.</span>
show_top<span style=color:#f92672>(</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    local n<span style=color:#f92672>=</span>$1
    local values<span style=color:#f92672>=</span><span style=color:#e6db74>${</span>@:2:n<span style=color:#e6db74>}</span>
    echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Top </span><span style=color:#e6db74>${</span>n<span style=color:#e6db74>}</span><span style=color:#e6db74> values: </span><span style=color:#e6db74>${</span>values<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>We can call this function with any number of parameters. The first parameter specifies how many of the subsequent parameters we will show:</p><pre><code>$ show_top 3 10 20 30 40 50
Top 3 values: 10 20 30
</code></pre><p>We have used the &lsquo;range&rsquo; operator on the <code>$@</code> variable to get a subset of the parameters. This script is a little odd to read because when we set the &lsquo;values&rsquo; parameter we need to &lsquo;skip&rsquo; past the first positional parameter, because the first positional parameter is the number of values to show.</p><p>The table below shows some of the common variables you can use when working with function parameters:</p><table><thead><tr><th>Variable</th><th>Description</th></tr></thead><tbody><tr><td><code>$1</code></td><td>The first parameter</td></tr><tr><td><code>$2</code></td><td>The second parameter</td></tr><tr><td><code>${11}</code></td><td>The 11th parameter - if the parameter is more than one digit you must surround it with braces</td></tr><tr><td><code>$#</code></td><td>The number of parameters</td></tr><tr><td><code>$@</code></td><td>The full set of parameters as an array</td></tr><tr><td><code>$*</code></td><td>The full set of parameters as a string separated by the first value in the <code>$IFS</code> variable</td></tr><tr><td><code>${@:start:count}</code></td><td>A subset of &lsquo;count&rsquo; parameters starting at parameter number &lsquo;start&rsquo;</td></tr></tbody></table><p>The <code>$@</code> and <code>@*</code> parameters look quite similar. The first one is an array, just like we saw in <a href=/docs/part-4-shell-scripting/variables-reading-input-and-mathematics/>Chapter 19 - Variables, Reading Input, and Mathematics</a>. The second version is the parameters collected together into a single string separated by spaces (actually, separated by the first character in the <code>$IFS</code> variable).</p><h2 id=parameter-shifting>Parameter Shifting</h2><p>We can use the <code>shift</code> (<em>shift positional parameters</em>) to remove a number of parameters from the beginning of the position parameters list and &lsquo;shift&rsquo; the remaining parameters to take their place.</p><p>This is a little hard to describe so let's see how we can use it to simplify our <em>show_top</em> function:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Show the top &#39;n&#39; values of a set.</span>
show_top<span style=color:#f92672>(</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#75715e># Grab the number of values to show, then shift.</span>
    local n<span style=color:#f92672>=</span>$1
    shift

    <span style=color:#75715e># Get the set of values to show. Notice that we start in position 1 now.</span>
    local values<span style=color:#f92672>=</span><span style=color:#e6db74>${</span>@:1:n<span style=color:#e6db74>}</span>
    echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Top </span><span style=color:#e6db74>${</span>n<span style=color:#e6db74>}</span><span style=color:#e6db74> values: </span><span style=color:#e6db74>${</span>values<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>After we get the value of the first parameter, we &lsquo;shift&rsquo;, removing it from the list of positional parameters so that we can deal with the remaining parameters. I would avoid using &lsquo;shift&rsquo; too much - if you find that you are having to write complex code to shift parameters around you might be better using a programming language rather than the shell for the task you are performing!</p><h1 id=return-values>Return Values</h1><p>You can return a value from a shell function in two ways. The first is to simply set the value of a variable, like so:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>is_even<span style=color:#f92672>(</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    local number<span style=color:#f92672>=</span>$1

    <span style=color:#75715e># A number is even if when we divide it by 2 there is no remainder.</span>
    <span style=color:#75715e># Set &#39;result&#39; to 1 if the parameter is even and 0 otherwise.</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> <span style=color:#66d9ef>$((</span>number <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span><span style=color:#66d9ef>))</span> -eq <span style=color:#ae81ff>0</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
        result<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>
    <span style=color:#66d9ef>else</span>
        result<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>
    <span style=color:#66d9ef>fi</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>A function could set any number of variables to provide output. Here's how we could use the <em>is_even</em> function:</p><pre><code>$ number=33
$ is_even $number
$ echo &quot;Result is: $0&quot;
Result is: 0
</code></pre><p>In general, this method of returning values from a function should be avoided, for the reasons we've discussed already in this chapter. It overwrites the value of a global variable and that can be confusing for the operator.</p><p>A more common way to return a value from a function is to write its result to <em>stdout</em> - let's look at this in detail.</p><h2 id=writing-results-to-stdout>Writing Results to Stdout</h2><p>If we write our result to <em>stdout</em>, then we can capture the result of a function in a far more readable way:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>lowercase<span style=color:#f92672>(</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    local params<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$@<span style=color:#e6db74>&#34;</span>
    <span style=color:#75715e># Translate all uppercase characters to lowercase characters.</span>
    echo <span style=color:#e6db74>&#34;</span>$params<span style=color:#e6db74>&#34;</span> | tr <span style=color:#e6db74>&#39;[:upper:]&#39;</span> <span style=color:#e6db74>&#39;[:lower:]&#39;</span> 
<span style=color:#f92672>}</span>
</code></pre></div><p>In this example we write the result of the function to <em>stdout</em>. This means that we can capture the result and put it in another variable by simply executing the command in a subshell:</p><pre><code>$ result=$(lowercase &quot;Don't SHOUT!&quot;)
$ echo &quot;$result&quot;
don't shout!
</code></pre><p>If you have a programming background it might seem very strange that you write results in a function by writing to <em>stdout</em>. Remember - the shell is a text based interface to the computer system. The majority of commands that we have seen so far that provide output write their output to the screen. This is what <code>ls</code> does, what <code>find</code> does, what <code>cat</code> does and so on. When we <code>echo</code> a result from a function, we are really just following the Unix standard of writing the results of a program to the screen.</p><p>This is important - if we run our function directly in a shell, we can see the result written to the screen:</p><pre><code>$ lowercase &quot;PLEASE don't SHOUT!&quot;
please don't shout!
</code></pre><p>Remember - shell functions are designed to behave in a similar way to shell commands. They write their output to <em>stdout</em>.</p><h2 id=dealing-with-output-in-commands>Dealing with Output in Commands</h2><p>Although it might feel a bit clunky, writing the results of a command to <em>stdout</em> is a tried and tested method of returning results. However, we need to be careful. Let's take a look at an example to see why!</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># This function creates a temporary folder for today and returns its path.</span>
temp_today<span style=color:#f92672>(</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#75715e># Get today&#39;s date in the format YYYY-MM-DD.</span>
    local today<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>date +<span style=color:#e6db74>&#34;%Y-%m-%d&#34;</span><span style=color:#66d9ef>)</span>

    <span style=color:#75715e># Create a temporary directory for today and return it.</span>
    tmpdir_today<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>/tmp/</span><span style=color:#e6db74>${</span>today<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
    echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Creating folder &#39;</span><span style=color:#e6db74>${</span>tmpdir_today<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;...</span><span style=color:#e6db74>&#34;</span>
    mkdir -p <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>tmpdir_today<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
    echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>tmpdir_today<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>This function creates a temporary folder that is based on the current date. If we try and grab the result of the function and change to that folder then the script will fail:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Go to today&#39;s temporary folder.</span>
folder<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>temp_today<span style=color:#66d9ef>)</span>
cd <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>folder<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</code></pre></div><p>This script fails, with the output:</p><pre><code>'Creating folder \'/tmp/2021-05-28\'...\n/tmp/2021-05-28': No such file or directory
</code></pre><p>What's going on here?</p><p>Well in the <em>temp_today</em> function we wrote a message halfway through the function, showing the name of the folder that would be created. This message is part of the output of the function. Even though in the last line we echo the path to the folder, the output of the command is <em>all</em> of the text we have written.</p><p>It is important to remember that any command you call in a function that might write to <em>stdout</em> could cause problems as it could write text to your output:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>command_exists<span style=color:#f92672>(</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>if</span> type <span style=color:#e6db74>&#34;</span>$1<span style=color:#e6db74>&#34;</span>; <span style=color:#66d9ef>then</span>
        echo <span style=color:#e6db74>&#34;1&#34;</span>
    <span style=color:#66d9ef>else</span>
        echo <span style=color:#e6db74>&#34;0&#34;</span>
    <span style=color:#66d9ef>fi</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>What happens when we try and store the result of the function in a variable?</p><pre><code>$ result=$(command_exists &quot;touch&quot;)
$ echo &quot;Result is: ${result}&quot;
Result is: touch is hashed (/usr/bin/touch)
1
</code></pre><p>This is not a well written function, we'll look at a better way to write it next. But it shows an important challenge to be aware of - when <code>type</code> is used to find out whether a command exists it returns success if the command exists but also writes to <em>stdout</em>.</p><p>In <a href=/docs/part-2-core-skills/thinking-in-pipelines/>Chapter 7 - Thinking in Pipelines</a> we saw that we can send the output of a command to the &lsquo;null&rsquo; device to silence its output. We can use this trick in our functions to stop commands from &lsquo;polluting&rsquo; our result:
T</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>command_exists<span style=color:#f92672>(</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>if</span> type <span style=color:#e6db74>&#34;</span>$1<span style=color:#e6db74>&#34;</span> &gt;&gt; /dev/null; <span style=color:#66d9ef>then</span>
        echo <span style=color:#e6db74>&#34;1&#34;</span>
    <span style=color:#66d9ef>else</span>
        echo <span style=color:#e6db74>&#34;0&#34;</span>
    <span style=color:#66d9ef>fi</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>Now if we run this command we will not get the output from the <code>type</code> command in our result - the output was redirected to the null device.</p><h2 id=returning-status-codes>Returning Status Codes</h2><p>The <code>return</code> (<em>return from shell function</em>) command causes a function to exit with a given status code.</p><p>This is something that often causes confusion in shell scripts. The reason is that in most programming languages, you would use a &lsquo;return&rsquo; statement to return the result of a function. But in the shell, when we return, we set the <em>status code</em> of the function.</p><p>What is a status code? We actually touched on this in <a href=/docs/part-4-shell-scripting/mastering-conditional-logic/>Chapter 20 - Mastering the If Statement</a>. When a command runs, we expect it to return a <em>status code</em> of &lsquo;zero&rsquo; to indicate success. Any non-zero status code is used to specify an <em>error code</em>.</p><p>Let's see how we could re-write the <em>command_exists</em> function to set a status code:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>command_exists<span style=color:#f92672>(</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>if</span> type <span style=color:#e6db74>&#34;</span>$1<span style=color:#e6db74>&#34;</span> &gt;&gt; /dev/null; <span style=color:#66d9ef>then</span>
        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
    <span style=color:#66d9ef>else</span>
        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>
    <span style=color:#66d9ef>fi</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>Now that our command sets a status code properly, we can use it in an &lsquo;if statement&rsquo; like so:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#66d9ef>if</span> command_exists <span style=color:#e6db74>&#34;common&#34;</span>; <span style=color:#66d9ef>then</span>
    echo <span style=color:#e6db74>&#34;The &#39;common&#39; command is installed on your system&#34;</span>
<span style=color:#66d9ef>else</span>
    echo <span style=color:#e6db74>&#34;The &#39;common&#39; command is not installed on your system&#34;</span>
<span style=color:#66d9ef>fi</span>
</code></pre></div><p>Remember - only use the &lsquo;return&rsquo; command to set a status code. Many shells will only allow values from 0-255 to be set, and most users will expect that a command should return zero for success and that any non-zero value is an error code. If you need to provide output for a command that is not just a status code, you should write it to <em>stdout</em> or if you must, set the value of a global variable.</p><p>The result of the last executed command is always available in the special variable <code>$?</code>. Here's how you could use it:</p><pre><code>$ type &quot;test&quot;
test is a shell builtin
$ echo &quot;Result: $?&quot;
Result: 0
</code></pre><h1 id=error-handling>Error Handling</h1><p>When you run a shell script, if a command in the script fails, the script will continue to run. Like many other points in this chapter this might seem unintuitive if you come from a programming background, but this makes sense in the shell - if the shell was to terminate whenever a command fails it would be very difficult to use interactively.</p><p>Let's create a script called &lsquo;today&rsquo; that makes a new temporary folder each day, then puts a link to that folder in our home directory:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e>#!/usr/bin/env sh
</span><span style=color:#75715e></span>
<span style=color:#75715e># Get today&#39;s date in the format YYYY-MM-DD.</span>
today<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>date +<span style=color:#e6db74>&#34;%Y-%m-%d&#34;</span><span style=color:#66d9ef>)</span>

<span style=color:#75715e># Create the path to today&#39;s temp folder and then make sure the folder exists.</span>
temp_path<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>/tmp/</span><span style=color:#e6db74>${</span>today<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
mkdir -p <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>temp_path<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>

<span style=color:#75715e># Now that we&#39;ve created the folder, make a symlink to it in our homedir.</span>
ln -sf <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>temp_path<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>HOME<span style=color:#e6db74>}</span><span style=color:#e6db74>/today</span><span style=color:#e6db74>&#34;</span> 

<span style=color:#75715e># Write out the path we created.</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>temp_path<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</code></pre></div><p>Now we can run the script to create temporary folder for the current day and a link to it in our home directory:</p><pre><code>$ chmod +x ./today.sh
$ ./today.sh
/tmp/2021-05-28
$ cd ~/today
</code></pre><p>In this example we created a new directory in the <em>tmp</em> folder and created a link to it in our home directory. But what happens if we cause one of the commands to fail?</p><p>First, let's clean up the folder we created:</p><pre><code>$ rm -rf $(./today.sh)
$ rm ~/today
</code></pre><p>Now we'll create a file where we want to put our &lsquo;today&rsquo; folder:</p><pre><code>$ touch &quot;/tmp/$(date +&quot;%Y-%m-%d&quot;)&quot;
</code></pre><p>If we run our script now, we can see a problem:</p><pre><code>$ ./today.sh
mkdir: /tmp/2021-05-28: Not a directory
/tmp/2021-05-28
$ cd ~/today
bash: cd: /home/dwmkerr/today: Not a directory
</code></pre><p>The <code>mkdir</code> command failed - because there was a <em>file</em> in the location where we wanted to create the folder. But the script kept on running - meaning that it created a symlink to this file. Now when we try to move to the <code>today</code> folder we get another error - it is a link to a file not a folder.</p><p>In general in your shell scripts if a command fails you probably want the entire script to stop executing. Otherwise you can get this cascading effect as commands continue to return even after there was a failure, which can lead to all sorts of unexpected behaviour.</p><p>You can use the <code>set</code> (<em>set option</em>) command to set an option in the shell. There is an option that tells the shell to exit when a command fails. Here's how we would use it:</p><pre><code>#!/usr/bin/env sh

# Exit if any command fails.
set -e

# ...
</code></pre><p>The &lsquo;set&rsquo; command allows you to turn on and turn off shell options. The &lsquo;e&rsquo; option means &lsquo;exit if any command exits with a non-zero status&rsquo;.</p><p>Now let's clean up again:</p><pre><code>$ rm -rf $(./today.sh)
$ rm ~/today
</code></pre><p>And finally, we'll run the same script after creating the file that will cause a failure:</p><pre><code>$ touch &quot;/tmp/$(date +&quot;%Y-%m-%d&quot;)&quot;
$ ./today.sh
mkdir: /tmp/2021-05-28: Not a directory
</code></pre><p>In this case the script stopped running as soon as there was a failure - after the <code>mkdir</code> command failed.</p><h1 id=the-function-keyword>The Function Keyword</h1><p>In some scripts you might see functions defined using the <code>function</code> keyword, as below:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#66d9ef>function</span> title<span style=color:#f92672>(</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    echo <span style=color:#e6db74>&#34;My Script version 1.0&#34;</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>The &lsquo;function&rsquo; keyword is not required. The keyword is available in Bash and similar shells. Using the function keyword has a minor benefit that it does not lead to an error if you have already defined an <em>alias</em> with the same name as the function you are declaring. However, the drawback is that it is less standard and therefore less portable.</p><p>I would recommend that you do not use the &lsquo;function&rsquo; keyword. Firstly, this will make your scripts more portable. Secondly, if your function is going to clash with the name of an alias that has already been defined, I would actually think that it is better that the script fails. Better to fail early and realise there is clash than to silently overwrite the alias which may cause unexpected errors later on when something else tries to call the alias and calls your function instead!</p><h1 id=parameters-and-status-codes-for-scripts>Parameters and Status Codes for Scripts</h1><p>Everything we have learned about parameters applies to scripts themselves. We can pass parameters to scripts and read them with the special variables such as <code>$1</code>, <code>$2</code> and so on.</p><p>The only difference is that instead of using the <code>return</code> command when we want to exit a script with a status code, we use the <code>exit</code> (<em>exit the shell</em>) command. The exit command exits the current shell with the provided status code.</p><p>Be careful when using the <code>exit</code> command - if you are running a script then it is fine to use <code>exit</code>, it will simply close the subshell that the script is running in. But if you type <code>exit</code> in your shell that you are using interactively, it will close it.</p><h1 id=updating-the-common-command>Updating the &lsquo;common&rsquo; Command</h1><p>In the previous chapter we created the <code>common.v4.sh</code> command, that shows common commands from the users shell history.</p><p>If you need a refresher on what is in the script, you can view it in your pager with:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>less ~/effective-shell/scripts/common.v4.sh
</code></pre></div><p>The output of the command will look something like:</p><pre><code>1: 280 gst
2: 144 vi
3: 84 gc
4: 72 ga .
5: 62 gl
6: 54 ls
7: 50 gpo
8: 48 gcm
9: 45 make dev
10: 44 gpr
</code></pre><p>Let's make a couple of changes.</p><p>First, let's make sure we exit the script if one of the commands fails:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Exit if any command fails.</span>
set -e
</code></pre></div><p>Next, we will update the script on line 7 so that we use the first parameter as the command count. If the first parameter is not set, we default to ten:</p><pre><code># ...
command_count=${1:-10} # The number of common commands to show
# ...
</code></pre><p>Here we are using the <code>$1</code> variable. But we are also using <em>Shell Parameter Expansion</em> as described in <a href=/docs/part-4-shell-scripting/variables-reading-input-and-mathematics/>Chapter 19 - Variables, Reading Input, and Mathematics</a> to provide a default value to use if the parameter is not set.</p><p>Next, let's change the line that writes out the count and the name of the command. At the moment, the count is shown and then the command name. Let's write a function that takes a number and line of text and writes it as a line of text with the number <em>after</em> the text and in brackets:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>write_command_then_count<span style=color:#f92672>(</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#75715e># Get the command and count, this will be text that looks like:</span>
    <span style=color:#75715e>#   &#39;43 git commit&#39;</span>
    <span style=color:#75715e># Then write the command and the count afterwards.</span>
    local line<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$1<span style=color:#e6db74>&#34;</span>
    local count<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>line<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> | cut -d<span style=color:#e6db74>&#39; &#39;</span> -f1<span style=color:#66d9ef>)</span>
    local command<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>line<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> | cut -d<span style=color:#e6db74>&#39; &#39;</span> -f2-<span style=color:#66d9ef>)</span>
    echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>command<span style=color:#e6db74>}</span><span style=color:#e6db74> (</span><span style=color:#e6db74>${</span>count<span style=color:#e6db74>}</span><span style=color:#e6db74>)</span><span style=color:#e6db74>&#34;</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>We can now re-write our loop to make it a little cleaner:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#66d9ef>for</span> command in $commands
<span style=color:#66d9ef>do</span>
    echo <span style=color:#e6db74>&#34;</span>$counter<span style=color:#e6db74>: </span><span style=color:#66d9ef>$(</span>write_command_then_count <span style=color:#e6db74>&#34;</span>$command<span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span>
    counter<span style=color:#f92672>=</span><span style=color:#66d9ef>$((</span>counter <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span><span style=color:#66d9ef>))</span>
<span style=color:#66d9ef>done</span>
</code></pre></div><p>The updated script is in the samples folder at <em>~/effective-shell/scripts/common.v5.sh</em>, you can update your link to point to this version by running the <code>ln</code> command:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>ln -s ~/effective-shell/scripts/common.v5.sh /usr/local/bin/common
</code></pre></div><p>Now when we run this command we can optionally provide the number of commands to show as a parameter. The output also is shown with the number of times the command has been called <em>after</em> the command text itself:</p><pre><code>$ common 5
common commands:
1: gst (139)
2: vi (74)
3: gc (42)
4: ga . (36)
5: gl (31)
</code></pre><h1 id=summary>Summary</h1><p>In this chapter we looked at how to use functions to provide more structure to our shell scripts, and also how to use parameters, return values and status codes.</p><p>In the next and final chapter of this section, we'll look at some more advanced techniques that can be useful when writing shell scripts.</p></article><div class="book-footer justify-between"><div><a class="flex align-center" href=https://github.com/dwmkerr/effective-shell/commit/354e41d79767baeecfa0a4405aeaa6a36589b6af title="Last modified by Dave Kerr | Jun 7, 2021" target=_blank><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>Jun 7, 2021</span></a></div><div><a class="flex align-center" href=https://github.com/dwmkerr/effective-shell/edit/master/website/content/docs/part-4-shell-scripting/functions-parameters-and-error-handling/_index.md target=_blank><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"effective-shell"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><p>Copyright &copy; <script>document.write(new Date().getFullYear())</script>, Dave Kerr</p></div><aside class="book-toc levels-3 fixed"><nav id=TableOfContents><ul><li><a href=#chapter-22---functions-parameters-and-error-handling>Chapter 22 - Functions, Parameters and Error Handling</a></li><li><a href=#creating-a-function----index--->Creating a Function</a></li><li><a href=#variables-in-functions>Variables in Functions</a><ul><li><a href=#variable-scoping---index-->Variable Scoping</a></li></ul></li><li><a href=#passing-parameters-to-functions>Passing Parameters to Functions</a><ul><li><a href=#parameter-variables>Parameter Variables</a></li><li><a href=#parameter-shifting>Parameter Shifting</a></li></ul></li><li><a href=#return-values>Return Values</a><ul><li><a href=#writing-results-to-stdout>Writing Results to Stdout</a></li><li><a href=#dealing-with-output-in-commands>Dealing with Output in Commands</a></li><li><a href=#returning-status-codes>Returning Status Codes</a></li></ul></li><li><a href=#error-handling>Error Handling</a></li><li><a href=#the-function-keyword>The Function Keyword</a></li><li><a href=#parameters-and-status-codes-for-scripts>Parameters and Status Codes for Scripts</a></li><li><a href=#updating-the-common-command>Updating the &lsquo;common&rsquo; Command</a></li><li><a href=#summary>Summary</a></li></ul></nav></aside></main></body></html>