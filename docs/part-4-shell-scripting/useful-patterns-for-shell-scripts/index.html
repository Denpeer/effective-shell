<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Useful Patterns for Shell Scripts"><meta property="og:title" content="Useful Patterns for Shell Scripts"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://effective-shell.com/docs/part-4-shell-scripting/useful-patterns-for-shell-scripts/"><title>Useful Patterns for Shell Scripts | Effective Shell</title><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.f8520695a602b532b093067e25561bfe6fa10ca8c25171b97142acf58fa8f13c.css integrity="sha256-+FIGlaYCtTKwkwZ+JVYb/m+hDKjCUXG5cUKs9Y+o8Tw="><script defer src=/en.search.min.abff7fa0b9fa3f6f8ee77b89b7986b4dca3062f9bb6f9e37187080001aa8b304.js integrity="sha256-q/9/oLn6P2+O53uJt5hrTcowYvm7b543GHCAABqoswQ="></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-155335600-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><link rel=alternate type=application/rss+xml href=https://effective-shell.com/docs/part-4-shell-scripting/useful-patterns-for-shell-scripts/index.xml title="Effective Shell"></head><body><input type=checkbox class=hidden id=menu-control><main class="flex container"><aside class="book-menu fixed"><nav><h2 class=book-brand><a href=https://effective-shell.com/><span>Effective Shell</span></a></h2><h2 class=book-subtitle><span>By Dave Kerr</span></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/docs/introduction/><strong>Introduction</strong></a></li><li><a href=/docs/getting-started/><strong>Getting Started</strong></a></li><li><a href=/docs/part-1-transitioning-to-the-shell/><strong>Part 1 - Transitioning to the Shell</strong></a><ul><li><a href=/docs/part-1-transitioning-to-the-shell/navigating-your-system/>Navigating Your System</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/managing-your-files/>Managing Your Files</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/clipboard-gymnastics/>Clipboard Gymnastics</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/getting-help/>Getting Help</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/the-renaissance-of-the-shell/>The Renaissance of the Shell</a></li></ul></li><li><a href=/docs/part-2-core-skills/><strong>Part 2 - Core Skills</strong></a><ul><li><a href=/docs/part-2-core-skills/thinking-in-pipelines/>Thinking in Pipelines</a></li><li><a href=/docs/part-2-core-skills/fly-on-the-command-line/>Fly on the Command Line</a></li><li><a href=/docs/part-2-core-skills/job-control/>Job Control</a></li><li><a href=/docs/part-2-core-skills/understanding-commands/>Understanding Commands</a></li><li><a href=/docs/part-2-core-skills/finding-files/>Finding Files</a></li><li><a href=/docs/part-2-core-skills/what-is-a-shell/>What is a Shell?</a></li></ul></li><li><a href=/docs/part-3-manipulating-text/><strong>Part 3 - Manipulating Text</strong></a><ul><li><a href=/docs/part-3-manipulating-text/regex-essentials/>Regex Essentials</a></li><li><a href=/docs/part-3-manipulating-text/get-to-grips-with-grep/>Get to Grips with Grep</a></li><li><a href=/docs/part-3-manipulating-text/slice-and-dice-text/>Slice and Dice Text</a></li><li><a href=/docs/part-3-manipulating-text/advanced-text-manipulation/>Advanced Text Manipulation with Sed</a></li><li><a href=/docs/part-3-manipulating-text/build-commands-on-the-fly/>Build Commands on the Fly with Xargs</a></li></ul></li><li><a href=/docs/part-4-shell-scripting/><strong>Part 4 - Shell Scripting</strong></a><ul><li><a href=/docs/part-4-shell-scripting/shell-script-essentials/>Shell Script Essentials</a></li><li><a href=/docs/part-4-shell-scripting/variables-reading-input-and-mathematics/>Variables, Reading Input, and Mathematics</a></li><li><a href=/docs/part-4-shell-scripting/mastering-the-if-statement/>Mastering the If Statement</a></li><li><a href=/docs/part-4-shell-scripting/loops-and-working-with-files-and-folders/>Loops and working with Files and Folders</a></li><li><a href=/docs/part-4-shell-scripting/functions-parameters-and-error-handling/>Functions, Parameters and Error Handling</a></li><li><a href=/docs/part-4-shell-scripting/useful-patterns-for-shell-scripts/ class=active>Useful Patterns for Shell Scripts</a></li></ul></li><li><a href=/docs/work-in-progress/><strong>Work in Progress</strong></a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class="flex align-center justify-between book-header"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Useful Patterns for Shell Scripts</strong></header><article class=markdown><h1 id=chapter-23---useful-patterns-for-shell-scripts>Chapter 23 - Useful Patterns for Shell Scripts</h1><p>To close this the section on shell scripting we're going to look at some common patterns you will see in shell scripts. These are an assortment of techniques you may find useful when building your scripts - you may come across them in scripts others have written as well.</p><p>Remember that although this chapter focuses on patterns that are useful in scripts, you can apply these patterns in any shell session. This means you might find this chapter useful even if you are not expecting to write scripts, just as a way to understand some more advanced shell techniques.</p><h1 id=debugging-shell-scripts>Debugging Shell Scripts</h1><p>You can use the <code>set</code> (<em>set option</em>) command to set the _trace option_. This option is incredibly useful for debugging shell scripts. When the trace option is set, the shell will write out each statement before it is evaluated.</p><p>Let's see just how useful this is with an example!</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># today.sh - creates a &#39;today&#39; symlink in the home directory folder to a fresh</span>
<span style=color:#75715e># temporary folder each day.</span>

<span style=color:#75715e># Enable tracing in the script.</span>
set -x

<span style=color:#75715e># Get today&#39;s date in the format YYYY-MM-DD.</span>
today<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>date +<span style=color:#e6db74>&#34;%Y-%m-%d&#34;</span><span style=color:#66d9ef>)</span>

<span style=color:#75715e># Create the path to today&#39;s temp folder and then make sure the folder exists.</span>
temp_path<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>/tmp/</span><span style=color:#e6db74>${</span>today<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
mkdir -p <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>temp_path<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>

<span style=color:#75715e># Now that we&#39;ve created the folder, make a symlink to it in our homedir.</span>
ln -sf <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>temp_path<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>HOME<span style=color:#e6db74>}</span><span style=color:#e6db74>/today</span><span style=color:#e6db74>&#34;</span>

<span style=color:#75715e># Disable tracing now that we are done with the work.</span>
set +x

<span style=color:#75715e># Write out the path we created.</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>temp_path<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</code></pre></div><p>Notice that we use <code>set -x</code> to enable tracing early on in the script, and <code>set +x</code> to disable tracing towards the end. If we run this script, we'll see the following output:</p><pre><code>$ ~/effective-shell/scripts/today.sh
++ date +%Y-%m-%d
+ today=2021-05-29
+ temp_path=/tmp/2021-05-29
+ mkdir -p /tmp/2021-05-29
+ ln -sf /tmp/2021-05-29 /home/dwmkerr/today
+ set +x
/tmp/2021-05-29
</code></pre><p>Each command that the shell executes is written to <em>stdout</em> before it is executed. The parameters are expanded, which can make it far easier to see what is going on and troubleshoot issues.</p><p>The <code>+</code> symbol is written at the start of each trace line, so that you can differentiate it from normal output that you write in your script<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. The final line of output in the example above does not have a <code>+</code> in front of it - because it is actual output from an <code>echo</code> command, rather than a trace line.</p><p>The number of <code>+</code> symbols indicates the &lsquo;level of indirection&rsquo; - this is how many sub-shells you are in. Each subshell is traced on its own line. This makes tracing complex commands far easier:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>set -x
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Name of home folder is </span><span style=color:#66d9ef>$(</span>basename <span style=color:#66d9ef>$(</span>echo ~<span style=color:#66d9ef>)</span> <span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span>
</code></pre></div><p>The output of this command is:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>+++ echo /home/dwmkerr
++ basename /home/dwmkerr
+ echo <span style=color:#e6db74>&#39;Name of home folder is dwmkerr&#39;</span>
Name of home folder is dwmkerr
</code></pre></div><p>Notice that each subshell command is shown with an additional plus as it gets more nested. The nested commands are shown in the order that they are evaluated.</p><h1 id=checking-for-existing-variables-or-functions>Checking for Existing Variables or Functions</h1><p>The <code>declare</code> (<em>set variable values and attributes</em>) command can be used to explicitly declare that we are creating a variable. We saw in <a href=/docs/part-4-shell-scripting/variables-reading-input-and-mathematics/>Chapter 19 - Variables, Reading Input, and Mathematics</a> that sometimes this command is required - if we want to create an associative array for example.</p><p>There are a number of options for the &lsquo;declare&rsquo; command, but one that is particularly useful is the <code>-p</code> (<em>display attributes and value</em>) option. This can be used to show all of the variables of a certain type.</p><p>Here's an example to show all associative arrays that have been created:</p><pre><code>$ declare -p -A
declare -A BASH_ALIASES=()
declare -A BASH_CMDS=()
</code></pre><p>You can also use this command to validate whether a variable has been set or not:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#66d9ef>if</span> declare -p -A my_options 2&gt;1 /dev/null; <span style=color:#66d9ef>then</span>
    echo <span style=color:#e6db74>&#34;&#39;my_options&#39; exists&#34;</span>
<span style=color:#66d9ef>else</span>
    echo <span style=color:#e6db74>&#34;&#39;my_options&#39; does not exist&#34;</span>
<span style=color:#66d9ef>fi</span>
</code></pre></div><p>We have to silence the error output of the <code>declare</code> command unless we want it to print an message if the variable doesn't exist. This technique can be useful to use before setting variables to ensure that they are not already in use, or check that the variable exists.</p><p>Functions are also variables - so we can use this trick to show all functions that are declared, the value of a function, or check if a function exists.</p><h1 id=unsetting-values>Unsetting Values</h1><p>If you are writing a script that should clean up after itself, you might want to use the <code>unset</code> (<em>unset values and attributes</em>) command. This can be useful if you want to create a script that leaves behind no variables or functions that could cause issues for later users:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Remove the &#39;is_even&#39; function from the shell session.</span>
unset -f is_even
</code></pre></div><h1 id=traps>Traps</h1><p>You can use the <code>trap</code> (<em>trap signals and events</em>) command to specify a set of commands to run when the shell receives signals, or at certain points such as when the script exits or a function returns.</p><p>A very common use for traps is to create a &lsquo;cleanup&rsquo; function that is executed when the script exits or if the user aborts execution by pressing <code>Ctrl+C</code> (which sends the <code>SIGINT</code> signal).</p><p>Here's an example of how a <code>trap</code> can be set to cleanup a temporary folder when a script exits or is interrupted:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Create a temporary folder for the effective shell download.</span>
source<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;https://effective-shell.com/downloads/effective-shell-playground.tar.gz&#34;</span>
tmp_dir<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>mktemp -d 2&gt;/dev/null <span style=color:#f92672>||</span> mktemp -d -t <span style=color:#e6db74>&#39;effective-shell&#39;</span><span style=color:#66d9ef>)</span>
tmp_tar<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>tmp_dir<span style=color:#e6db74>}</span><span style=color:#e6db74>/effective-shell.tar.gz</span><span style=color:#e6db74>&#34;</span>

<span style=color:#75715e># Define a cleanup function that we will call when the script exits or if</span>
<span style=color:#75715e># it is aborted.</span>
cleanup <span style=color:#f92672>(</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -e <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>tmp_tar<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span> rm <span style=color:#e6db74>&#34;</span>$tmp_tar<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>; <span style=color:#66d9ef>fi</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -d <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>tmp_dir<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span> rm -rf <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>tmp_dir<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>; <span style=color:#66d9ef>fi</span>
<span style=color:#f92672>}</span>

<span style=color:#75715e># Cleanup on interrupt or terminate signals and on exit.</span>
trap <span style=color:#e6db74>&#34;cleanup&#34;</span> SIGINT SIGTERM EXIT

<span style=color:#75715e># Download the samples.</span>
curl --fail --compressed -q -s <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>source<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> -o <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>tmp_tar<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>

<span style=color:#75715e># Extract the samples.</span>
tar -xzf <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>tmp_tar<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> -C <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>tmp_dir<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</code></pre></div><p>In this script we have defined a function called &lsquo;cleanup&rsquo;. We then use the <code>trap</code> command to ensure that we call the function if <code>SIGINT</code> is sent, <code>SIGTERM</code> is sent or when the script exits. This is very useful in scripts that can take a while. This script downloads the effective shell samples from the internet. If the user is having connectivity issues then this might take a while and they may end up aborting the script. If they do so in this case we will still clean up the temporary folder we created.</p><p>Traps provide a very convenient way to handle things like cleanup, provide more diagnostic information or even disable a user from interrupting your script. In the example below we force the user to press Ctrl+C twice if they want to interrupt the script:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>interrupt_count<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>
on_interrupt<span style=color:#f92672>(</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> $interrupt_count -lt <span style=color:#ae81ff>1</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
        echo <span style=color:#e6db74>&#34;Aborting this operation can cause errors.&#34;</span>
        echo <span style=color:#e6db74>&#34;Press Ctrl+C again if you are sure you want to cancel.&#34;</span>
        interrupt_count<span style=color:#f92672>=</span><span style=color:#66d9ef>$((</span>interrupt_count <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span><span style=color:#66d9ef>))</span>
    <span style=color:#66d9ef>else</span>
        <span style=color:#75715e># Convention is to use the status code 130 for interrupted scripts.</span>
        echo <span style=color:#e6db74>&#34;Aborting long operation&#34;</span>
        exit <span style=color:#ae81ff>130</span>
    <span style=color:#66d9ef>fi</span>
<span style=color:#f92672>}</span>

trap on_interrupt SIGINT

total_time<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>
<span style=color:#66d9ef>while</span> true; <span style=color:#66d9ef>do</span>
    echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Long operation: </span><span style=color:#e6db74>${</span>total_time<span style=color:#e6db74>}</span><span style=color:#e6db74> seconds elapsed</span><span style=color:#e6db74>&#34;</span>
    sleep <span style=color:#ae81ff>3</span>
    total_time<span style=color:#f92672>=</span><span style=color:#66d9ef>$((</span>total_time <span style=color:#f92672>+</span> <span style=color:#ae81ff>3</span><span style=color:#66d9ef>))</span>
<span style=color:#66d9ef>done</span>
</code></pre></div><p>If we run this script we can see that the user must press Ctrl+C twice to abort the operation:</p><pre><code>$ ~/effective-shell/scripts/long-operation.sh
Long operation: 0 seconds elapsed
Long operation: 3 seconds elapsed
Long operation: 6 seconds elapsed
^CAborting this operation can cause errors.
Press Ctrl+C again if you are sure you want to cancel.
Long operation: 9 seconds elapsed
Long operation: 12 seconds elapsed
^CAborting long operation
</code></pre><p>Some other things that you might want to be aware of for the trap command are:</p><ul><li>The <code>SIG</code> at the beginning of the name of a signal is optional, and a signal number can also be used - this means that <code>SIGINT</code>, <code>INT</code> and <code>2</code> are all equivalent options for <code>trap</code></li><li>You can list the signals available with <code>trap -l</code> or <code>kill -l</code> - but remember that special conditions such as <code>EXIT</code> and <code>RETURN</code> are not listed, you can find these with <code>help trap</code></li><li>You can stop a signal from being processed with <code>trap "" SIGINT</code> - this means that no command will be executed when we receive a <code>SIGINT</code></li><li>You can reset a trap by running <code>trap - SIGINT</code>, this will remove any trap handler</li><li>You can test your traps by sending a signal explicitly to your script with <code>kill -s SIGINT</code>, providing the name of the signal</li></ul><h1 id=case-statements>Case Statements</h1><p>If you find yourself writing overly complex &lsquo;if statements&rsquo;, you might use a _case statement_ to simplify your code.</p><p>A case statement is a bit like an &lsquo;if statement&rsquo;. The structure is as follows:</p><pre><code>case &lt;expression&gt; in
    pattern1)
        &lt;pattern1-commands&gt;
        ;;
    pattern2 | pattern3)
        &lt;pattern2and3-commands&gt;
        ;;
    *)
        &lt;default-commands&gt;
        ;;
esac
</code></pre><p>Typically you will provide the &lsquo;case&rsquo; statement a variable and use it to check against a number of values. Here's a common example you'll see - checking to see whether a response is &lsquo;yes&rsquo; or &lsquo;no&rsquo;:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>read -p <span style=color:#e6db74>&#34;Yes or no: &#34;</span> response
<span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>response<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> in
    y | Y | yes | ok<span style=color:#f92672>)</span>
        echo <span style=color:#e6db74>&#34;You have confirmed&#34;</span>
        ;;
    n | N | no<span style=color:#f92672>)</span>
        echo <span style=color:#e6db74>&#34;You have denied&#34;</span>
        ;;
    *<span style=color:#f92672>)</span>
        echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>${</span>response<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39; is not a valid response</span><span style=color:#e6db74>&#34;</span>
        ;;
<span style=color:#66d9ef>esac</span>
</code></pre></div><p>The example above shows very simple text patterns, but any text pattern can be used:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>read -p <span style=color:#e6db74>&#34;Yes or no: &#34;</span> response
<span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>response<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> in
    <span style=color:#f92672>[</span>yY<span style=color:#f92672>]</span>*<span style=color:#f92672>)</span>
        echo <span style=color:#e6db74>&#34;You have (probably) confirmed&#34;</span>
        ;;
    <span style=color:#f92672>[</span>nN<span style=color:#f92672>]</span>*<span style=color:#f92672>)</span>
        echo <span style=color:#e6db74>&#34;You have (probably) denied&#34;</span>
        ;;
    *<span style=color:#f92672>)</span>
        echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>${</span>response<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39; is not a valid response</span><span style=color:#e6db74>&#34;</span>
    ;;
<span style=color:#66d9ef>esac</span>
</code></pre></div><p>In this example the first pattern is <code>[yY]*</code> which means either the &lsquo;y&rsquo; or &lsquo;Y&rsquo; character followed by zero or more characters, this will match things like &lsquo;yes&rsquo; &lsquo;YES&rsquo; or &lsquo;yay&rsquo;. We have a similar pattern for the negative response.</p><p>The case statement can look quite complex, I often think that even if it takes more lines to write the logic using &lsquo;if statements&rsquo; it will be more readable, but this is common pattern nonetheless and good to know about!</p><h1 id=handling-options>Handling Options</h1><p>You can use the <code>getopts</code> (<em>parse option arguments</em>) command to process the arguments for a script or function</p><p>Let's imagine we wanted to update our &lsquo;common&rsquo; command to support the following options:</p><ul><li><code>-h</code> for &lsquo;help&rsquo;, which shows command help</li><li><code>-e</code> for &lsquo;execute&rsquo;, which takes the number of a command from the list which will be executed</li></ul><p>The &lsquo;getopts&rsquo; command takes two parameters. The first is an &lsquo;option string&rsquo;, which is a list of the parameter letters that are allowed. This string starts with a colon, and any letter which is followed by a colon is expected to have a value provided. The second parameter is the name of the variable to set when we are processing options.</p><p>Typically this command is used in a while loop, as it will return &lsquo;success&rsquo; until the final option has been processed. A case statement is typically used to process the option:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># Helper function to show how the command should be invoked.</span>
show_help<span style=color:#f92672>(</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    echo <span style=color:#e6db74>&#34;usage:&#34;</span>
    echo <span style=color:#e6db74>&#34;  common [-h] [-e &lt;command_number&gt;] count&#34;</span>
<span style=color:#f92672>}</span>

<span style=color:#75715e># Process the options.</span>
<span style=color:#66d9ef>while</span> getopts <span style=color:#e6db74>&#34;:he:&#34;</span> option; <span style=color:#66d9ef>do</span>
    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>${</span>option<span style=color:#e6db74>}</span> in

        <span style=color:#75715e># Handle the &#39;help&#39; option.</span>
        h <span style=color:#f92672>)</span>
            show_help
            exit <span style=color:#ae81ff>0</span>
            ;;

        <span style=color:#75715e># Handle the &#39;execute command&#39; option by storing the value provided</span>
        <span style=color:#75715e># for the option.</span>
        e <span style=color:#f92672>)</span>
            execute_command<span style=color:#f92672>=</span><span style=color:#e6db74>${</span>OPTARG<span style=color:#e6db74>}</span>
            ;;

        <span style=color:#75715e># If we have an invalid argument, warn and fail.</span>
        <span style=color:#ae81ff>\?</span> <span style=color:#f92672>)</span>
            echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>The value &#39;</span><span style=color:#e6db74>${</span>OPTARG<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39; is not a valid option</span><span style=color:#e6db74>&#34;</span>
            exit <span style=color:#ae81ff>1</span>
            ;;

        <span style=color:#75715e># If we are missing a required argument, warn and exit.</span>
        : <span style=color:#f92672>)</span>
            echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>The option &#39;</span><span style=color:#e6db74>${</span>OPTARG<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39; requires an argument</span><span style=color:#e6db74>&#34;</span>
            ;;
    <span style=color:#66d9ef>esac</span>
<span style=color:#66d9ef>done</span>
</code></pre></div><p>There are a few things to point out from this script:</p><ul><li>The option string starts with a colon - any option letter that is followed by a colon expects an argument</li><li>If an invalid option letter is set, the value of the option variable is set to <code>\?</code> - we can then handle this in our case statement</li><li>If a letter is provided without an argument that is required, the value of the option variable is set to <code>:</code> - we can then handle this in our case statement</li></ul><p>For complex option processing you might see scripts where multiple loops are used to process sets of options. It is common to end option processing with the following line:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>shift <span style=color:#66d9ef>$((</span>OPTIND <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span><span style=color:#66d9ef>))</span>
</code></pre></div><p>The <code>${OPTIND}</code> variable stores the index of the last option processed. By shifting by this value minus one, we remove the processed options from the <code>$@</code> (all parameters) array. This means we don't try to process the same options again.</p><p>The <em>~/effective-shell/scripts/common.sh</em> script processes parameters using the <code>getopts</code> command. You can use this as an example to help you with your own scripts.</p><h1 id=colouring-output>Colouring Output</h1><p>There are special escape sequences that can be used in the shell to colour the output of the text shown. For example, in many terminals the following text will be shown in green:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>green<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;\e[0;32m&#39;</span>
reset<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;\e[0m&#39;</span>
echo -e <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Do you like </span><span style=color:#e6db74>${</span>green<span style=color:#e6db74>}</span><span style=color:#e6db74>apples</span><span style=color:#e6db74>${</span>reset<span style=color:#e6db74>}</span><span style=color:#e6db74>?</span><span style=color:#e6db74>&#34;</span>
</code></pre></div><p>On most terminals you will see the text below, with the word &lsquo;apples&rsquo; rendered in green:</p><pre><code>Do you like apples?
</code></pre><p>Note that it is important to provide the <code>-e</code> flag to the &lsquo;echo&rsquo; command so that it correctly processes the colour codes. In fact, a better option is to use the <code>printf</code> (<em>format and print arguments</em>) command, as it is more portable and behaves more consistently across different versions of Unix and Linux.</p><p>The colour codes are ANSI escape sequences that have been defined to control the formatting of content in a terminal. There are number of formatting options - such as foreground and background colours, bold, underline and so on. These codes can be quickly found online if you search for &ldquo;ANSI color codes&rdquo;.</p><p>It is important to be careful when using colour codes - you don't want them in all circumstances. Let&rsquo; see an example. The &lsquo;rainbow&rsquo; function below writes out a message in a number of colours:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>rainbow <span style=color:#f92672>(</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    local message<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$1<span style=color:#e6db74>&#34;</span>
    local reset<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;\e[0m&#39;</span>
    <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#f92672>(</span>colour<span style=color:#f92672>=</span>31; colour&lt;<span style=color:#f92672>=</span>37; colour++<span style=color:#f92672>)</span><span style=color:#f92672>)</span>
    <span style=color:#66d9ef>do</span>
        colour_code<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>\\e[0;</span><span style=color:#e6db74>${</span>colour<span style=color:#e6db74>}</span><span style=color:#e6db74>m</span><span style=color:#e6db74>&#34;</span>
        printf <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>colour<span style=color:#e6db74>}</span><span style=color:#e6db74> - </span><span style=color:#e6db74>${</span>colour_code<span style=color:#e6db74>}</span><span style=color:#e6db74>${</span>message<span style=color:#e6db74>}</span><span style=color:#e6db74>${</span>reset<span style=color:#e6db74>}</span><span style=color:#e6db74>\n</span><span style=color:#e6db74>&#34;</span>
    <span style=color:#66d9ef>done</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>If we run this function in most terminals, we'll see the provided message with the colour number in seven different colours:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ rainbow hello
<span style=color:#ae81ff>31</span> - test
<span style=color:#ae81ff>32</span> - test
<span style=color:#ae81ff>33</span> - test
<span style=color:#ae81ff>34</span> - test
<span style=color:#ae81ff>35</span> - test
<span style=color:#ae81ff>36</span> - test
<span style=color:#ae81ff>37</span> - test
</code></pre></div><p>We have to be careful when formatting output. It can be helpful for a user in an interactive shell (on many systems for example even the <code>ls</code> command is actually an alias for <code>ls --color=auto</code> meaning that the <code>ls</code> command uses colours in its output). But there are circumstance when we don't want to use colour codes. Let's see what we get when we write the <code>rainbow</code> output to a file:</p><pre><code>$ rainbow hello &gt;&gt; text.txt
$ cat -v text.txt
31 - ^[[0;31mhello^[[0m
32 - ^[[0;32mhello^[[0m
33 - ^[[0;33mhello^[[0m
34 - ^[[0;34mhello^[[0m
35 - ^[[0;35mhello^[[0m
36 - ^[[0;36mhello^[[0m
37 - ^[[0;37mhello^[[0m
</code></pre><p>The &lsquo;-v&rsquo; parameter tells <code>cat</code> to make escape characters visible. If you open the in a text editor you will see the same escape characters written in the file.</p><p>This shows the problem with the <code>rainbow</code> function - it adds the colour escape sequences even when we are writing the results to a file. In most cases this is <em>not</em> going to be what we want. Commands like <code>ls</code> do not include colour codes when writing to a file.</p><p>There is not an entirely fool-proof way to avoid this issue, but the most common pattern I have seen is to check whether the standard output file descriptor is associated with a terminal. We can do this using the <code>-t</code> expression of the <code>test</code> command:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -t <span style=color:#ae81ff>1</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
    echo <span style=color:#e6db74>&#34;We are writing to a terminal&#34;</span>
<span style=color:#66d9ef>else</span>
    echo <span style=color:#e6db74>&#34;We are not writing to a terminal&#34;</span>
<span style=color:#66d9ef>fi</span>
</code></pre></div><p>You will see <code>-t 1</code> in a number of scripts as a way to check whether the output is going to a terminal device. The <code>-t</code> test returns success if the provided file descriptor is associated with a terminal device. The file descriptor &lsquo;1&rsquo; is the descriptor for the <em>stdout</em> stream (if this is unfamiliar, check <a href=/docs/part-2-core-skills/thinking-in-pipelines/>Chapter 7 - Thinking in Pipelines</a>).</p><p>Here's how we could use the test in our rainbow function:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>rainbow <span style=color:#f92672>(</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    local message<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$1<span style=color:#e6db74>&#34;</span>
    local reset<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;\e[0m&#39;</span>
    <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#f92672>(</span>colour<span style=color:#f92672>=</span>31; colour&lt;<span style=color:#f92672>=</span>37; colour++<span style=color:#f92672>)</span><span style=color:#f92672>)</span>
    <span style=color:#66d9ef>do</span>
        colour_code<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>\\e[0;</span><span style=color:#e6db74>${</span>colour<span style=color:#e6db74>}</span><span style=color:#e6db74>m</span><span style=color:#e6db74>&#34;</span>
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -t <span style=color:#ae81ff>1</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
            printf <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>colour<span style=color:#e6db74>}</span><span style=color:#e6db74> - </span><span style=color:#e6db74>${</span>colour_code<span style=color:#e6db74>}</span><span style=color:#e6db74>${</span>message<span style=color:#e6db74>}</span><span style=color:#e6db74>${</span>reset<span style=color:#e6db74>}</span><span style=color:#e6db74>\n</span><span style=color:#e6db74>&#34;</span>
        <span style=color:#66d9ef>else</span>
            printf <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>colour<span style=color:#e6db74>}</span><span style=color:#e6db74> - </span><span style=color:#e6db74>${</span>message<span style=color:#e6db74>}</span><span style=color:#e6db74>\n</span><span style=color:#e6db74>&#34;</span>
        <span style=color:#66d9ef>fi</span>
    <span style=color:#66d9ef>done</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>This version of the function will not write the ANSI escape sequences if the output device is not a terminal, meaning that if we run:</p><pre><code>$ rainbow test &gt; text.txt
</code></pre><p>Then the output file will not contain escape sequences. You can find out more about the <code>-t</code> test by running <code>man test</code>.</p><p>As a final tip - if you are formatting output you should consider using the <code>tput</code> (<em>query terminfo database</em>) command to make your code more readable and portable:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>green<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>tput setaf 2<span style=color:#66d9ef>)</span> <span style=color:#75715e># set ansi foreground to &#39;2&#39; (green)</span>
reset<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>tput sgr0<span style=color:#66d9ef>)</span>    <span style=color:#75715e># reset the colours</span>
echo -e <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Do you like </span><span style=color:#e6db74>${</span>green<span style=color:#e6db74>}</span><span style=color:#e6db74>apples</span><span style=color:#e6db74>${</span>reset<span style=color:#e6db74>}</span><span style=color:#e6db74>?</span><span style=color:#e6db74>&#34;</span>
</code></pre></div><p>The &lsquo;tput&rsquo; command is quite advanced, but you can search online for more details (the manual pages for the command are hard to decipher as it can be used for many operations and is complex).</p><p>The <em>~/effective-shell/scripts/common.sh</em> script includes colourised output and also checks to see whether colour codes should be printed based - you can use this as a reference for your own scripts.</p><h1 id=checking-the-operating-system>Checking the Operating System</h1><p>Different flavours of Unix and Linux can behave quite differently. A common requirement is to write scripts that are portable and can be used across systems. However, this is not always possible. There are times when we need to check to see whether we are on a specific operating system and take a specific action.</p><p>You will often see the <code>uname</code> (<em>show operating system name</em>) command used to check the operating system:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>uname<span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span> in
    Darwin<span style=color:#f92672>)</span>
        os<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;OSX&#34;</span>
        ;;

    Linux<span style=color:#f92672>)</span>
        os<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Linux&#34;</span>
        ;;

    CYGWIN*|MINGW32*|MSYS*|MINGW*<span style=color:#f92672>)</span>
        os<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Windows&#34;</span>
        ;;

    SunOS<span style=color:#f92672>)</span>
        os<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Solaris&#34;</span>
        ;;

    *<span style=color:#f92672>)</span>
        echo <span style=color:#e6db74>&#34;Unsupported operating system&#34;</span>
        exit <span style=color:#ae81ff>1</span>
        ;;
<span style=color:#66d9ef>esac</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Your OS is: </span><span style=color:#e6db74>${</span>os<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</code></pre></div><p>The <em>~/effective-shell/scripts/common.sh</em> script checks to see whether the operating system is OSX and if so, temporarily aliases the text commands such as <code>sed</code> to their GNU equivalent, as the OSX versions of the commands are based on BSD so have slightly different parameters. You can use this script as an example of how to deal with OSX in shell scripts that are designed to be used on Linux as well as OSX.</p><h1 id=checking-for-installed-programs>Checking for Installed Programs</h1><p>As we saw in <a href=/docs/part-2-core-skills/understanding-commands/>Chapter 10 - Understanding Commands</a> there are many different ways to determine whether a command is available. The most correct and portable way to test to see whether a command is available is to use the <code>command -v</code> command as shown below:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#66d9ef>if</span> ! command -v <span style=color:#e6db74>&#34;curl&#34;</span> &gt;/dev/null 2&gt;&amp;1; <span style=color:#66d9ef>then</span>
    echo <span style=color:#e6db74>&#34;&#39;curl&#39; is not installed, please install and try again&#34;</span>
<span style=color:#66d9ef>fi</span>
</code></pre></div><p>Note that when we're using the <code>command</code> command, we silence error output and standard output. This is required because otherwise we would see an error message written to the screen if the command doesn't exit or would see the details of the command if it does exist.</p><p>The <em>~/effective-shell/scripts/common.sh</em> script checks to see whether certain GNU versions of tools are installed when running on OSX. You can refer to this script for an example of checking for the presence of commands.</p><h1 id=anti-patterns>Anti-Patterns</h1><p>Anti-patterns are techniques that you may see but should be avoided. I have noted a few here as you will likely see them in your travels and should know why they are problematic.</p><h2 id=configuring-options-in-shebangs>Configuring Options in Shebangs</h2><p>You will sometimes see shebangs in shell scripts that contain options, like so:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e>#!/usr/bin/bash -ex
</span><span style=color:#75715e></span>
<span style=color:#75715e># Script contents below...</span>
</code></pre></div><p>It is possible to specify the arguments to the program that is used to execute the script in the shebang. In the case above, the <code>-ex</code> flags are passed to the <code>bash</code> program, enabling the &lsquo;exit on error&rsquo; and &lsquo;trace&rsquo; options.</p><p>I include this pattern because it is possible you will see it in other scripts, but please do not do this. There are a two particular reasons that it is risky.</p><p>The first is that pattern requires that you know the path to the shell. As we saw in <a href=/docs/part-4-shell-scripting/shell-script-essentials/>Chapter 18 - Shell Script Essentials</a>, we should use the <code>#!/usr/bin/env</code> program so that we search the <code>$PATH</code> for the shell rather than assuming that we know the location of the shell program.</p><p>The second reason is that multiple parameters are not handled consistently across operating systems. For example, on some Unix systems the following shebang will run <code>bash</code> with the <code>-e</code> parameter:</p><pre><code>#!/usr/bin/env bash -e
</code></pre><p>However, on many Unix distributions only one parameter is passed. This would mean that the <code>-e</code> parameter would be silently ignored, which would be very confusing for the reader.</p><h1 id=summary>Summary</h1><p>In this chapter we saw an assortment of common patterns that can be useful when building shell scripts. In the next part of the book we're going to look at how you can customise your shell and environment to build your own toolkit!</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>The value shown before each trace line can be configured by setting the <code>$PS4</code> variable. <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></article><div class="book-footer justify-between"><div><a class="flex align-center" href=https://github.com/dwmkerr/effective-shell/commit/d985ac8a2967da5d80fa2fe98dea033b9da5d16a title="Last modified by Dave Kerr | Jun 2, 2021" target=_blank><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>Jun 2, 2021</span></a></div><div><a class="flex align-center" href=https://github.com/dwmkerr/effective-shell/edit/master/website/content/docs/part-4-shell-scripting/useful-patterns-for-shell-scripts/_index.md target=_blank><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"effective-shell"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><p>Copyright &copy; <script>document.write(new Date().getFullYear())</script>, Dave Kerr</p></div><aside class="book-toc levels-3 fixed"><nav id=TableOfContents><ul><li><a href=#chapter-23---useful-patterns-for-shell-scripts>Chapter 23 - Useful Patterns for Shell Scripts</a></li><li><a href=#debugging-shell-scripts>Debugging Shell Scripts</a></li><li><a href=#checking-for-existing-variables-or-functions>Checking for Existing Variables or Functions</a></li><li><a href=#unsetting-values>Unsetting Values</a></li><li><a href=#traps>Traps</a></li><li><a href=#case-statements>Case Statements</a></li><li><a href=#handling-options>Handling Options</a></li><li><a href=#colouring-output>Colouring Output</a></li><li><a href=#checking-the-operating-system>Checking the Operating System</a></li><li><a href=#checking-for-installed-programs>Checking for Installed Programs</a></li><li><a href=#anti-patterns>Anti-Patterns</a><ul><li><a href=#configuring-options-in-shebangs>Configuring Options in Shebangs</a></li></ul></li><li><a href=#summary>Summary</a></li></ul></nav></aside></main></body></html>