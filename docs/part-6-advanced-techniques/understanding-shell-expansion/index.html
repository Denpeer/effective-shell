<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Understanding Shell Expansion"><meta property="og:title" content="Understanding Shell Expansion"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://effective-shell.com/docs/part-6-advanced-techniques/understanding-shell-expansion/"><title>Understanding Shell Expansion | Effective Shell</title><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.f8520695a602b532b093067e25561bfe6fa10ca8c25171b97142acf58fa8f13c.css integrity="sha256-+FIGlaYCtTKwkwZ+JVYb/m+hDKjCUXG5cUKs9Y+o8Tw="><script defer src=/en.search.min.901d4b22032222a6f8db08efa32b2ce89f2b7affb9b504a133dbe52ece751a89.js integrity="sha256-kB1LIgMiIqb42wjvoyss6J8rev+5tQShM9vlLs51Gok="></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-155335600-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><link rel=alternate type=application/rss+xml href=https://effective-shell.com/docs/part-6-advanced-techniques/understanding-shell-expansion/index.xml title="Effective Shell"><script id=mcjs>!function(c,h,i,m,p){m=c.createElement(h),p=c.getElementsByTagName(h)[0],m.async=1,m.src=i,p.parentNode.insertBefore(m,p)}(document,"script","https://chimpstatic.com/mcjs-connected/js/users/eac1a082b6db34d40aaff2caf/a2aaca5a8358c2e12d3f43f1a.js");</script></head><body><input type=checkbox class=hidden id=menu-control><main class="flex container"><aside class="book-menu fixed"><nav><h2 class=book-brand><a href=https://effective-shell.com/><span>Effective Shell</span></a></h2><h2 class=book-subtitle><span>By Dave Kerr</span></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/docs/introduction/><strong>Introduction</strong></a></li><li><a href=/docs/getting-started/><strong>Getting Started</strong></a></li><li><a href=/docs/part-1-transitioning-to-the-shell/><strong>Part 1 - Transitioning to the Shell</strong></a><ul><li><a href=/docs/part-1-transitioning-to-the-shell/navigating-your-system/>Navigating Your System</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/managing-your-files/>Managing Your Files</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/clipboard-gymnastics/>Clipboard Gymnastics</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/getting-help/>Getting Help</a></li><li><a href=/docs/part-1-transitioning-to-the-shell/the-renaissance-of-the-shell/>The Renaissance of the Shell</a></li></ul></li><li><a href=/docs/part-2-core-skills/><strong>Part 2 - Core Skills</strong></a><ul><li><a href=/docs/part-2-core-skills/thinking-in-pipelines/>Thinking in Pipelines</a></li><li><a href=/docs/part-2-core-skills/fly-on-the-command-line/>Fly on the Command Line</a></li><li><a href=/docs/part-2-core-skills/job-control/>Job Control</a></li><li><a href=/docs/part-2-core-skills/understanding-commands/>Understanding Commands</a></li><li><a href=/docs/part-2-core-skills/finding-files/>Finding Files</a></li><li><a href=/docs/part-2-core-skills/what-is-a-shell/>What is a Shell?</a></li></ul></li><li><a href=/docs/part-3-manipulating-text/><strong>Part 3 - Manipulating Text</strong></a><ul><li><a href=/docs/part-3-manipulating-text/regex-essentials/>Regex Essentials</a></li><li><a href=/docs/part-3-manipulating-text/get-to-grips-with-grep/>Get to Grips with Grep</a></li><li><a href=/docs/part-3-manipulating-text/slice-and-dice-text/>Slice and Dice Text</a></li><li><a href=/docs/part-3-manipulating-text/advanced-text-manipulation/>Advanced Text Manipulation with Sed</a></li><li><a href=/docs/part-3-manipulating-text/build-commands-on-the-fly/>Build Commands on the Fly with Xargs</a></li></ul></li><li><a href=/docs/part-4-shell-scripting/><strong>Part 4 - Shell Scripting</strong></a><ul><li><a href=/docs/part-4-shell-scripting/shell-script-essentials/>Shell Script Essentials</a></li><li><a href=/docs/part-4-shell-scripting/variables-reading-input-and-mathematics/>Variables, Reading Input, and Mathematics</a></li><li><a href=/docs/part-4-shell-scripting/mastering-conditional-logic/>Mastering Conditional Logic</a></li><li><a href=/docs/part-4-shell-scripting/loops-and-working-with-files-and-folders/>Loops and working with Files and Folders</a></li><li><a href=/docs/part-4-shell-scripting/functions-parameters-and-error-handling/>Functions, Parameters and Error Handling</a></li><li><a href=/docs/part-4-shell-scripting/useful-patterns-for-shell-scripts/>Useful Patterns for Shell Scripts</a></li></ul></li><li><a href=/docs/part-5-building-your-toolkit/><strong>Part 5 - Building Your Toolkit</strong></a><ul><li><a href=/docs/part-5-building-your-toolkit/configuring-the-shell/>Configuring the Shell</a></li><li><a href=/docs/part-5-building-your-toolkit/customising-your-command-prompt/>Customising Your Command Prompt</a></li><li><a href=/docs/part-5-building-your-toolkit/managing-your-dotfiles/>Managing Your Dotfiles</a></li><li><a href=/docs/part-5-building-your-toolkit/controlling-changes-with-git/>Controlling Changes with Git</a></li><li><a href=/docs/part-5-building-your-toolkit/managing-remote-git-repositories/>Managing Remote Git Repositories and Sharing Your Dotfiles</a></li></ul></li><li><a href=/docs/part-6-advanced-techniques/><strong>Part 6 - Advanced Techniques</strong></a><ul><li><a href=/docs/part-6-advanced-techniques/understanding-shell-expansion/ class=active>Understanding Shell Expansion</a></li></ul></li><li><a href=/docs/work-in-progress/><strong>Work in Progress</strong></a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class="flex align-center justify-between book-header"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Understanding Shell Expansion</strong></header><article class=markdown><h1 id=chapter-29---understanding-shell-expansion>Chapter 29 - Understanding Shell Expansion</h1><p>When you are working with the shell there are a number of techniques that you can use to take simple commands and make more useful. For example, if we wanted to create three files, we could run <code>touch file1 file2 file3</code>, or we could use &lsquo;brace expansion&rsquo; and just run <code>touch file{1..3}</code>. Another example would be to delete all files that have names that start with <code>file</code> - like this <code>rm file*</code>, this is wildcard expansion.</p><p>Collectively, these features are called &lsquo;Shell Expansion&rsquo;. I think that introducing the entire set of features that make up shell expansion in one go can be a bit overwhelming, but now that we are in the advanced chapters it makes sense to understand exactly what shell expansion is, when it occurs, when it doesn't and how understanding it can make you a more effective user.</p><p>There are seven types of expansion that occur in the shell - in this chapter we'll look at each in detail and then see how they work together.</p><h1 id=what-is-shell-expansion>What is Shell Expansion?</h1><p>When the shell receives a command, either from the user typing at the keyboard, or from a shell script, it breaks it up into words. After this happens, the shell performs seven operations on the words, which can change how they are interpreted. These seven operations are collectively known as &lsquo;shell expansion&rsquo;. You are probably familiar with most of them as we have used them throughout this book.</p><p>The seven operations that the shell performs are:</p><ol><li>Brace Expansion - expanding values between braces, such as <code>file{1..3}</code> into <code>file1 file2 file3</code></li><li>Tilde Expansion - expanding the <code>~</code> tilde symbol for the home directory into the path to the home directory, such as <code>~/effective-shell</code> into <code>/home/dwmkerr/effective-shell</code></li><li>Parameter Expansion - expanding terms that start with a <code>$</code> symbol into parameter values, such as <code>$HOME</code> into the value of the variable named <code>HOME</code></li><li>Command Substitution - evaluation of the contents of <code>$(command)</code> sequences, which are used to run commands and return the results to the shell command line</li><li>Arithmetic Expansion - evaluation of the contents of <code>$((expression))</code> sequences, which are used to perform basic mathematical operations</li><li>Word Splitting - once all of the previous operations are run, the shell splits the command up into &lsquo;words&rsquo;, which are the units of text that you can run loops over</li><li>Pathname Expansion - the shell expands wildcards and special characters in pathnames, such as <code>file*.txt</code> into the set of files that are matched by the sequence</li></ol><p>If you want to see each of these operations in the manual, you can run <code>man bash</code> and search for the text <code>^EXPANSION</code>. Now let's see how each operation works in more detail.</p><h1 id=shell-expansion>Shell Expansion</h1><p>Let's take a look through each of the forms of shell expansion that are available to use.</p><h2 id=brace-expansion>Brace Expansion</h2><p>Brace expansion is the first shell expansion operation that occurs, it expands a simple expression that represents a sequence or range of characters.</p><p>In the examples below I'll show the expression on the first line and then what it expands to on the second line. The first example expands a set words or characters:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>mkdir /tmp/<span style=color:#f92672>{</span>one,two,three<span style=color:#f92672>}</span>

<span style=color:#75715e># The line above is expanded to:</span>
mdkir /tmp/one /tmp/two /tmp/three
</code></pre></div><p>Expansions of sets like this are a great way to perform operations that work on multiple files or folders at once.</p><p>We can also create sequences of numbers or characters:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>touch file<span style=color:#f92672>{</span>1..5<span style=color:#f92672>}</span>.txt

<span style=color:#75715e># The line above is expanded to:</span>
touch file1.txt file2.txt file3.txt file4.txt file5.txt
</code></pre></div><p>You as well as specifying the start and end of a sequence, you can specify the increment, you might see this in for loops like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#66d9ef>for</span> x in <span style=color:#f92672>{</span>0..10..2<span style=color:#f92672>}</span>; <span style=color:#66d9ef>do</span> print $x; <span style=color:#66d9ef>done</span>

<span style=color:#75715e># The line above is expanded to:</span>
<span style=color:#66d9ef>for</span> x in <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>6</span> <span style=color:#ae81ff>8</span> 10; <span style=color:#66d9ef>do</span> print $x; <span style=color:#66d9ef>done</span>
</code></pre></div><h2 id=tilde-expansion>Tilde Expansion</h2><p>If a word starts with a <code>~</code> tilde character, then the shell will expand the tilde into the value of the <code>$HOME</code> variable:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>cd ~/effective-shell

<span style=color:#75715e># The line above is expanded to:</span>
cd $HOME/effective-shell
</code></pre></div><p>If we were to unset the <code>$HOME</code> variable, then the expansion would use the current user's home directory:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>unset HOME
cd ~/effective-shell

<span style=color:#75715e># The line above is expanded to:</span>
cd /home/dwmkerr/effective-shell
</code></pre></div><p>Tilde expansion is very simple!</p><h2 id=parameter-expansion>Parameter Expansion</h2><p>When the dollar symbol <code>$</code> is used, this indicates that the shell is going to perform <em>parameter expansion</em>, which expands variables or the parameters of a script. It can also be used to indicate <em>command substitution</em> or <em>arithmetic expansion</em> - which we will see once we've looked at parameter expansion.</p><p>A lot of these expansions are covered in detail in <a href=/docs/part-4-shell-scripting/variables-reading-input-and-mathematics/>Chapter 19 - Variables, Reading Input, and Mathematics</a> but I have included each of the available expansions here for reference.</p><p>In it's most simple form, parameter expansion simple replaces the name of a variable or parameter with its value:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>fruit<span style=color:#f92672>=</span>apples
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>I like </span>$fruit<span style=color:#e6db74>&#34;</span>

<span style=color:#75715e># The line above is expanded to:</span>
echo <span style=color:#e6db74>&#34;I like apples&#34;</span>
</code></pre></div><p>When using parameter expansion it is generally preferable to surround the name of the parameter with braces - this allows you to tell the shell unambiguously what the name of the parameter is. For example:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>My backup folder is: </span><span style=color:#e6db74>${</span>HOME<span style=color:#e6db74>}</span><span style=color:#e6db74>backup</span><span style=color:#e6db74>&#34;</span>

<span style=color:#75715e># The line above is expanded to:</span>
echo <span style=color:#e6db74>&#34;My backup folder is: /home/dwmkerrbackup&#34;</span>
</code></pre></div><p>If we had <em>not</em> used braces, then the shell would expand the expression like so:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>My backup folder is: </span>$HOMEbackup<span style=color:#e6db74>&#34;</span>

<span style=color:#75715e># The line above is expanded to:</span>
echo <span style=color:#e6db74>&#34;My backup folder is: &#34;</span>
</code></pre></div><p>The reason that the expansion doesn't work as expected in this case is that the shell is trying to expand a parameter with the name <code>HOMEbackup</code> - the braces used in the first example make it clear to the shell that the parameter name is <code>HOME</code> and that the text <code>backup</code> should be added at the end of the expanded value.</p><p>There are a number of additional features available for parameter expansion that can make it more convenient. Let's look at each of them now.</p><p><strong>Default Values</strong></p><p>The expression <code>${parameter:-default}</code> will expand to the value of the parameter named <code>parameter</code> - but if that value is not set, then the value <code>default</code> is used. This can be convenient if you want to provide a value for the shell to use when a parameter is not set.</p><p><strong>Assign Default Values</strong></p><p>The expression <code>${parameter:=default}</code> will expand to the value of the parameter named <code>parameter</code> - but if that value is not set, then the value <code>default</code> is used. In this case, <code>parameter</code> is also set to <code>default</code>. This means that this expression works just like the &lsquo;default values&rsquo; expression above, but also sets the parameter at the same time.</p><p><strong>Display Error if Null or Unset</strong></p><p>The expression <code>${parameter:?message}</code> tells the shell to expand to the value of <code>parameter</code>, and if that value is null or unset, to instead write the message <code>message</code> to standard error and exit (unless the shell is interactive, in which case the shell is not closed).</p><p>This can be a convenient way to put a &lsquo;guard&rsquo; in place to ensure that a script aborts if a value is not set. Here's an example of how this can be used:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>backup_location<span style=color:#f92672>=</span><span style=color:#e6db74>${</span>BACKUP_DIR:?Please set BACKUP_DIR to use this script<span style=color:#e6db74>}</span>
cp -r ~/effective-shell <span style=color:#e6db74>${</span>BACKUP_DIR<span style=color:#e6db74>}</span>
</code></pre></div><p>In this script we copy the <em>~/effective-shell</em> folder to the folder set in the <code>BACKUP_DIR</code> parameter. However, if that parameter has not been set then the script will abort and show an error message telling the operator that the <code>BACKUP_DIR</code> parameter must be set.</p><p><strong>Use Alternate Value</strong></p><p>The expression <code>${parameter:+alternate}</code> expands to an empty string if <code>parameter</code> is null or unset. However, if <code>parameter</code> <em>has</em> a value, then the value of <code>alternate</code> is used instead.</p><p><strong>Offset and Length</strong></p><p>You can tell the shell to expand only a subset of the value of a parameter by using the <code>${parameter:offset}</code> expression. In this case, the shell will expand the value of <code>parameter</code>, but skip <code>offset</code> number of characters from the beginning:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>My home folder name is: </span><span style=color:#e6db74>${</span>HOME:6<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>

<span style=color:#75715e># The line above is expanded to:</span>
echo <span style=color:#e6db74>&#34;My home folder name is: dwmkerr&#34;</span>
</code></pre></div><p>You can also specify how many characters should be used by providing a <code>length</code> value after the offset with the expression <code>${parameter:offset:length}</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>The error message is: </span><span style=color:#e6db74>${</span>error_message:0:64<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</code></pre></div><p>In the expression above, only up to the first 64 characters of the parameter <code>error_message</code> will be shown.</p><p>The offset and length values can also be used with arrays:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>days<span style=color:#f92672>=</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Monday&#34;</span> <span style=color:#e6db74>&#34;Tuesday&#34;</span> <span style=color:#e6db74>&#34;Wednesday&#34;</span> <span style=color:#e6db74>&#34;Thursday&#34;</span> <span style=color:#e6db74>&#34;Friday&#34;</span> <span style=color:#e6db74>&#34;Saturday&#34;</span> <span style=color:#e6db74>&#34;Sunday&#34;</span><span style=color:#f92672>)</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>days[@]:2:3<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>

<span style=color:#75715e># The line above is expanded to:</span>
echo <span style=color:#e6db74>&#34;Tuesday Wednesday Thursday&#34;</span>
</code></pre></div><p>It is important to note that when using this technique with arrays, you must specify the array name and then <code>[@]</code> after the array name, to indicate that you want to work with all of the members of the array. If you <em>don't</em> do this, the entire array is converted into a single string and the resulting string has the offset and length applied.</p><p><strong>Expand Variable Names</strong></p><p>The <code>${!name*}</code> expression evaluates to the <em>name</em> of every parameter that starts with the text <code>name</code>. You can use this expression to find the full set of parameters that match a certain pattern.</p><p>How might this be useful? One nice trick is to use it to tidy up scripts. For example, if you are writing a script and create a set of variables for internal use, you could use this expression to find the names of all of the variables you have created and clean them up:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>_es_download_folder<span style=color:#f92672>=</span>~/downloads
_es_backup_folder<span style=color:#f92672>=</span>~/backups
_es_download_address<span style=color:#f92672>=</span>https://effective-shell.com/downloads/effective-shell-samples.tar.gz

<span style=color:#75715e># At this point we might have a script that uses the variables above...</span>

<span style=color:#75715e># Now clean up any variables we created.</span>
<span style=color:#66d9ef>for</span> var_name in <span style=color:#e6db74>${</span>!_es_*<span style=color:#e6db74>}</span>
<span style=color:#66d9ef>do</span>
    echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Cleaning up: </span><span style=color:#e6db74>${</span>var_name<span style=color:#e6db74>}</span><span style=color:#e6db74>...</span><span style=color:#e6db74>&#34;</span>
    unset <span style=color:#e6db74>${</span>var_name<span style=color:#e6db74>}</span>
<span style=color:#66d9ef>done</span>
</code></pre></div><p>This is rather an advanced technique but it does show how the &lsquo;expand variable names&rsquo; expansion can be useful.</p><p><strong>Array Expansion</strong></p><p>This topic is covered in detail in Chapter 19. The expression <code>${!array[@}</code> expands to the indices (or &lsquo;keys&rsquo;) for each item in an array:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>days<span style=color:#f92672>=</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Monday&#34;</span> <span style=color:#e6db74>&#34;Tuesday&#34;</span> <span style=color:#e6db74>&#34;Wednesday&#34;</span> <span style=color:#e6db74>&#34;Thursday&#34;</span> <span style=color:#e6db74>&#34;Friday&#34;</span> <span style=color:#e6db74>&#34;Saturday&#34;</span> <span style=color:#e6db74>&#34;Sunday&#34;</span><span style=color:#f92672>)</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>!days[@]<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>

<span style=color:#75715e># The line above is expanded to:</span>
echo <span style=color:#e6db74>&#34;0 1 2 3 4 5 6&#34;</span>
</code></pre></div><p>This expansion is convenient if you do not know the keys that make up an array and want to loop through them.</p><p><strong>Parameter Length</strong></p><p>The <code>${#parameter}</code> expression expands to the length of the value in the parameter named <code>parameter</code>.</p><p>You can also use this expression to find the length of an array - just add the <code>[@]</code> subscript like so <code>${#array[@]}</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>days<span style=color:#f92672>=</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Monday&#34;</span> <span style=color:#e6db74>&#34;Tuesday&#34;</span> <span style=color:#e6db74>&#34;Wednesday&#34;</span> <span style=color:#e6db74>&#34;Thursday&#34;</span> <span style=color:#e6db74>&#34;Friday&#34;</span> <span style=color:#e6db74>&#34;Saturday&#34;</span> <span style=color:#e6db74>&#34;Sunday&#34;</span><span style=color:#f92672>)</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>There are </span><span style=color:#e6db74>${#</span>days[@]<span style=color:#e6db74>}</span><span style=color:#e6db74> days in the array</span><span style=color:#e6db74>&#34;</span>

<span style=color:#75715e># The line above is expanded to:</span>
echo <span style=color:#e6db74>&#34;There are 7 days in the array&#34;</span>
</code></pre></div><p>You may have noticed at pattern by this point - many of the expansions that can be performed on a parameter can <em>also</em> be performed on an array, just by adding the <code>[@]</code> subscript to the parameter name. Think of this subscript as saying &lsquo;all of the array members&rsquo; - without it the shell combines all of the array members into a single string and performs the substitution on the result.</p><p><strong>Remove Pattern from Front</strong></p><p>You can use the <code>${parameter#pattern}</code> expression to expand the value of <code>parameter</code>, removing <code>pattern</code> from the front of the value:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>address<span style=color:#f92672>=</span>https://effective-shell.com
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Address: </span><span style=color:#e6db74>${</span>address#https://<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>

<span style=color:#75715e># The line above is expanded to:</span>
echo <span style=color:#e6db74>&#34;Address: effective-shell.com&#34;</span>
</code></pre></div><p>You can also tell the shell to remove as many sequential matches of <code>pattern</code> as possible, by using the <code>${parameter##pattern}</code> expression. This can be useful to strip out all of the characters up to a certain point in a parameter:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>folder<span style=color:#f92672>=</span>/home/dwmkerr/backups/2021-10-19
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Today&#39;s backup folder is: </span><span style=color:#e6db74>${</span>folder##*/<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>

<span style=color:#75715e># The line above is expanded to:</span>
echo <span style=color:#e6db74>&#34;Today&#39;s backup folder is: 2021-10-19&#34;</span>
</code></pre></div><p>Notice that in this example we are using an asterisk <code>*</code> symbol in the pattern, telling the shell to strip as many possible characters from the beginning of the parameter up until the final forward-slash <code>/</code> is found.</p><p><strong>Remove Pattern from Back</strong></p><p>The <code>${parameter%pattern}</code> expression works exactly like the expression above, but removes text from the <em>end</em> of a parameter:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>My working directory is: </span><span style=color:#e6db74>${</span>PWD<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>My parent folder is: </span><span style=color:#e6db74>${</span>PWD%/*<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>

<span style=color:#75715e># The lines above are expanded to:</span>
echo <span style=color:#e6db74>&#34;My working directory is: /home/dwmkerr/repos/github/dwmkerr/effective-shell&#34;</span>
echo <span style=color:#e6db74>&#34;My parent folder is: /home/dwmkerr/repos/github/dwmkerr&#34;</span>
</code></pre></div><p>In this example we used an asterisk <code>*</code> wildcard in the pattern to remove all of the text from the back of the parameter, up to and including the first forward-slash <code>/</code> symbol found.</p><p>We can also remove as many matches as possible, by using the expression <code>${parameter%%pattern}</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>archive<span style=color:#f92672>=</span>effective-shell.tar.gz
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Name of archive is: </span><span style=color:#e6db74>${</span>archive%%.*<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>

<span style=color:#75715e># The line above is expanded to:</span>
echo <span style=color:#e6db74>&#34;Name of archive is: effective-shell&#34;</span>
</code></pre></div><p>Notice that in this case the removal of the characters did not stop at the first period <code>.</code> symbol, it removed as many characters as possible until the <em>last</em> period <code>.</code> symbol was found.</p><p><strong>Pattern Replacement</strong></p><p>You can also replace a pattern in a parameter by using the expression <code>${parameter/pattern/string}</code>. This can be used to perform substitutions:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>message<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Hello Dave&#34;</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>message/Hello/Goodbye<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>

<span style=color:#75715e># The line above is expanded to:</span>
echo <span style=color:#e6db74>&#34;Goodbye Dave&#34;</span>
</code></pre></div><p>There are actually a number of options available for Pattern Replacement that can control things like the number of replacements that are performed and how arrays are treated. I would recommend not using overly complex replacements using these types of expressions though - instead use a command like <code>tr</code> or <code>sed</code> to make it very explicit what is going on - the built-in shell parameter replacement can be quite complex for the reader to parse and can also vary from shell to shell.</p><p>For suggestions on alternative ways to manipulate text check <a href=/docs/part-3-manipulating-text/slice-and-dice-text/>Chapter 15 - Slice and Dice Text</a> or <a href=/docs/part-3-manipulating-text/advanced-text-manipulation/>Chapter 16 - Advanced Text Manipulation with Sed</a></p><p><strong>Lowercase or Uppercase</strong></p><p>You can use the <code>${parameter^^}</code> expression to return the value of <code>parameter</code> converted to uppercase. You can also use the <code>${parameter,,}</code> expression to return the value of <code>parameter</code> converted to lowercase. An example is below:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>message<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Hello Reader&#34;</span>
echo <span style=color:#e6db74>${</span>message^^<span style=color:#e6db74>}</span>
echo <span style=color:#e6db74>${</span>message,,<span style=color:#e6db74>}</span>
</code></pre></div><p>The output of this script is:</p><pre><code>HELLO READER
hello reader
</code></pre><p><strong>Parameter Indirection</strong></p><p>If you want to get the value of a parameter that has an arbitrary name you can use the <code>${!parameter_name}</code> expression. This will return the value of the parameter that has the name of the value of <code>parameter_name</code> - you can see this in action like so:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>parameter_name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;HOME&#34;</span>
echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>!parameter_name<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</code></pre></div><p>The output of this script is:</p><pre><code>/home/dwmkerr
</code></pre><p>This can be very useful if you are writing scripts that will work with arbitrary of variable parameter names.</p><p>You can see more examples of how parameter expansion works, and in particular how to use parameter expansion with the parameters to functions or scripts in <a href=/docs/part-4-shell-scripting/variables-reading-input-and-mathematics/>Chapter 19 - Variables, Reading Input, and Mathematics</a>.</p><h2 id=command-substitution>Command Substitution</h2><p>The second form of expansion that starts with a dollar <code>$</code> symbol is <em>command substitution</em>. This form of expansion instructs the shell to run a specific command. The syntax is simply <code>$(comand)</code>.</p><p>We have seen command substitution throughout the book - in the example below we expand the <code>date</code> command to print the current date:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>The date is: </span><span style=color:#66d9ef>$(</span>date<span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span>

<span style=color:#75715e># The line above is expanded to:</span>
echo <span style=color:#e6db74>&#34;The date is: Tue Oct 19 16:49:07 +08 2021&#34;</span>
</code></pre></div><p>You may find that your scripts or commands are easier to manage if you store the results of a command in a variable like so:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>archives<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>find ~/downloads -type f -name <span style=color:#e6db74>&#34;*.tar.gz&#34;</span><span style=color:#66d9ef>)</span>
</code></pre></div><p>In this command we store the results of the <code>find</code> operation in the parameter named <code>archives</code>.</p><p>There is an alternative syntax for command substitution that you might see. In this alternative syntax the command is surrounded by backtick symbol. The command above could be written like so:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>archives<span style=color:#f92672>=</span><span style=color:#e6db74>`</span>find ~/downloads -type f -name <span style=color:#e6db74>&#34;*.tar.gz&#34;</span><span style=color:#e6db74>`</span>
</code></pre></div><p>You may see this syntax from time to time, however I would suggest that you avoid it. The reason is that you cannot <em>nest</em> commands using this syntax. If you want to run a command that itself performs command substitution it is not possible to do so with this backtick syntax. Instead, prefer the form that uses parentheses - such as <code>result=$(command1 $(command2))</code>.</p><h2 id=arithmetic-expansion>Arithmetic Expansion</h2><p>The final form of shell expansion that starts with a dollar symbol <code>$</code> is <em>arithmetic expansion</em>. This expansion can be used to perform simple arithmetic expressions:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>The result of 23*4 is: </span><span style=color:#66d9ef>$((</span><span style=color:#ae81ff>23</span><span style=color:#f92672>*</span><span style=color:#ae81ff>4</span><span style=color:#66d9ef>))</span><span style=color:#e6db74>&#34;</span>
echo <span style=color:#e6db74>&#34;The result of 23*4 is: 92&#34;</span>
</code></pre></div><p>Arithmetic expansion is covered in detail in <a href=/docs/part-4-shell-scripting/variables-reading-input-and-mathematics/>Chapter 19 - Variables, Reading Input, and Mathematics</a>.</p><h2 id=word-splitting>Word Splitting</h2><p>Word splitting is a complex topic that can often cause confusion. Word splitting is the process that the shell goes through when it takes the results of parameter expansion, command substitution and arithmetic expansion and then attempts to split the result into &lsquo;words&rsquo;. The easiest way to remember which expansions have word splitting applied are that it is applied to <em>any</em> expansion that starts with a dollar symbol <code>$</code> and that does <em>not</em> occur within double quotes.</p><p>The fact that word splitting only occurs if a substitution does <em>not</em> use double quotes can also cause confusion. Let's take a look into word splitting in detail and see when it is useful and when it can be problematic.</p><p>To see word splitting in action, we'll run a command that returns a set of words. In the example note that there are different numbers of space characters between some of the days:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>days<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Monday Tuesday Wednesday      Thursday Friday   Saturday Sunday&#34;</span>
<span style=color:#66d9ef>for</span> day in <span style=color:#e6db74>&#34;</span>$days<span style=color:#e6db74>&#34;</span>
<span style=color:#66d9ef>do</span>
    echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>day<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
<span style=color:#66d9ef>done</span>
</code></pre></div><p>The output of this script is:</p><pre><code>Monday Tuesday Wednesday      Thursday Friday   Saturday Sunday
</code></pre><p>In the expression <code>for day in "$day"</code> we are using <em>shell parameter expansion</em> to expand the <code>days</code> parameter. We have surrounded <code>$day</code> in quotes - this means that we are telling the shell <em>not</em> to apply any word splitting. This means the shell preserves the spaces in the parameter. When we loop through the parameter we have one value only - the original set of days, including the spaces, that we set in the parameter.</p><p>Now let's run the same script but this time we will <em>not</em> surround <code>$days</code> in quotes, meaning that the shell <em>will</em> perform word splitting:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>days<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Monday Tuesday Wednesday      Thursday Friday   Saturday Sunday&#34;</span>
<span style=color:#66d9ef>for</span> day in $days
<span style=color:#66d9ef>do</span>
    echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>day<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
<span style=color:#66d9ef>done</span>
</code></pre></div><p>The output of this script is:</p><pre><code>Monday
Tuesday
Wednesday
Thursday
Friday
Saturday
Sunday
</code></pre><p>In this case we can see that word splitting has occurred. The shell has performed the following operations:</p><ol><li>First, it searches through each character in the input</li><li>Every time it finds a character in the <code>IFS</code> (<em>Input Field Separator</em>) special variable, it splits the word</li><li>If there are multiple instances of a separator character, they are removed, and replaced with a single instance only</li></ol><p>By default, the <code>IFS</code> variable is set to <code>&lt;space>&lt;tab>&lt;newline></code>. This means that any spaces, tabs or newline characters in the input are considered as characters that the shell will use to split words. As you can see from the example above, when we have multiple instances of these characters sequentially (such as the five space characters after the <code>Wednesday</code> value), they are replaced with a single instance of the first character (a space in this case) and then the splitting occurs.</p><p>The fact that the shell uses spaces, tabs and newlines as input field separators can sometimes cause confusion - in particular if you have a list of files:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>programs<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;/usr/bin/bash /usr/bin/zshell /usr/bin/new shell&#34;</span>
<span style=color:#66d9ef>for</span> program in $programs
<span style=color:#66d9ef>do</span>
    echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>program<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
<span style=color:#66d9ef>done</span>
</code></pre></div><p>The output of this script is:</p><pre><code>/usr/bin/bash
/usr/bin/zshell
/usr/bin/new
shell
</code></pre><p>The final command, which has a space in the name, has been split into two words. You could avoid this issue by temporarily <em>changing</em> the value of <code>IFS</code> to use a different separator for words:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>programs<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;/usr/bin/bash;/usr/bin/zshell;/usr/bin/new shell&#34;</span>
OLDIFS<span style=color:#f92672>=</span>$IFS
IFS<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;;&#39;</span>
<span style=color:#66d9ef>for</span> program in $programs
<span style=color:#66d9ef>do</span>
    echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>program<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
<span style=color:#66d9ef>done</span>
IFS<span style=color:#f92672>=</span>$OLDIFS
</code></pre></div><p>The output of this script is:</p><pre><code>/usr/bin/bash
/usr/bin/zshell
/usr/bin/new shell
</code></pre><p>In this script we saved the original value of <code>IFS</code> into a parameter called <code>OLDIFS</code>, changed <code>IFS</code> to use a semi-colon as a separator, ran the loop (which correctly split the programs and preserved the space in the last program name) then change <code>IFS</code> back to its original value.</p><p>You should be careful when changing <code>IFS</code> to make sure that you change it back to its original value straight afterwards - other programs or commands might expect <code>IFS</code> to be set to the default value so it should only be changed with caution.</p><p>If you were to look at the contents of the <code>PATH</code> variable, which specifies the locations the shell should search for commands, you will see that they are actually separated by colons:</p><pre><code>$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games
</code></pre><p>The results you see will vary depending on your operating system. But the fact that they are separated by colons means that you can easily change <code>IFS</code> to a colon character to get each of the paths - even if they contain spaces:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>OLDIFS<span style=color:#f92672>=</span>$IFS
IFS<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;:&#34;</span>
<span style=color:#66d9ef>for</span> path in $PATH
<span style=color:#66d9ef>do</span>
    echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>path<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
<span style=color:#66d9ef>done</span>
IFS<span style=color:#f92672>=</span>$OLDIFS
</code></pre></div><p>The output of this script will look something like this:</p><pre><code>/usr/local/sbin
/usr/local/bin
/usr/sbin
/usr/bin
/sbin
/bin
/usr/games
/usr/local/games
</code></pre><p>We will see a little more about how the shell can sometimes split up a filename with spaces (or even newlines) in the path when we look at the final shell expansion - pathname expansion.</p><h2 id=pathname-expansion>Pathname Expansion</h2><p>When the shell encounters the asterisk <code>*</code>, question mark <code>?</code> or open square brackets <code>[</code> characters, it marks the beginning of an expression that will have <em>pathname expansion</em> applied to it. We have actually seen pathname expansion a number of times in this book - it is the expansion that occurs when we use wildcards or patterns in shell scripts to expand a list of paths:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ ls ~/downloads/*.tar.gz
/home/dwmkerr/downloads/aspnetcore-runtime-3.1.18-osx-x64 <span style=color:#f92672>(</span>1<span style=color:#f92672>)</span>.tar.gz
/home/dwmkerr/downloads/aspnetcore-runtime-3.1.18-osx-x64.tar.gz
/home/dwmkerr/downloads/dotnet-sdk-3.1.412-osx-x64.tar.gz
/home/dwmkerr/downloads/effective-shell-playground.tar.gz
/home/dwmkerr/downloads/effective-shell-samples <span style=color:#f92672>(</span>1<span style=color:#f92672>)</span>.tar.gz
/home/dwmkerr/downloads/effective-shell-samples <span style=color:#f92672>(</span>2<span style=color:#f92672>)</span>.tar.gz
/home/dwmkerr/downloads/effective-shell-samples.tar.gz
</code></pre></div><p>This script shows all of the files in the <em>~/downloads</em> folder that match the pattern <code>*.tar.gz</code>. The results you see will depend on what you have in your own <em>~/downloads</em> folder!</p><p>It is important to remember that the shell performs all of the types of expansion that we have described <em>in order</em>. This means that word expansion is performed <em>before</em> pathname expansion. So if you loop through the results of an expanded path, word splitting will not be performed on those results. We can see that with the script below:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#66d9ef>for</span> $path in ~/downloads/*.tar.gz
<span style=color:#66d9ef>do</span>
    echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>path<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
<span style=color:#66d9ef>done</span>
</code></pre></div><p>The result of this script is:</p><pre><code>/home/dwmkerr/downloads/aspnetcore-runtime-3.1.18-osx-x64 (1).tar.gz
/home/dwmkerr/downloads/aspnetcore-runtime-3.1.18-osx-x64.tar.gz
/home/dwmkerr/downloads/dotnet-sdk-3.1.412-osx-x64.tar.gz
/home/dwmkerr/downloads/effective-shell-playground.tar.gz
/home/dwmkerr/downloads/effective-shell-samples (1).tar.gz
/home/dwmkerr/downloads/effective-shell-samples (2).tar.gz
/home/dwmkerr/downloads/effective-shell-samples.tar.gz
</code></pre><p>Note that the spaces in the path names have been preserved - pathname expansion happens <em>after</em> word splitting - so the paths themselves are left as-is.</p><p>As well as the asterisk <code>*</code> character, which can be used as a wildcard character in pathname expansion, there is also the question mark <code>?</code> character which means &lsquo;any single character&rsquo;. You can also use expressions such as <code>[abc]</code> to match on a range of characters. The exact details of how these special characters are used can be found in <code>man bash</code>.</p><p>One feature of pathname expansion that people can sometimes be surprised by is what happens if the shell finds <em>no files</em> that match the pattern. You can see this in action below:</p><pre><code>$ echo ~/effective-shell/*.txt
/home/dwmkerr/effective-shell/*.txt
</code></pre><p>There are no files in the <em>~/effective-shell</em> folder that match the pattern <code>*.txt</code> and in this case the shell has left the text as-is. This means that you should always check the results of the expansion before assuming that the shell has found a file!</p><p>For example, if I wanted to run the <code>touch</code> command on a set of files, I would do the following:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#66d9ef>for</span> file in ~/effective-shell/*.txt
    <span style=color:#75715e># If the file / folder doesn&#39;t exist, skip it.</span>
    <span style=color:#66d9ef>if</span> ! <span style=color:#f92672>[</span> -e <span style=color:#e6db74>&#34;</span>$file<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>continue</span>; <span style=color:#66d9ef>fi</span>
    touch <span style=color:#e6db74>&#34;</span>$file<span style=color:#e6db74>&#34;</span>
<span style=color:#66d9ef>do</span>
</code></pre></div><p>In this script we first check to see whether the file or folder exists by using the <code>-e</code> test. If the file or folder doesn't exist then we skip through the loop. You can see more examples of this pattern in <a href=/docs/part-4-shell-scripting/loops-and-working-with-files-and-folders/>Chapter 21 - Loops and working with Files and Folders</a>.</p><p>Pathname expansion has limitations - if you need a more sophisticated way to search for a set of files, check <a href=/docs/part-2-core-skills/finding-files/>Chapter 11 - Finding Files</a>.</p><h1 id=summary>Summary</h1><p>In this chapter we went into the lower level details of how <em>shell expansion</em> works and looked at the seven types of expansion the shell will perform on the input it is provided. Whilst we have seen many of these expansions already throughout the book, I think it is useful to see all of them together in one place to really understand <em>what</em> the shell does with the input you provide it in your commands.</p><p>Hopefully with this additional knowledge on shell expansion, you will be less likely to make mistakes around things like word splitting, or how empty results from filename expansion are treated, which often cause people confusion.</p><p>In the next chapter we will examine some of the limitations of shell scripting and alternatives to shell scripts that can be useful to become familiar with.</p></article><div class="book-footer justify-between"><div><a class="flex align-center" href=https://github.com/dwmkerr/effective-shell/commit/ca7336d05b00d7ae6aa5117c3642b848a7b64e4e title="Last modified by Dave Kerr | Jan 24, 2022" target=_blank><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>Jan 24, 2022</span></a></div><div><a class="flex align-center" href=https://github.com/dwmkerr/effective-shell/edit/master/website/content/docs/part-6-advanced-techniques/understanding-shell-expansion/_index.md target=_blank><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"effective-shell"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><p>Copyright &copy; <script>document.write(new Date().getFullYear())</script>, Dave Kerr</p></div><aside class="book-toc levels-3 fixed"><nav id=TableOfContents><ul><li><a href=#chapter-29---understanding-shell-expansion>Chapter 29 - Understanding Shell Expansion</a></li><li><a href=#what-is-shell-expansion>What is Shell Expansion?</a></li><li><a href=#shell-expansion>Shell Expansion</a><ul><li><a href=#brace-expansion>Brace Expansion</a></li><li><a href=#tilde-expansion>Tilde Expansion</a></li><li><a href=#parameter-expansion>Parameter Expansion</a></li><li><a href=#command-substitution>Command Substitution</a></li><li><a href=#arithmetic-expansion>Arithmetic Expansion</a></li><li><a href=#word-splitting>Word Splitting</a></li><li><a href=#pathname-expansion>Pathname Expansion</a></li></ul></li><li><a href=#summary>Summary</a></li></ul></nav></aside></main></body></html>