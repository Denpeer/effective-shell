'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/section6/the-future/','title':"The Future",'content':""});index.add({'id':1,'href':'/docs/1-getting-started/','title':"Chapter 1 - Getting Started",'content':"Chapter 1 - Getting Started This section is for those who are completely new to this topic. In this section we'll introduce just what the shell is, who this book is useful for, and what you can expect to learn.\nWe'll also look at how to set your computer up so that you can follow along with the examples. We'll finish by demonstrating a few basic skills so that you can learn to move around in the shell and get started with the rest of the book.\nIf you are already comfortable with running a shell, know what Bash is, and know how to run basic commands like ls and cd, then you can completely skip this section.\nIf you are already comfortable with running a shell, know what bash is, and know how to run basic commands like ls and cd, are familiar with terms like command and parameter then you can skip this section. You could also just review the Summary to make sure that you are comfortable with the material which has been introduced and then move onto the next section.\nWhat is the Shell? If you don't know what the shell is, then this is the place to start!\nWhen we talk about \u0026ldquo;The Shell\u0026rdquo;, we're normally referring to the simple, text-based interface which is used to control a computer or a program.\nHere's what the shell looks like on Windows:\nAnd here's what it looks like on a Mac:\nAnd here's what it looks like on Fedora, a popular Linux distribution:\nWhen we are talking about the shell in this book, we're talking about the simple program which can be used to operate the computer using this text based interface.\nWhy would you want to do this? There are a few reasons!\nFirstly, using the shell can help you learn more about the internals of how your computer can work. This can be really helpful if you are technology professional or work with computers.\nSecondly, there are some scenarios where you have to use a shell. Not every program or system can be operated with a Graphical User Interface, which is the visual point-and-click interface you are probably using now. Some lower-level programs do not have such interfaces, and many computers do not either.\nFinally, there are some scenarios where it can be more efficient to use the shell. Operations which might be time consuming or repetitive to perform using the user interface might be much faster to perform in a shell. You can also write shell scripts to automate these kinds of operations.\nIn the next section you'll learn how to startup the shell on your computer. Once this is done you are ready to continue with the book.\nOpening the Shell Now let's actually learn how to open the shell on your computer.\nOnce we've done this, we might need to make some configuration changes so that we get it to behave in a way which as consistent with other shells as possible - we'll get to that in the next chapter.\nMicrosoft Windows There are a number of shell programs on Microsoft Windows. We'll be using the basic shell which is pre-installed, which is called the \u0026ldquo;Command Prompt\u0026rdquo;.\nTo open the command prompt, start by clicking the start button on the bottom left hand side of the screen, and type command prompt. Open the Command Prompt program:\nOnce the program has opened, type whoami then hit the Return key. The whoami program will show the username of the logged in user:\nThat's it! We've still got some configuration to do to make this shell behave more like a Linux shell, which this book uses as the standard, but we'll come to that in the next section.\nMacOS If you are using a Mac, then you just need to run the \u0026ldquo;Terminal\u0026rdquo; program to open your shell. Hold down the Command Key and press Space, then type terminal. Open the terminal program which is shown:\nOnce the program has opened, type whoami then hit the Return key. The whoami program will show the username of the logged in user:\nThat's it! In the next section we'll make some minor configuration changes to keep things consistent with the samples in the book.\nLinux / Unix If you are using a Linux or Unix system, I'll assume that you are familiar enough with it to open a shell. Which terminal you use should not affect how you use this book, but for consistencies sake be aware that most of the examples are assuming that the user is using Bash version 5.\nConfiguring the Shell Shells can vary enormously between different systems. In general, Linux systems tend to use the \u0026ldquo;Bash\u0026rdquo; shell and require little configuration. Apple's MacOS operating system is actually based on BSD Unix, and under the hood is somewhat different to most Linux systems. Microsoft Windows is a completely unrelated operating system to either Linux or Unix and operates in a fundamentally different way both of them.\nIn this book, we assume that you are using a \u0026ldquo;Linux-like\u0026rdquo; system, something which operates like a modern Linux distribution. This is a deliberate choice. If you become comfortable using a Linux-like shell, you can generally apply the techniques we'll show to MacOS with no difficulties. For Windows, the techniques are not necessarily transferable immediately, but still valuable to know. Windows is actually being updated at the time of writing to provide a Linux-like shell interface as part of the core operating system (this is known as the Windows Subsystem Linux. As time progresses it will be easier to run commands using the techniques in this book natively, but for now we'll have to tweak a few things.\nIn this section we'll make sure that we are running with a setup which is close to Linux, and aim to set the latest version of our shell to the popular \u0026ldquo;Bash\u0026rdquo; program. If you are familiar with Bash but prefer to use another shell, that is fine, most of the book will work with any modern shell. However, if you are not sure what shell you should be using, I would recommend you follow the guides below to setup the most popular shell at its latest version.\nOnce this is done then we are ready to get into the book properly!\nMicrosoft Windows Windows is not anything like Linux under the hood. So to get a shell working, we have three options:\n Use a tool which provides common Linux tools which have been written to work with Windows Use a \u0026ldquo;virtual machine\u0026rdquo; running Linux Use the Windows Subsystem for Linux  The first option is the best if you want to actually be able to work with the files on your computer quickly and easily day to day.\nThe second option is best if you want to be able to experiment with the shell, but keep it completely separate from your main computer and its files.\nThe final option is best if you are a power user or expert who wants to use the latest WSL features and build the skills with the platform as soon as possible.\nWe'll go through all options here.\nOption 1: Install Linux Tools This is probably the easiest option and the one I would recommend for most user. It will let you run something like a Linux shell when you choose to, but not get in your way during day-to-day usage of your computer.\nTo get a Linux-like experience on a Windows machine, we'll install Cygwin. Cygwin provides a large set of programs which are generally available on Linux systems, which are designed to work on Windows.\nDownload the Cygwin installer and start the installation process. You should see something like this:\nStart the installation and tell it to install from the internet (the default option):\nInstall for all users in the default location. It is also fine to change the options if you prefer:\nCygwin will ask you where to install downloaded packages, whether a proxy is needed, and what download sites to use. Leave these options at their default unless you know what you are doing and why you'd need to change them. It will then start downloading. Once it has downloaded the list of available packages to install, it will ask which packages you want. Choose the default option \u0026ldquo;All\u0026rdquo;:\nThe installer will now start downloading and installing the programs:\nOnce Cygwin has finished installing, you will have a link to open Cygwin available on the desktop and start menu.\nYou can use this link to start using the \u0026ldquo;Bash\u0026rdquo; shell, or if you prefer you can open the \u0026ldquo;Command Prompt\u0026rdquo; as described in Opening the Shell and run the bash program:\nNote that you shouldn't use the --norc option. I have used it in the screenshot above just so that my Bash looks like it would after a clean install, without my own customisations added.\nAt this point you have a ready-to-go bash environment and can continue on to the Summary and Next Section.\nOption 2: Use a Virtual Machine We can run a virtual machine on Windows which will give us a complete Linux environment. This is an ideal way to create a safe sandbox for experimentation, without changing how the rest of the system is setup.\nThere are many ways to run a virtual machine on Windows. For this example we'll use the free \u0026lsquo;Oracle VirtualBox\u0026rsquo; tool. VirtualBox will run a virtual machine, and on that virtual machine we will install the popular Ubuntu distribution of Linux.\nFirst, start downloading Ubuntu, which might take some time as the download is quite large. You will want to install the latest Desktop Edition (which at the time of writing is version 18):\nWhile the Ubuntu software downloads, we can install VirtualBox. Go to the VirtualBox Website and download the VirtualBox installer. You will need the installer for \u0026lsquo;Windows Hosts\u0026rsquo;.\nOnce the installer has downloaded, run it to start the installation:\nNext you will be asked to configure the installation options. The defaults will be fine for most users:\nThen the installation will start:\nOnce the installation is complete and the Ubuntu installer has downloaded we can move onto the next step.\nOpen VirtualBox and choose \u0026lsquo;New\u0026rsquo; to create a new Virtual Machine. Ensure \u0026ldquo;Expert Mode\u0026rdquo; is selected. Provide a name for the machine and choose \u0026ldquo;Linux\u0026rdquo; as the type and \u0026ldquo;Ubuntu_64\u0026rdquo; as the version type. Everything else can be left as the default, unless you want to tweak the machine settings:\nYou will be asked to setup a virtual hard disk. I would recommend the default options for most users:\nOnce the machine has been created it will be shown in the main VirtualBox window. Select the machine and choose \u0026ldquo;Start\u0026rdquo;:\nWhen the machine starts up it will ask you for a \u0026ldquo;Startup Disk\u0026rdquo;. This is the disk which will be used to setup the operating system. Press the \u0026ldquo;browse\u0026rdquo; icon, then choose \u0026ldquo;open\u0026rdquo; and select the Ubuntu file which you downloaded, which should end in .iso:\nIf this step fails, you may need to disable \u0026ldquo;Hyper-V\u0026rdquo; and \u0026ldquo;Windows Sandbox\u0026rdquo; by going to \u0026ldquo;Add or Remove Windows features\u0026rdquo;:\nAfter a short while you will see the Ubuntu installer start up. Choose the \u0026ldquo;Install Ubuntu\u0026rdquo; option:\nYou can specify language settings, what components are installed and more. These options can be left at the default. On the final page, choose the \u0026ldquo;Erase disk and install Ubuntu\u0026rdquo; option:\nThe final step will be to choose a name for the computer, and a username and password to log in with. You can use any values you like here, just don't forget them!\nAfter this the installation will proceed. It might take a little while. After the installation is complete, you will need to restart. If you get an error saying \u0026ldquo;Please remove installation medium\u0026rdquo; just power off the machine and restart it. After restarting you can log into the machine with the credentials you specified earlier.\nWhen you have logged in, press the applications icon on the bottom-left of the screen and search for the \u0026ldquo;Terminal\u0026rdquo; application:\nYou are now running the \u0026ldquo;Bash\u0026rdquo; shell in the terminal. You can run the whoami command to show the current user, or bash --version to see the version of Bash which is installed:\nThat's it! You now have a virtual machine running Ubuntu and Bash which you can use to learn about the shell.\nOption 3: Setup the Windows Subsystem for Linux The Windows Subsystem for Linux is a relatively new set of features for Microsoft Windows. It allows users to install a Linux distribution on their Windows machine. This is a great way for us to be able to use the \u0026ldquo;Bash\u0026rdquo; shell without having to set up a virtual machine.\nFirst, open up the \u0026ldquo;Turn Windows Features on or off\u0026rdquo; option from the control panel:\nThen enable the \u0026ldquo;Windows Subsystem for Linux\u0026rdquo; feature:\nAfter your computer has restarted, open up the Windows App Store and search for \u0026ldquo;Ubuntu\u0026rdquo;:\nOnce Ubuntu has installed, open up the app. It will then initialise (which can take a little while):\nChoose a username and password to complete the setup:\nAnd that's it! You can now open the Ubuntu app at any time to use Ubuntu on Windows, interfacing using the Bash shell.\nMacOS If you are running a Mac, then you can probably run the standard Terminal program and follow the material in this book without making any changes. However, the version of Bash which comes installed by default on MacOS is version 3, which is a little out of date. I would strongly suggest that you upgrade the default installation. On MacOS Catalina, the default shell has changed to Z Shell - this should work fine for all of the examples in this book, but you might want to switch it to Bash to be on the safe side (you can always change back later).\nTo install the right software, we'll use a tool called Homebrew. Homebrew is a \u0026lsquo;package manager\u0026rsquo;, a tool used to install software on your computer, from the shell. It's kind of like the App Store but for shell users!\nFirst, follow the instructions online to install Homebrew:\nIn most cases, this will require opening the terminal programming and running a snippet which looks like this:\n/usr/bin/ruby -e \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\u0026#34; However, this might have changed since the time of writing so do check the website to see what the latest instructions are. You don't actually need to know what is going on with this command (but by the time you've worked through a bit more of this book it will make sense!), but in a nutshell it runs a basic installation script, using the Ruby programming language (which comes pre-installed on MacOS).\nOnce this has installed, install Bash by running the following command in the shell:\nbrew install bash This uses the brew command, which we have just installed, to install the bash program.\nFinally, update the Terminal preferences to use the version of Bash you have just installed, rather than the default, by setting the shell location to /usr/local/bin/bash:\nAgain, why we make these changes is not essential to know for now, we'll go into more details in a later section. Once you've made this change, whenever you open a new terminal window, it will run the latest version of Bash, which you can confirm by running echo $BASH_VERSION:\nThere is actually a more sophisticated way to change what shell is used in a system, which is the special chsh command (short for \u0026ldquo;change shell\u0026rdquo;). We'll see this in a later section. We'll also see what echo is in more detail shortly.\nLinux As before, if you are running Linux I will assume you are able to open a terminal and setup the appropriate shell. You can follow along with the content in this book with any recent Bash-like shell.\nThat's It! Later on we'll see a little more about the differences between different shell programs, what the difference between a shell and a terminal is and more. But for now, you are ready to go and move onto the Summary and then Section 1.\nA Quick Demo of the Shell If you have never used the shell before, then this is where we'll start. We're not going to go into lots of detail, there's plenty of that later on in book. Instead we'll do a quick crash course on the basics. If you have not used the shell before this'll give you a chance to see how it works.\nStart by opening your shell. This is covered in Opening the Shell. Your shell should be Bash - if this doesn't sound familiar, then make sure you have followed the instructions in Configuring the Shell.\nYou should see your terminal program running your shell. You can see what the version is of your shell by running:\nbash --version Let's quickly dissect this. We have run the bash command. A command can be a program on your computer, or it can be something built into the shell. We'll look at this in a lot more detail later, but for now it's important to understand that a lot of what you will be doing is running commands.\nThe --version text is a parameter. Parameters affect how commands work. This is actually easier to see with an example.\nLet's move to the home folder. On most computers your home folder is your personal space where things like documents, photos, music, downloads and so on are kept.\nLet's switch to the home folder by running the following command:\ncd ~ Once you've done that, run the pwd command:\npwd So what has happened here? The first command:\ncd ~ Is used to change directory - that's what cd stands for. The parameter we passed to cd was just the \u0026lsquo;tilde\u0026rsquo; character (~). This character has a special meaning in the shell - it means \u0026ldquo;the current user's home directory\u0026rdquo;.\nFinally, we ran the pwd command. This command is short for print working directory. It writes out to the screen where you currently are. On my Mac, my home directory is located at /Users/dwmkerr, which is what the command has shown me.\nLet's take another look at a command. Run the following in your shell:\nls The ls command is short for list directory contents - it shows you everything that is in the current directory. On my computer you can see things like the \u0026lsquo;Downloads\u0026rsquo;, \u0026lsquo;Music\u0026rsquo; and \u0026lsquo;Pictures\u0026rsquo; folders, which are set up by default on a Mac, as well as some of my own folders.\nWe can pass different parameters to ls. The main parameter is the location of the folder we'd like to list the contents of. So if we wanted to see what was in the Music folder, we'd just run:\nls Music Not much to see here:\nMany commands actually allow us to pass multiple parameters. For example, we could list the contents of my Movies and my personal applications:\nls Movies Applications There's not much in either. You might wonder why Applications is so empty - that's because we're looking at the applications only installed for the current user, because we are in the user's home directory. To see the applications for everyone we'd need to use the folder where applications are kept for all users.\nWe can do this by running ls /Appliciations:\nThe trick here is that we start with a leading forward slash - this means the Applications folder in the root of the computer, not the one in my current folder.\nOn Windows, applications are kept in different places, but we can see some of the installed applications by running ls \u0026quot;c:\\program files\\\u0026quot;:\nWhy do we have the extra quotation marks here? If we ran the command without the quotation marks, the shell would think we were giving it two parameters. It would think we wanted to see the contents of the c:\\program and files folders - and they don't exist!\nThe error above shows what happens when we miss the quotation marks.\nNow we can take a look at how a flag would work. A flag is a parameter which changes how a command works. Flags normally start with a hyphen. Let's say we wanted to know the size of the files in the folder. We do this by using the -lh pass the parameter, which is short for long list, human readable:\nls -lh Downloads/*.jpg Now I can see all of the jpg files (jpg files are images) in my Downloads folder. I can see it looks like I've got two pictures of \u0026ldquo;Mardi Himal\u0026rdquo; (a mountain in the Himalayas) which are both 384 Kilobytes in size, as well as some other images. Blow by blow, this is what we've got:\n ls - List the contents of a folder -lh - This is the long list in human-readable sizes parameter, which means we see how big the files are in a friendly format (like 911K for Kilobytes, rather than showing something like 911012 which would be the number of bytes - and harder to read!) Downloads/*.jpg - Show the contents of the Downloads folder, including any files which end with .jpg - the * is a wildcard which means that we don't mind what the filename is  The -lh parameter is shorthand. Many commands offer longhand parameters (such as --version) as well as shorthand (such as -v as an alternative for --version). Longhand is easier to read, shorthand is faster to type.\nDon't worry - in the next section we'll see how to look up the available parameters for a command. You don't need to remember all of these details, only understand which part is the command and which parts are the parameters. This is just an introduction for now!\nNow let's look at one more command.\nThe Echo Command The \u0026lsquo;echo\u0026rsquo; command is used to write out a message in the shell. Here's an example of how it works:\necho \u0026#34;Hello Shell!\u0026#34; This command writes out the text Hello Shell!:\nWhy would we do this? One of the most common reasons would be to see what the shell thinks a certain value is. For example, try this command:\necho \u0026#34;My home directory is at: $HOME\u0026#34; You'll see something like this:\nThe $HOME part of the text is called a variable. We can recognise variables because they start with a dollar symbol. $HOME is a built-in variable which holds the location of the current user's home directory.\nWe're going to see all sorts of cool things we can do with echo as we continue in the book!\nMove Around One common thing we can do in a visual file explorer is move around. We can open folders, and go \u0026lsquo;up\u0026rsquo; from the current folder. We often also see visually where we are in the folder structure with an \u0026lsquo;address bar\u0026rsquo;.\nA useful reference might be the picture below:\nHere we map the shell commands to the visual interface's equivalents:\n pwd shows the current working directory - where you currently are in the file system ls lists the files in the current directory (or any directory you tell it) cd .. changes the directory to another location - if you use the special .. directory, you are telling it to change to the parent directory, i.e. \u0026lsquo;go up\u0026rsquo; in the file system  As a final trick, lets see how we open a file or folder. Let's say I want to open one of the photos in my Downloads folder. Here's how I can do it:\ncd ~/Downloads open himalayas.jpg We can see the result here:\nRunning open himalayas.jpg has opened the photo in the application which is used for photos by default in the operating system.\nBe aware - this command is different on different operating systems (but we're going to see later on how to fix that and make it consistent everywhere!). The open command will open a file on MacOS. On Windows you can use start, and on Linux you can generally use xdg-open.\nAs a nifty trick, trying running open .1:\n. This will open the current folder. Every folder contains two \u0026lsquo;special\u0026rsquo; folders. The first is .., which we've seen means \u0026lsquo;my parent folder\u0026rsquo; and the second is ., which means \u0026lsquo;myself\u0026rsquo;. Having this . folder is convenient, as it means we can do things like this - run a command to open the current folder.\nWe're going to go into a lot more detail on how to work with files and folders, move around, but hopefully this has provided a crash course for the basics. They key concepts to remember, which are much more important than the individual commands we've see are:\n In the shell we run commands We can change how commands work by using parameters Some parameters just go at the end of the command - like ls Downloads Some parameters start with a hyphen, and change how the command behaves - these are often called \u0026lsquo;flags\u0026rsquo;. An example is ls -lh, which lists the files in the current folder with a human-readable file size  We've also learned:\n cd changes the current directory pwd prints the current directory ls lists the files in a directory echo can be used to write out text to the screen open, start and xdg-open can be used to open a file or folder on MacOS, Windows and Linux respectively  Now we can start to get into more detail!\nSummary In this section we learnt:\n That this book is for IT professionals, hobbyists or anyone who wants to learn more about how to work with computers What the shell is, and why we might want to use it How to open the shell programs for Windows, Mac and Linux which are installed by default How to configure the shells for Windows or Mac to behave in a Linux-like way to allow us to follow on with the rest of the book  We introduced the following commands:\n cd - which changes directory pwd - which prints the current working directory ls - which lists the contents of a directory echo - which writes text to the screen open - which will open a file or folder  We also briefly introduced variables, which are special values which start with the dollar symbol, such as $HOME which stores the user's home directory. We saw that each directory contains two special directories - .. which represents the parent directory, and . which represents the current directory.\nWith these tasks complete we can now move onto the next section.\n Footnotes\n  On Windows you might need to run start . and on Linux, xdg-open .. \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':2,'href':'/docs/part-1-transitioning-to-the-shell/1-navigating-your-system/','title':"Chapter 2 - Navigating Your System",'content':"Chapter 2 - Navigating Your System Switching from a graphical user interface to the shell can take some getting used to. First we'll take a look at how to navigate your system using the shell, and get information on files and folders in the system.\nThis section will introduce the pwd, ls, cd, pushd and popd commands, as well as the concepts of the \u0026ldquo;working directory\u0026rdquo; and \u0026ldquo;environment variables\u0026rdquo;. We'll also take a bit of a look into how \u0026ldquo;Paths\u0026rdquo; work.\nIf these commands far familiar to you then feel free to jump to the next chapter! Otherwise, let's get started.\nThe Working Directory Perhaps the easiest way to start to understand how to navigate your system using the shell is to use a graphical interface as an illustration of how we often navigate. Open your shell, and enter the following command:\npwd You should see something like this:\nWhen we open a folder in a graphical user interface, we are always viewing the contents of a folder, or directory. When you open the shell, the same applies - we are always sitting in a specific directory.\nThe pwd command is the Print Working Directory command. It shows the full path of the directory that you are in. You might not use this command very often, as in many shells you can see the directory you are in (if you cannot see this in your shell, you'll find out how to do this in the Chapter 18).\nThere's one more way to find the working directory. It is stored in an Environment Variable called PWD.\nAn environment variable is just a bit of data that you can access from your shell. You can create them, you can change them, and there are some which are set for you by the system or the shell to help you out.\nTry the following command:\necho \u0026#34;My current working directory is: $PWD\u0026#34; You should see something like this:\nThe dollar symbol is used to tell the shell we want to use the PWD variable, not write out the text PWD. We'll see a lot more about environment variables as we continue through the book.\nListing the Contents of the Working Directory In the graphical user interface, we can also see the files and folders in the current directory. In the shell, we don't see this content. But we can show the contents of the current working directory with the following command:\nls You should see something like this:\nThe ls command is the List Directory Contents command. It will show the contents of a directory. If we don't give it any parameters it will show the contents of the current directory.\nThere are a lot of options for the ls command. In Chapter 5 we'll see how to find out the options for commands. For now, let's look at one of the most common options -l. This shows the contents as a list:\nls -l A little like the \u0026lsquo;details\u0026rsquo; view in a graphical user interface, this list view shows us more details, such as who owns the file or folder, when it was modified, and more. Again, we'll see more details on this later.\nChanging the Directory In a graphical user interface, you move to a different directory by clicking on it.\nIn the shell, you run the cd command. Try it out with:\n# Move to the pictures directory... cd Pictures # ...then list the contents of the directory. # Note that the \u0026#39;-al\u0026#39; flags mean show *all* files, as a *list*. ls -al Note that when you see shell commands, everything which starts with a hash symbol is a comment. These comments are just for readability, you don't need to include them. But if you are saving your own shell snippets (or \u0026ldquo;scripts\u0026rdquo;), then you might find comments a useful way to remind yourself of what you are hoping to achieve with the commands, or to make the script more readable.\nOn my system, we'll see the following output:\nThe cd command is the Change Directory command. You might see a pattern here - shell commands often are very short (to make it easier to type them quickly), and are often made up of the first letters of the description of the command (pwd for Print Working Directory, cd for Change Directory).\nNow that you know how the cd command works, you will be able to move around to different folders. At this stage, it's important to talk a little bit about how paths work in systems.\nUnderstanding Paths In Linux, Windows and MacOS (and most other operating systems), paths are the \u0026lsquo;addresses\u0026rsquo; of files or folders.\nThere are two types of paths - Absolute Paths and Relative Paths. An absolute path is one which gives the exact location of a file. For example, on my computer, the absolute path to the folder I am writing this book in is:\n/Users/dwmkerr/repos/github/dwmkerr/effective-shell Absolute paths always start with a slash. That's how the system knows it is an absolute path. The / is the root of the file system - basically it's the folder which everything else lives in.\nIf I have an absolute path, I know exactly where the file or folder is. Let's compare this to a relative path. Below is the relative path in my shell for the file I'm writing right now:\nwebsite/content/docs/part-1-transitioning-to-the-shell This path is relative to my current working directory in the shell. This means that this path only makes sense if you use it from a specific directory. If I am in my Pictures folder, and I want to move to the 2020-photos folder, I could do it in two ways. The first is with an absolute path:\ncd /Users/dwmkerr/Pictures/2020-photos The second is with a relative path:\ncd 2020-photos In short - relative paths are often useful if you want to move to something within the current directory and absolute paths are useful if you need to move to somewhere completely different.\nThe Special Dot and Dot Dot Folders As you experiment with these commands, you might have noticed that every folder contains two other folders, one with the name . and one with the name ... Run ls -al on the pictures folder to see an example:\nls -al pictures You should see something like this:\nThis picture highlights two special folders - . and ... These are special folders which exist in every folder in the system.\nThe first folder, ., represents the folder it is in. Why would this be useful? Well, sometimes we just want a quick way to say the equivalent of \u0026ldquo;right here\u0026rdquo; in a command. For example, if I wanted to copy the current folder to a backup folder, I could do this:\ncp . /backup The cp command is the Copy command, and we'll see it in the next chapter. But the key thing to note is that we can use . to tell the command to copy the folder we are in right now.\nThe .. folder means the parent folder. You can use this to \u0026ldquo;go up\u0026rdquo; to the parent folder, for example:\ncd .. ls . Would give:\nNote that we've used cd .. to change directory to the parent folder then ls to list the contents of the current folder. We could also just have used ls on its own as it defaults to the current folder.\nThe .. folder can be helpful if you need to navigate to a location which is outside of your current folder. For example, if I am in the pictures folder and I want to move to the scripts folder, I can just use:\ncd ../scripts ls And we'll see this:\nThe Home Directory There is one more special part of the file system we have to know about. That is the Home Directory. In Linux-like systems every user has their own personal directory where they can keep their files and folders.\nThis directory can always be accessed through the ~ character. For example, no matter where I am in the system I can run the following command to move to my home directory and show the contents:\ncd ~ ls This would show something like this:\nThis makes moving around your home directory very easy. For example, on a Mac, to go to your pictures folder from anywhere, you can always just run:\ncd ~/Pictures Your home directory on most computers will be where you keep your documents, pictures, videos and so on. Normally this directory is not accessible to other users of the system. Each user in a system gets their own home directory.\nYou can also see the home directory by using the special HOME environment variable:\necho \u0026#34;My home directory is: $HOME\u0026#34; This would show something like this:\nOne useful trick - running cd without any parameters will always take you home! So to go home, just run:\ncd Now that we know about relative paths, absolute paths, and the special dot and dot dot folders, and the home directory we can continue learning how to navigate the shell!\nPushing and Popping the Working Directory One thing we might want to do is quickly move from one location to another, then go back again. Let's say for example I am working in on this chapter, but I want to check my downloads. One way to do this is with this pushd command:\npushd ~/Downloads ls popd After I've checked my downloads, I can run popd to go back to where I was:\nThe pushd command \u0026lsquo;pushes\u0026rsquo; a new working directory onto a stack - moving you there. The popd command \u0026lsquo;pops\u0026rsquo; the working directory off the top of the stack. A stack is a structure often used in computers, we can actually push lots of different files to the working directory stack.\nWhy is it called a stack? Well the reason is that if we were to visualise the structure, it might look like a stack of plates or similar. Here's how pushd and popd would look if we were to visualise it:\nThese commands can be useful if you need to move to other locations but want to be able to quickly go back to where you were before afterwards.\nGoing Back One last trick which can save time is the following command:\ncd - This is a special parameter for cd which tells it to go back to the last location you moved to. Here's how it might look if you use it:\nThis can only be used to go back to the last directory. If you need to be able to go backwards multiple times or through a history of directories, you might need to use pushd and popd instead.\nSummary In this chapter we introduced the following:\n The pwd (print working directory) command shows the current working directory The $PWD environment variable holds the current working directory The ls (_list) command shows the contents of the current directory or a given directory The ls -l command shows the contents of the current directory as list The cd (change directory) changes the current working directory Absolute paths are paths which specify the exact location of a file or folder\u0026hellip; \u0026hellip;Relative paths are paths which are relative to the current directory The . special folder means \u0026lsquo;this folder\u0026rsquo; The .. special folder means \u0026lsquo;the parent folder\u0026rsquo; The ~ special folder is the \u0026lsquo;home directory\u0026rsquo; The $HOME environment variable holds the user's home directory You can run cd at any time to quickly go to your home directory You can use pushd and popd to push and pop the working directory stack You can use the cd - command to go back to the last location  "});index.add({'id':3,'href':'/docs/section1/1-navigating-the-command-line/','title':"Navigating the Command Line",'content':"Navigating the Command Line I can't think of a better place to start than navigating the command line. As you start to do more and more in the shell, text in the command line can quickly become hard to handle. In this article I'll show some simple tricks for working with the command line more effectively.\nHere's a quick reference diagram, the rest of the article goes into the details!\n\nThis article, examples and diagrams are available at github.com/dwmkerr/effective-shell.\n Basic Navigation Searching Editing In-Place Clear the Screen Pro Tip: All The Keys! Pro Tip: Transposing! Closing Thoughts  Basic Navigation Let's assume we have a very simple command we are writing, which is going to write a quote to a text file:\necho \u0026#34;The trouble with writing fiction is that it has to make sense, whereas real life doesn\u0026#39;t. -- Iain M. Banks\u0026#34; \u0026gt;\u0026gt; quote.txt Navigating around long lines of text is a slow process if you are only relying on the arrow keys, so take the time to learn the following shortcuts:\n   Action Shortcut Example     Go to beginning / end Ctrl + a / Ctrl + e    Go backwards / forwards one word Alt + b / Alt + f    Delete a word / undo Ctrl + w / Ctrl + -    Delete next word Alt + d    Delete all the way to the beginning1 Ctrl + u    Delete all the way to the end Ctrl + k     Searching Once you have the basic navigation commands down, the next essential is searching. Let's assume we've run the following three commands:\n$ command1 param1 param2 param3 $ command2 param4 param5 param6 $ command3 param7 param8 param9 You can search backwards or forwards with Ctrl + r and Ctrl + s. This will search in the current command and then iteratively through previous commands:\nThis is useful for searching in the current command, but can be also used to quickly search backwards and forwards through the command history:\nAs you type, your command history is searched, the most recent commands coming first. Use the arrow keys to edit the command, press enter to execute it, or Ctrl + g to cancel the search.\nHere are the same commands applied to the original example:\n   Action Shortcut Example     Search backwards / forwards Ctrl + r / Ctrl + s    Run the command Enter    Edit the command Right Arrow / Left Arrow    Stop searching Ctrl + g     Editing In-Place These tips and tricks are helpful, but if you are working with a really long or complex command, you might find it useful just to jump into your favourite editor.\nUse Ctrl + x , Ctrl + e to edit-in place:\nIn a later article I'll talk a little more about how to configure the default editor.\nClear the Screen Probably the shortcut I use the most is Ctrl + l, which clears the screen without trashing your current command. Here's how it looks:\nPro Tip: All The Keys! You can use the bindkey command to see a list of all keyboard shortcuts:\n$ bindkeys \u0026quot;^@\u0026quot; set-mark-command \u0026quot;^A\u0026quot; beginning-of-line \u0026quot;^B\u0026quot; backward-char \u0026quot;^D\u0026quot; delete-char-or-list \u0026quot;^E\u0026quot; end-of-line \u0026quot;^F\u0026quot; forward-char \u0026quot;^G\u0026quot; send-break \u0026quot;^H\u0026quot; backward-delete-char \u0026quot;^I\u0026quot; expand-or-complete \u0026quot;^J\u0026quot; accept-line \u0026quot;^K\u0026quot; kill-line \u0026quot;^L\u0026quot; clear-screen ... This is an extremely useful command to use if you forget the specific keyboard shortcuts, or just want to see the shortcuts which are available.\nPro Tip: Transposing! If you've mastered all of the commands here and feel like adding something else to your repertoire, try this:\nThe Alt + t shortcut will transpose the last two words. Use Ctrl + t to transpose the last two letters:\nThese were new to me when I was researching for this article. I can't see myself ever being able to remember the commands more quickly than just deleting the last two words or characters and re-typing them, but there you go!\nClosing Thoughts If you are ever looking to go deeper, then search the web for GNU Readline, which is the library used under the hood to handle the command line in many shells. You can actually configure lower level details of how all shells which use readline work, with the .inputrc configuration file.\nThe great thing about learning these shortcuts is that they will work in any prompt which uses GNU Readline. This means everything you've learnt applies to:\n Bash zsh The Python REPL The Node.js REPL  And probably a whole bunch more2.\nAll of these shortcuts should be familar to Emacs users. There is in fact a \u0026lsquo;Vi Mode\u0026rsquo; option for readline, which allows you to use vi commands to work with text. You can enter this mode with set -o vi, I'll likely come back to this in detail in a later article.\nThere's a great cheat sheet on emacs readline commands at readline.kablamo.org/emacs, which is a very useful reference if you want to dig deeper. For this article I've tried to focus on what I think are the most useful commands (and transpose just so you can show off!).\nHope that was useful! GIFs were made with LICEcap.\nFootnotes References  Wikipedia: GNU Readline GNU Org: Readline Init File Kablamo.org: Readline Cheat Sheet    If you are using zsh, then this will clear the entire line. \u0026#x21a9;\u0026#xfe0e;\n If you know of any more, please let me know and I'll update the article! \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':4,'href':'/docs/section1/2-clipboard-gymnastics/','title':"Become a Clipboard Gymnast",'content':"Become a Clipboard Gymnast In this article I'll show you how you can use the shell as an efficient tool to compliment how you use the clipboard.\nNote for Linux Users: In this article I'll use the pbcopy and pbpaste commands to access the clipboard, which are available on a Mac only. To get access to the same commands on other platforms, check Appendix: Clipboard Access on Linux\nUse the Shell on the Clipboard You can easily use shell commands on the contents of your clipboard. Just use pbpaste to output the clipboard, run the output through some commands, then use pbcopy to copy the result.\nTry copying the following text:\nKirk Van Houten Timothy Lovejoy Artie Ziff Then in the shell, run:\npbpaste You should see the contents of the clipboard. Now we'll look at some ways that shell access to the clipboard can help with common tasks.\nRemoving Formatting Don't you hate it when you have to copy formatted text and don't have an easy way to paste it as unformatted text? Here's an example, I want to copy this Wikipedia page on \u0026lsquo;bash\u0026rsquo;, and paste it into a Word document:\nMany programs have a shortcut to paste the contents of the clipboard (such as \u0026lsquo;command + shift + v\u0026rsquo;) but if you are like me you might find yourself pasting into a plain text editor just to copy out the plain text.\nIf you just run the command pbpaste | pbcopy, you can easily strip the formatting:\nWe're just piping out the clipboard (which ends up as plain text, cause we're in a terminal!) and then piping that plain text back into the clipboard, replacing the formatted text which was there before.\nThis little trick can be very useful. But we can use the same pattern to quickly manipulate the contents of the clipboard in more sophisticated ways.\nManipulating Text Let's say someone has emailed me a list of people I need to invite to an event:\nThe problem is:\n The list is in Excel and is formatted The list has duplicates I need to turn each name into an email address like 'Artie_Ziff@simpsons.com\u0026rsquo;  And I want to email everyone quickly.\nWe can quickly handle this task without leaving the shell.\nCopy the raw text below if you want to try out the same commands and follow along:\nArtie Ziff Kirk Van Houten Timothy Lovejoy Artie Ziff Nick Riviera Seymore Skinner Hank Scorpio Timothy Lovejoy John Frink Cletus Spuckler Ruth Powers Artie Ziff Agnes Skinner Helen Lovejoy First, we copy the text to the clipboard.\nNow we can paste and sort:\n$ pbpaste | sort Agnes Skinner Artie Ziff Artie Ziff Artie Ziff Cletus Spuckler Hank Scorpio Helen Lovejoy John Frink Kirk Van Houten Nick Riviera Ruth Powers Seymore Skinner Timothy Lovejoy Timothy Lovejoy Then remove the duplicates:\n$ pbpaste | sort | uniq Agnes Skinner Artie Ziff Cletus Spuckler Hank Scorpio Helen Lovejoy John Frink Kirk Van Houten Nick Riviera Ruth Powers Seymore Skinner Timothy Lovejoy Replace the space with an underscore:\n$ pbpaste | sort | uniq | tr \u0026quot; \u0026quot; \u0026quot;_\u0026quot; Agnes_Skinner Artie_Ziff Cletus_Spuckler Hank_Scorpio Helen_Lovejoy John_Frink Kirk_Van_Houten Nick_Riviera Ruth_Powers Seymore_Skinner Timothy_Lovejoy Then add the final part of the email address:\n$ pbpaste | sort | uniq | tr \u0026quot; \u0026quot; \u0026quot;_\u0026quot; | sed 's/$/@simpsons.com/' Agnes_Skinner@simpsons.com Artie_Ziff@simpsons.com Cletus_Spuckler@simpsons.com Hank_Scorpio@simpsons.com Helen_Lovejoy@simpsons.com John_Frink@simpsons.com Kirk_Van_Houten@simpsons.com Nick_Riviera@simpsons.com Ruth_Powers@simpsons.com Seymore_Skinner@simpsons.com Timothy_Lovejoy@simpsons.com This looks perfect! We can now put the transformed text back onto the clipboard:\n$ pbpaste | sort | uniq | tr ' ' '_' | sed 's/$/@simpsons.com' | pbcopy All in all we have the following pipeline:\n pbpaste - output the clipboard sort - order the output uniq - deduplicate the rows tr ' ' '_' - replace spaces with underscores sed /$/@simpsons.com - add the email domain to the end of the row  Building this in one go is hard, let's look at little more at the pipeline.\nI hope this was useful! Please comment if you have any questions or tips. To see further articles as they come out, follow the repo at:\ngithub.com/dwmkerr/effective-shell\nOr just follow @dwmkerr on Twitter.\nThinking in Pipelines Some of these commands might be unfamiliar, some might not make sense, and you might be thinking \u0026lsquo;how would I remember that\u0026rsquo;. Actually, there are many ways to solve the problem above, this is the one I came up with by iteratively changing my input text.\nHere's what I mean - you'll see that I actually build a pipeline like this step-by-step:\n(P.S - if you are wondering how I am jumping backwards and forwards a word at a time, check the last chapter \u0026lsquo;Navigating the Command Line').\nWhat we're doing here is only possible because these simple commands all follow \u0026lsquo;the Unix Philosophy\u0026rsquo;. They do one thing well, and each command expects it's input to become the input of another command later on. Specifically:\n The commands are primitive and simple - sort is sorting a list, uniq is making elements unique. The commands don't produce unnecessary output - sort doesn't add a header such as Sorted Items, which is great because otherwise it would clutter our pipeline. We are chaining commands together, the output of one becomes the input of another.  We don't need a command such as \u0026lsquo;Take a muddy list, sort and clean it, then turn pairs of words into an email address\u0026rsquo; - with a few simple \u0026lsquo;workhorse\u0026rsquo; commands we can easily build this functionality ourselves.\nThese workhorse commands will be introduced and detailed as we go through the series. We'll also spend a lot more time looking at pipelines.\nAppendix - Clipboard Access on Linux If you are using Linux, there is no pbcopy and pbpaste commands. You can use the xclip tool to create equivalent commands.\nFirst, install xclip:\nsudo apt-get install -y xclip Then add the following to your .bashrc file:\n# Create mac style aliases for clipboard access. alias pbcopy=\u0026#34;xclip -selection c\u0026#34; alias pbpaste=\u0026#34;xclip -selection c -o\u0026#34; Obviously you can use any alias you like! The article assumes that pbcopy and pbpaste have been used.\n"});index.add({'id':5,'href':'/docs/section1/3-getting-help/','title':"Getting Help",'content':"Getting Help In this article I'll show you how to quickly get help when working with tools in the shell, without disrupting your flow!\nGetting Help is Important! If you are trying to be more effective when using the shell, it is crucial to know how to quickly look things up.\nThere'll be many circumstances where you'll need to open a browser to search for help, but there's also a wealth of information only a few keystrokes away. Looking up parameters, checking how to run commads, C library docs or useful information like ASCII charts are available directly in the system.\nBefore we look at the standard way of accessing documentation on unix-like systems, which is the man command, I'm going to introduce tldr.\nNine times out of ten I get the help I need in a few seconds with tldr, so if you take only one thing away from the article, take the first section. Then if you want to learn more about the system manuals, read on!\ntl;dr Let's say I need to find and replace some text in a file. I know I can do this with the sed command, but have forgotten the syntax.\nAll I need to do is run tldr sed:\nThe first example is exactly what I'm looking for. Now for any more detail than a few basic examples, I'm going to have to go to the manual, but it's overkill for the basics. Here's what man sed shows me:\nAnd this is just page one of six! There's a lot of detail, which is great sometimes, but for a quick lookup, tldr is perfect.\nYou can install the tldr tool with npm install -g tldr. It's open source and community maintained.\nNow a lot of the time, you are still going to need more help or more detail. For the rest of the article, we'll dive a bit deeper into man, the system manual pages.\nUnderstanding \u0026lsquo;man\u0026rsquo; Most tools you encounter in the shell have manual pages available. Many people will be familiar with the man command to get help on a tool, but let's take a look in a bit more detail, there's actually a lot more available than just the documentation for common commands.\nGetting help on a command The most basic way to get help on a command is with man. Here's an example:\n$ man cp CP(1) BSD General Commands Manual CP(1) NAME cp -- copy files SYNOPSIS cp [-R [-H | -L | -P]] [-fi | -n] [-apvX] source_file target_file cp [-R [-H | -L | -P]] [-fi | -n] [-apvX] source_file ... target_directory DESCRIPTION In the first synopsis form, the cp utility copies the contents of the source_file to the target_file. In the second synopsis form, the con- tents of each named source_file is copied to the destination target_directory. The names of the files themselves are not changed. If cp detects an attempt to copy a file to itself, the copy will fail. ... The man command opens the manual for the given tool. These manuals should contain all command line options and details of how to use the tool.\nYou can scroll up and down through the content with the arrow keys, this is because the information is presented in the shell pager, which is a tool for looking through content which might not easily fit on a screen.\nUsing the pager The first thing you might notice is that you can move through the manual pages with the arrow keys.\nManpages are just text files, and man opens them in a pager tool, which is what is providing the keyboard interface to look through the file.\nOn most systems, the pager will be the less program. There are lots of commands you can use to navigate through files with less, but the bare essentials are:\n d - Scroll down half a page u - Scroll up half a page j / k - Scroll down or up a line. You can also use the arrow keys for this q - Quit /\u0026lt;search\u0026gt; - Search for text n - When searching, find the next occurrence N - When searching, find the previous occurrence  There are many other commands, but the set above is normally what I find myself using the most.\nIf you are interested, you can actually see what your pager is with the command below:\n$ echo $PAGER less The $PAGER environment variable is used to tell the shell what program to use for paging. More details are found with man man.\nYou can put any text content into your pager - try this:\nls -al /usr/bin | less This lists the contents of the /usr/bin folder, piping the output to less so we can easily scroll through it.\nThere are alternative pagers available (on many Unix-y systems you'll have less, more and most) but in general you'll normally get what you need with less.\nWhat's with the numbers? You'll often see tools referred to in manpages with numbers after them. Take a look at man less:\nThe number is the manual Section Number. The different sections of the manual are documented be found on most unix-like systems in man's documentation, which you can check by running man man1. Here's what you'd get on Ubuntu 16:\n Section 1 - Executable programs or shell commands Section 2 - System calls (functions provided by the kernel) Section 3 - Library calls (functions within program libraries) Section 4 - Special files (usually found in /dev) Section 5 - File formats and conventions eg /etc/passwd Section 6 - Games Section 7 - Miscellaneous (including macro packages and conventions), e.g. man(7), groff(7) Section 8 - System administration commands (usually only for root) Section 9 - Kernel routines [Non standard]  We'll go through the setions in detail shorltly.\nYou can specifically choose which section of the manual you are looking in by using:\nman \u0026lt;section\u0026gt; \u0026lt;search\u0026gt; You can also get more information about the sections themselves by opening up the intro page. For example:\n$ man 1 intro INTRO(1) BSD General Commands Manual INTRO(1) NAME intro -- introduction to general commands (tools and utilities) DESCRIPTION Section one of the manual contains most of the commands which comprise... Why would you do this, and why would you care? A few examples from each section show how this can be quite useful to know about.\nSection 1: Programs and Shell Commands These are programs, probably what you are going to be looking up most regularly! For example, man 1 time shows:\nTIME(1) BSD General Commands Manual TIME(1) NAME time -- time command execution SYNOPSIS time [-lp] utility DESCRIPTION The time utility executes and times utility. After the utility finishes, time writes the total time elapsed, the time consumed by system overhead, and the time used to execute utility to the standard error stream. Times are reported in seconds. ... Section 2: System Calls You'll probably not use this section unless you are doing systems programming2. This section contains info on the avaiable Linux Kernel system calls. For example, running man 2 chown gives:\nCHOWN(2) BSD System Calls Manual CHOWN(2) NAME chown, fchown, lchown, fchownat -- change owner and group of a file SYNOPSIS #include \u0026lt;unistd.h\u0026gt; int chown(const char *path, uid_t owner, gid_t group); ... Section 3: Library Calls These are the manpages for the C standard library functions. For example, man 3 time:\nTIME(3) BSD Library Functions Manual TIME(3) NAME time -- get time of day LIBRARY Standard C Library (libc, -lc) SYNOPSIS #include \u0026lt;time.h\u0026gt; time_t time(time_t *tloc); ... Here we can see why the sections are important to know about.\nRunning man time would not open the page above, because man searches the library in ascending section order, meaning that it actually finds time(1) and shows the pages for the time program, not the time C library call.\nBecause of the potential ambiguity of names if no section number is included, in lots of Linux documentation you'll see the man section number written next to library calls, system calls, programs and so on (things will refer to sed(1) or time(3) for example.\nSection 4: Devices This section deals with the special devices which live in the /dev/* folder. For example, running man 4 random shows:\nRANDOM(4) BSD Kernel Interfaces Manual RANDOM(4) NAME random , urandom -- random data source devices. SYNOPSIS pseudo-device random DESCRIPTION The random device produces uniformly distributed random byte values of potentially high quality. ... Again, we see that section numbers can be important. If you just run man random, you'll see:\nRANDOM(3) BSD Library Functions Manual RANDOM(3) NAME initstate, random, setstate, srandom, srandomdev -- better random num- ber generator; routines for changing generators LIBRARY Standard C Library (libc, -lc) SYNOPSIS #include \u0026lt;stdlib.h\u0026gt; char * initstate(unsigned seed, char *state, size_t size); long random(void); ... Which is the manpage for random(3), which is C library function, not the /dev/random file!\nSection 5: File Formats This section details special files in the system. For example, man 5 crontab shows:\nCRONTAB(5) BSD File Formats Manual CRONTAB(5) NAME crontab -- tables for driving cron DESCRIPTION A crontab file contains instructions to the cron(8) daemon of the gen- eral form: ``run this command at this time on this date''. Each user has their own crontab, and commands in any given crontab will be exe- cuted as the user who owns the crontab. Uucp and News will usually have their own crontabs, eliminating the need for explicitly running su(1) as part of a cron command. ... Which describes the crontab file used to define scheduled tasks. Again, this is different to man crontab which would document crontab(1). Similarly, man 5 passwd is going to show something quite different to man passwd.\nSection 6: Games Nothing says it better than man 6 intro itself (this'll not work on a Mac sadly, but try it on another Linux system):\n... DESCRIPTION Section 6 of the manual describes all the games and funny little programs available on the system. ... There are probably a few silly programs available on your system, here you'll find their manuals. For example, man 6 banner on a Mac shows:\nBANNER(6) BSD Games Manual BANNER(6) NAME banner -- print large banner on printer SYNOPSIS banner [-d] [-t] [-w width] message ... DESCRIPTION Banner prints a large, high quality banner on the standard output. If the message is omitted, it prompts for and reads one line of its stan- dard input. ... This section is going to be highly dependent on your OS!\nSection 7: Miscellaneous This is where you'll find additional assorted documentation. For example, man 7 ascii shows:\nASCII(7) BSD Miscellaneous Information Manual ASCII(7) NAME ascii -- octal, hexadecimal and decimal ASCII character sets DESCRIPTION The octal set: 000 nul 001 soh 002 stx 003 etx 004 eot 005 enq 006 ack 007 bel ... Section 8: System Commands We've actually already seen one of these commands mentioned, in the manpage for crontab(5) it mentions cron(8). Let's see, with man 8 cron:\nCRON(8) BSD System Manager's Manual CRON(8) NAME cron -- daemon to execute scheduled commands (Vixie Cron) SYNOPSIS cron [-s] [-o] [-x debugflag[,...]] These are commands which sysadmins would normally run. You might open section eight unexpectedly, for example man chmod will open chmod(1), but man chown will open chown(8), as it is a system command.\nSome distributions might vary for section nine. On my Mac it contains information about the kernel interfaces, a C style guide and some more.\nGetting the Index of Manual Section Manpages are just files on the filesystem, so you can get the index of a section just by looking in the appropriate folder.\nFor example, to index the available system calls, try ls /usr/share/man/man2:\nEV_SET.2 FD_CLR.2 FD_COPY.2 FD_ISSET.2 FD_SET.2 FD_ZERO.2 _exit.2 accept.2 access.2 acct.2 ... This is quick and easy way to see what sort of entries you have on your system. If you want to work out where an entry lives, use the -w flag:\n$ man -w printf /usr/share/man/man1/printf.1 Searching the Manual You can search the manpage titles and summaries with man -k. For example, man -k cpu shows:\ncpuwalk.d(1m) - Measure which CPUs a process runs on. Uses DTrace dispqlen.d(1m) - dispatcher queue length by CPU. Uses DTrace gasm(n), grammar::me::cpu::gasm(n) - ME assembler You can find more advanced options for searching by using your newfound man skills on man itself.\nThat's Enough! I'd recommend tldr as a first-call for checking to see how to use a command.\nman is a powerful tool to dive deeper into how programs and components of the system work. Like many tools which have been around for a long time, there's a lot you can do with man. Much of it you'll likely never need, so I've tried to keep this article to the basics.\nUnderstanding manpage sections is useful - you'll see them referenced again and again in documentation on the system and online.\nI hope this helps you save some time when you are working! Please let me know in the comments if you have any questions or thoughts.\nYou can also check out the rest of the effective shell series.\nAppendix: Dash As a final note, if you find yourself using man a lot because you work offline (I fly a lot so find it very helpful when on a plane with no WiFi), you should also look at Dash3.\nDash is simply an offline documentation aggregator. It can download online manuals for many, many different programming languages, frameworks, technologies and so on. I actually have a vim keyboard command to open the word under the cursor in dash, with the documentation automatically set based on the type of the file.\nThis is super-useful if you are offline at lot and need more sophisticated offline documentation. You can find out more about it at https://kapeli.com/dash.\nFootnotes   Weirdly satisfying to run. \u0026#x21a9;\u0026#xfe0e;\n Which it is always fun to try if you get the chance, and a great way to learn more about the fundamentals of the operating system. \u0026#x21a9;\u0026#xfe0e;\n Dash is a paid product. Full disclosure - I don't get any money from them or anyone else to write about anything, all content is 100% based on my experiences. I don't run ads on my site either. \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':6,'href':'/docs/section1/4-moving-around/','title':"Moving Around",'content':"Moving Around You might already spend a lot of time in the shell, running various command line programs or using tooling for development projects or operational tasks. But you might also still switch back to a more visual paradigm for working with files, directories and resources.\nBeing able to perform everyday file and folder manipulation tasks directly from the shell can really speed up your workflow. Let's look at some common tasks and see how we can work with them in the shell. Along the way we'll also introduce some of the most frequently used tools and commands to work with the filesystem.\nWhere Am I? The first command to become familiar with is pwd (\u0026lsquo;print working directory\u0026rsquo;). This command will echo the current absolute path. You can also use the $PWD environment variable:\n$ pwd /Users/dave/repos/github/dwmkerr/effective-shell $ echo $PWD /Users/dave/repos/github/dwmkerr/effective-shell Depending on your shell, or your command-line setup (which we will discuss in a later chapter), you might also see your working directly on the command-line.\nChanging Directory Most likely one of the most familiar commands out there, the cd or chdir function changes the current directory:\n$ pwd /Users/dave/repos/github/dwmkerr/effective-shell $ cd $ pwd /users/dave $ cd - ~/repos/github/dwmkerr/effective-shell $ pwd /Users/dave/repos/github/dwmkerr/effective-shell $ cd ~ $ pwd /users/dave Here we can see that running cd with no parameters moves to the users \u0026lsquo;home\u0026rsquo; directory. This directory is always available in the $HOME environment variable.\nRunning cd - will switch back to the previous directory — this is very useful if you want to quickly jump somewhere and then back again.\nYou can use ~ as an alias for the home directory, allowing you to quickly move to personal folders, with commands such as cd ~/Downloads.\nMost commonly, you will specify a path when changing directory. This can be a fully qualified path, or it can be a relative path:\n$ cd /dev $ cd ~/repos $ cd ./github You can use the special link .., which is a folder that points to the parent directory to move \u0026lsquo;upwards\u0026rsquo;:\n$ pwd /Users/dave/repos/github/dwmkerr/effective-shell $ cd ../../ $ pwd /Users/dave/repos/github Exploring a Directory Once we are in a directory, we will often want to see the contents. The ls (\u0026ldquo;list directory contents\u0026rdquo;) command is useful here:\n$ pwd /Users/dave/repos/github/dwmkerr/effective-shell $ ls 1-navigating-the-command-line LICENSE 2-clipboard-gymnastics README.md 3-getting-help sed.1 4-moving-around By default, the ls command will list the files and directories. We can show more information with the -l (\u0026ldquo;long format\u0026rdquo;) flag:\n$ ls -l total 48 drwxr-xr-x 6 dave staff 192 Mar 5 16:01 1-navigating-the-command-line drwxr-xr-x 5 dave staff 160 Oct 10 2017 2-clipboard-gymnastics drwxr-xr-x 4 dave staff 128 Dec 19 2017 3-getting-help drwxr-xr-x 3 dave staff 96 Mar 7 15:39 4-moving-around -rw-r--r-- 1 dave staff 1066 Jun 10 2017 LICENSE -rw-r--r-- 1 dave staff 561 Mar 7 15:30 README.md -rw-r--r-- 1 dave staff 15707 Mar 5 16:01 sed.1 Now we can see the permissions, the link count (which is rarely particularly useful and varies from platform to platform), the owner, the group, the size and the modification date (as well as the name).\nWe can make the sizes more human readable, and sort by size with a few more flags -h (\u0026ldquo;human readable\u0026rdquo;) and -s (\u0026ldquo;sort by size\u0026rdquo;):\n$ ls -lhS total 48 -rw-r--r-- 1 dave staff 15K Mar 5 16:01 sed.1 -rw-r--r-- 1 dave staff 1.0K Jun 10 2017 LICENSE -rw-r--r-- 1 dave staff 561B Mar 7 15:30 README.md drwxr-xr-x 6 dave staff 192B Mar 5 16:01 1-navigating-the-command-line drwxr-xr-x 5 dave staff 160B Oct 10 2017 2-clipboard-gymnastics drwxr-xr-x 4 dave staff 128B Dec 19 2017 3-getting-help drwxr-xr-x 3 dave staff 96B Mar 7 15:39 4-moving-around There are lot of options for ls. Check the chapter Getting Help for some tips on how to get more information on a command!\nManaging the Directory Stack You might find that you want to move to a number of directories, then return to where you started. This can be particularly useful when scripting. You can use the pushd (\u0026ldquo;push onto directory stack\u0026rdquo;) and popd (\u0026ldquo;pop from directory stack\u0026rdquo;) commands to add or remove directories from the stack:\n$ pwd /Users/dave/repos/github/dwmkerr/effective-shell # OK - I\u0026#39;m writing my article at the moment, but want to check my downloads, and come back shortly... # Move to the downloads folder... $ ls aws-nuke-v2.8.0-darwin-amd64 # OK cool - the tool I was downloading has arrived, let\u0026#39;s use it... cd aws-nuke-v2.8.0-darwin-amd64 ./aws-nuke # Now I want to go back to my article... $ popd ~/Downloads ~/repos/github/dwmkerr/effective-shell ~/Downloads $ popd ~/repos/github/dwmkerr/effective-shell In this case, using cd - would not be sufficient — that would just switch us from the aws-nuke folder to Downloads and back again. But by using the directory stack we can save where we are, move, and then \u0026lsquo;pop\u0026rsquo; our way back to where we started.\nAuto-Completion Pressing tab when using commands like cd will generally show an auto-completion menu:\n$ cd ~/repos/ # press \u0026#39;tab\u0026#39; now... github/ gitlab/ local/ scratch/ Pressing tab again will cycle through options, and shift-tab will cycle backwards. Enter will select an option, escape (or Ctrl-C) will cancel.\nSome shells, such as zsh, support even more advanced auto-completion. For example, we can auto-complete to fill in partially specified directory names:\n% cd ~/r/g/d/e # press tab now...\u000c% cd ~/repos/github/dwmkerr/effective- effective-container-engineering/ effective-shell/ Auto-completion is generally very shell specific. We'll look more into the different shells that are available in later chapters. But in general, if you are uncertain, pressing tab will often show a sensible set of options.\nThat's It! This is a small chapter, but an important one. Later on, as we start to do more file and system manipulation from the shell, moving and copying files and so on, we will build on these concepts. But it is critical to first know the basics of how to move around the filesystem with the shell.\n"});index.add({'id':7,'href':'/docs/part-1-transitioning-to-the-shell/5-getting-started-with-the-shell/','title':"Getting Started with the Shell",'content':"Getting Started with the Shell If you have never used the shell before, then this is where we'll start. We're not going to go into lots of detail, there's plenty of that later on in book. Instead we'll do a quick crash course on the basics. If you have not used the shell before this'll give you a chance to see how it works.\nStart by opening your shell. This is covered in Opening the Shell. Your shell should be Bash - if this doesn't sound familiar, then make sure you have followed the instructions in Configuring the Shell.\nYou should see your terminal program running your shell. You can see what the version is of your shell by running:\nbash --version Let's quickly dissect this. We have run the bash command. A command can be a program on your computer, or it can be something built into the shell. We'll look at this in a lot more detail later, but for now it's important to understand that a lot of what you will be doing is running commands.\nThe --version text is a parameter. Parameters affect how commands work. This is actually easier to see with an example.\nLet's move to the home folder. On most computers your home folder is your personal space where things like documents, photos, music, downloads and so on are kept.\nLet's switch to the home folder by running the following command:\ncd ~ Once you've done that, run the pwd command:\npwd So what has happened here? The first command:\ncd ~ Is used to change directory - that's what cd stands for. The parameter we passed to cd was just the \u0026lsquo;tilde\u0026rsquo; character (~). This character has a special meaning in the shell - it means \u0026ldquo;the current user's home directory\u0026rdquo;.\nFinally, we ran the pwd command. This command is short for print working directory. It writes out to the screen where you currently are. On my Mac, my home directory is located at /Users/dwmkerr, which is what the command has shown me.\nLet's take another look at a command. Run the following in your shell:\nls The ls command is short for list directory contents - it shows you everything that is in the current directory. On my computer you can see things like the \u0026lsquo;Downloads\u0026rsquo;, \u0026lsquo;Music\u0026rsquo; and \u0026lsquo;Pictures\u0026rsquo; folders, which are set up by default on a Mac, as well as some of my own folders.\nWe can pass different parameters to ls. The main parameter is the location of the folder we'd like to list the contents of. So if we wanted to see what was in the Music folder, we'd just run:\nls Music Not much to see here:\nMany commands actually allow us to pass multiple parameters. For example, we could list the contents of my Movies and my personal applications:\nls Movies Applications There's not much in either. You might wonder why Applications is so empty - that's because we're looking at the applications only installed for the current user, because we are in the user's home directory. To see the applications for everyone we'd need to use the folder where applications are kept for all users.\nWe can do this by running ls /Appliciations:\nThe trick here is that we start with a leading forward slash - this means the Applications folder in the root of the computer, not the one in my current folder.\nOn Windows, applications are kept in different places, but we can see some of the installed applications by running ls \u0026quot;c:\\program files\\\u0026quot;:\nWhy do we have the extra quotation marks here? If we ran the command without the quotation marks, the shell would think we were giving it two parameters. It would think we wanted to see the contents of the c:\\program and files folders - and they don't exist!\nThe error above shows what happens when we miss the quotation marks.\nNow we can take a look at how a flag would work. A flag is a parameter which changes how a command works. Flags normally start with a hyphen. Let's say we wanted to know the size of the files in the folder. We do this by using the -lh pass the parameter, which is short for long list, human readable:\nls -lh Downloads/*.jpg Now I can see all of the jpg files (jpg files are images) in my Downloads folder. I can see it looks like I've got two pictures of \u0026ldquo;Mardi Himal\u0026rdquo; (a mountain in the Himalayas) which are both 384 Kilobytes in size, as well as some other images. Blow by blow, this is what we've got:\n ls - List the contents of a folder -lh - This is the long list in human-readable sizes parameter, which means we see how big the files are in a friendly format (like 911K for Kilobytes, rather than showing something like 911012 which would be the number of bytes - and harder to read!) Downloads/*.jpg - Show the contents of the Downloads folder, including any files which end with .jpg - the * is a wildcard which means that we don't mind what the filename is  The -lh parameter is shorthand. Many commands offer longhand parameters (such as --version) as well as shorthand (such as -v as an alternative for --version). Longhand is easier to read, shorthand is faster to type.\nDon't worry - in the next section we'll see how to look up the available parameters for a command. You don't need to remember all of these details, only understand which part is the command and which parts are the parameters. This is just an introduction for now!\nNow let's look at one more command.\nThe Echo Command The \u0026lsquo;echo\u0026rsquo; command is used to write out a message in the shell. Here's an example of how it works:\necho \u0026#34;Hello Shell!\u0026#34; This command writes out the text Hello Shell!:\nWhy would we do this? One of the most common reasons would be to see what the shell thinks a certain value is. For example, try this command:\necho \u0026#34;My home directory is at: $HOME\u0026#34; You'll see something like this:\nThe $HOME part of the text is called a variable. We can recognise variables because they start with a dollar symbol. $HOME is a built-in variable which holds the location of the current user's home directory.\nWe're going to see all sorts of cool things we can do with echo as we continue in the book!\nMove Around One common thing we can do in a visual file explorer is move around. We can open folders, and go \u0026lsquo;up\u0026rsquo; from the current folder. We often also see visually where we are in the folder structure with an \u0026lsquo;address bar\u0026rsquo;.\nA useful reference might be the picture below:\nHere we map the shell commands to the visual interface's equivalents:\n pwd shows the current working directory - where you currently are in the file system ls lists the files in the current directory (or any directory you tell it) cd .. changes the directory to another location - if you use the special .. directory, you are telling it to change to the parent directory, i.e. \u0026lsquo;go up\u0026rsquo; in the file system  As a final trick, lets see how we open a file or folder. Let's say I want to open one of the photos in my Downloads folder. Here's how I can do it:\ncd ~/Downloads open himalayas.jpg We can see the result here:\nRunning open himalayas.jpg has opened the photo in the application which is used for photos by default in the operating system.\nBe aware - this command is different on different operating systems (but we're going to see later on how to fix that and make it consistent everywhere!). The open command will open a file on MacOS. On Windows you can use start, and on Linux you can generally use xdg-open.\nAs a nifty trick, trying running open .1:\n. This will open the current folder. Every folder contains two \u0026lsquo;special\u0026rsquo; folders. The first is .., which we've seen means \u0026lsquo;my parent folder\u0026rsquo; and the second is ., which means \u0026lsquo;myself\u0026rsquo;. Having this . folder is convenient, as it means we can do things like this - run a command to open the current folder.\nWe're going to go into a lot more detail on how to work with files and folders, move around, but hopefully this has provided a crash course for the basics. They key concepts to remember, which are much more important than the individual commands we've see are:\n In the shell we run commands We can change how commands work by using parameters Some parameters just go at the end of the command - like ls Downloads Some parameters start with a hyphen, and change how the command behaves - these are often called \u0026lsquo;flags\u0026rsquo;. An example is ls -lh, which lists the files in the current folder with a human-readable file size  We've also learned:\n cd changes the current directory pwd prints the current directory ls lists the files in a directory echo can be used to write out text to the screen open, start and xdg-open can be used to open a file or folder on MacOS, Windows and Linux respectively  Now we can start to get into more detail!\n Footnotes   On Windows you might need to run start . and on Linux, xdg-open .. \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':8,'href':'/docs/section1/5-what-is-a-shell/','title':"What is a Shell?",'content':"This is the first \u0026lsquo;interlude\u0026rsquo; in my Effective Shell series. These interludes give some background, history or more flavour to some of the topics.\nThis one should be high-level enough for even non-technical readers to enjoy (or at least understand!). I've tried to make sure any term that might be unfamiliar is described in a footnote1. For the more technical reader, it provides an important grounding on some of the key concepts relating to shells and how they work.\nIntroduction for the Non-Technical Reader It might come as a surprise that many technical computer users (programmers, data scientists, systems administrators etc) spend a lot of time using an interface which looks like it's from the sixties:\nIf you work with technologists, you might have seen them using an interface like this. This kind of simple, text-based interface is called a shell, and it has been a common way to interface with computers ever since the first screens and keyboards were created.\nGiven how much computing has advanced, why would people use such an interface? Just look at how much the Windows operating-system has changed over the last three decades:\n(By Source (WP:NFCC#4), Fair use, https://en.wikipedia.org/w/index.php?curid=58853841)\nWhy would people choose to use such an archaic interface as a shell?\n Typing is fast: A skilled shell user can manipulate a system at dazzling speeds just using a keyboard. Typing commands is generally much faster than exploring through user interfaces with a mouse Shells are programmable: Users will often being programming as they work in a shell, creating scripts to automate time-consuming or repetetive processes Shells are portable: A shell can be used to interface to almost any type of computer, from a mainframe to a Raspberry Pi, in a very similar way.  Not all technical users will use a shell regularly, but there are many who will spend the bulk of their time in such an interface. It is such a crucial skill to be able to operate one effectively that I have been writing this series primarily to show ways to be more efficient with this kind of interface.\nIntroduction for the Technical Reader You may be familiar with the shell, but it can be useful to understand some of the surrounding concepts in detail. How does a shell differ from a terminal? What is a tty? How do shells really work? Hopefully as you read this article you'll discovery something that you didn't know about shells.\nLet's Get Started! To understand what shells, terminals, command-prompts and so on are and how they relate, we need to start with the basics: how a modern computer works!\nA Computer in a Nutshell The diagram below shows a simplified view of a typical computer:\nAlready there's a lot going on.\nYour computer is going to have a CPU2 and memory3, and almost certainly a network adapter4 and display adapter5. Most computers will have at least one hard disk. For home PCs, there'll also likely be a bunch of peripherals, such as a mouse, keyboard, printers, flash drives, webcams and so on.\nThe Operating System The operating system is the piece of software installed on a computer that can interface with the hardware. Without hardware, such as a CPU, memory, a network adapter, a graphics card, disk drives and so on, there's not much that you can do with the computer. The operating system is the primary interface to this hardware. No normal programs will talk to hardware directly - the operating system abstracts this hardware away and provides a software interface to it.\nThe abstraction the operating system provides is essential. Developers don't need to know the specifics of how to work with individual devices from different vendors; the operating system provides a standardised interface to all of this. It also handles various tasks such as making sure the system starts up properly.\nThe operating system is generally broken down into two parts - the kernel and user space:\nLet's look at these in more detail.\nThe Kernel This is the part of the operating system that is responsible for the most sensitive tasks: interfacing with physical devices, managing the resources that are available for users and programs, starting up the various systems that are needed, and so on.\nSoftware running in the kernel has direct access to resources, so is extremely sensitive. The kernel will balance resources between the programs in user space, which we'll look at shortly. If you've ever had to install \u0026lsquo;drivers\u0026rsquo;, these are examples of pieces of software that will run in the kernel - they'll have direct access to a physical device you've installed, and expose it to the rest of the software on the computer.\nWhy \u0026lsquo;kernel\u0026rsquo;? The kernel is the soft, edible part of a nut or seed, which is surrounded by a shell. Below you can see a walnut - the kernel is the soft bit in the middle, and the shell surrounds and protects it. This is a useful metaphor that is used for parts of a computer.\n(By Kkchaudhary11 - Own work, CC BY-SA 4.0, https://commons.wikimedia.org/w/index.php?curid=49069244)\nThe operating system kernel really is the core of the operating system. It's such a sensitive area of the operating system that we actually want to avoid running software in it if possible6. And that is where user space comes in.\nUser Space The vast majority of programs run in \u0026lsquo;user space\u0026rsquo; (also commonly called \u0026lsquo;user land\u0026rsquo;).\nWhen a program starts, the kernel will allocate it a private segment of memory and provide limited access to resources. The program is given access to a library of functions by the operating system, which it can use to access resources such as files, devices and so on. Programs in user space are essentially in sandboxes, where there is a limit to how much damage they can do.\nFor example, a program running in user space can use the standard fopen function, which is provided on almost every operating system as part of the C Standard Library. This allows a program to attempt to open a file. The operating system will make a decision on whether the program is allowed to open the file (based on things such as permissions, where the file is and so on) and then, if it is OK with the call, will give the program access to the file. Under the hood, this \u0026lsquo;user space\u0026rsquo; call translates to a system call in the kernel.\nNow that the key components have been introduced, we can look at the shell. The name should come as no surprise, as it is a wrapper or outer layer to the operating system (which itself contains the sensitive nugget of the kernel).\nThe Shell So what is the shell? The shell is just a general name for any user space program that allows access to resources in the system, via some kind of interface.\nShells come in many different flavours but are generally provided to aid a human operator in accessing the system. This could be interactively, by typing at a terminal, or via scripts, which are files that contain a sequence of commands.\nFor example, to see all of the files in a folder, the human operator could write a program in a language such as C, making system calls to do what they want. But for day-to-day tasks, this would be repetitive. A shell will normally offer us a quick way to do that exact task, without having to manually write a program to do it.\nHere's an example, where a shell is being used to show the \u0026lsquo;png\u0026rsquo; images in the folder I am working in7:\nSo a shell is a user-space program to interface with the computer. But there a few more moving parts than just a shell we are seeing in the image above. There are different types of shells, there are terminal programs, and there are the programs or commands that the shell calls (in the example above, tree is a program). Let's pick these apart.\nHere's a diagram that more accurately shows what is going on:\nWe've introduced a few new things here. There's a user, who is interfacing with a terminal, which is running a shell, which is showing a command prompt. The user has written a command that is calling a program (in this case, the tree program).\nLet's dissect this bit by bit.\nThe Terminal We're not directly interacting with the \u0026lsquo;shell\u0026rsquo; in this diagram. We're actually using a terminal. When a user wants to work with a shell interactively, using a keyboard to provide input and a display to see the output on the screen, the user uses a terminal.\nA terminal is just a program that reads input from the keyboard, passes that input to another program (normally a shell), and displays the results on the screen. A shell program on its own does not do this - it requires a terminal as an interface.\nWhy the word terminal? This makes sense when you look at how people interfaced with computers historically. Input to a computer might be through punch cards, and output would often be via a printer. The Teletype Termimal8 became a common way for users to interface with computers.\n(Photograph by Rama, Wikimedia Commons, Cc-by-sa-2.0-fr, CC BY-SA 2.0 fr, https://commons.wikimedia.org/w/index.php?curid=17821795)\nAt this time, computers were very large, complex, and expensive machines. It was common to have many terminals connected to a single large machine (or \u0026lsquo;mainframe\u0026rsquo;), or a few terminals that people would share. But the terminal itself was just a human interface to the operating system. A more modern terminal would be something like an IBM 3486:\n(By ClickRick - Own work, CC BY-SA 3.0, https://commons.wikimedia.org/w/index.php?curid=6693700)\nThis is a very small computer in its own right but still basically just a dumb screen and keyboard connected by a cable to a larger mainframe computer in another location.\nThis mechanism is still very much the case today. When I want to work with a computer in a data centre, I don't go and find the machine, plug in a keyboard and a display and directly interface to it. I run a terminal program on my computer to provide access to the remote machine. My terminal program allows me to use my keyboard and display to work with a remote machine - all via a secure shell - which is a secured-shell connection over a network.\nSo terminals in many ways are quite simple - they are interfaces. But because they are quite simple programs, we can't do much with them. So normally, the first thing that a terminal program will do is run a shell program - a program that we can use to operate the computer.\nThere's nothing special about terminals - anyone can write a program to operate as a terminal, which is why you will see many different terminals around. Examples are the standard \u0026lsquo;terminal\u0026rsquo; app for MacOS X, the gnome-terminal for Linux, and iTerm2 and Hyper. There's a bunch of screenshots of different setups at the end of the article.\nBack to the Shell Now that we've described the terminal, we can go back and look at the shell in detail.\nThe shell is the program that is going to take input from somewhere and run a series of commands. When the shell is running in a terminal, it is normally taking input interactively from the user. As the user types in commands, the terminal feeds the input to the shell and presents the output of the shell on the screen.\nA shell program can also take input from files; these files will then generally be \u0026lsquo;shell scripts\u0026rsquo;. This might be used to run automated operations, such as cleaning up certain folders when a computer starts.\nShells can write output to files or other locations, and so on. You can run a shell program outside of a terminal - you just won't be able to interface with it using a keyboard or display. And in fact, lots of operations happen in this way: automated scripts, startup tasks, installers and so on.\nSo what else does a shell do? Most of the features are related to helping human operators work with the system more efficiently.\n Quickly enter commands, see the history of commands and quickly restructure commands (see Effective Shell - Navigating the Command Line) Navigate through the file system, moving from folder to folder (see Effective Shell - Move Around!), which makes it easier for an operator to navigate the file system. Chain the output of commands together - for example, taking the output of one basic program, such as the tree program we saw, and writing it to a file (see Effective Shell - Understanding Pipelines) Offer a programming language, allowing the operator to perform more complicated tasks (see Effective Shell - Basic Shell Scripting)  And a lot more! In fact, that's what the whole Effective Shell series is about - how to get the most from these powerful programs, particularly for those who use them regularly.\nThe Command Prompt or Command Line The last part of the diagram, which we haven't covered yet, is the command prompt.\nWhen a shell is running in terminal, it knows that a human operator will be interfacing with it. So to make sure that the operator has some kind of visual hint that they have to enter commands, the shell will output some kind of prompt.\nI've included a set of screenshots at the end of the article, just after this section, and you can see how some different command prompts look.\nNote that shells don't have to use command prompts - if you use a shell program to execute a script, there will be no command prompt. Shells only show a prompt when they know they are being used interactively. Many programs which allow a user to operate interactively will show a command prompt.\nShell command prompts can be customised, so they will often look different from machine to machine (for more details, see Effective Shell - Customising the Command Line). Below is an example that shows a lot of technical information. This is from the highly popular oh-my-zsh framework for the \u0026lsquo;Z Shell\u0026rsquo; shell, which is very popular among developers:\n*(Source: https://ohmyz.sh/)\nShell Commands and Different Shells A lot of the \u0026lsquo;commands\u0026rsquo; in a shell, such as cat (which shows the contents of a file), are actually just simple programs, which will interface with the kernel. No matter what shell you use, these commands will behave the same way, because really all you are doing is calling another program.\nSome commands, such as cd (change directory), are built into the shell. Some commands are functions that have been defined, or aliases to other commands (for more details on commands, see Effective Shell - Commands). Commands will often differ between shells.\nNot all shells are created equal - anyone can write a shell program, maybe creating a simple interface to the computer or a highly complex one with many features. In fact, a later article in this series will look at the genealogy of the most common shells.\nOn most Unix-like systems, the default shell is a program called bash, which stands for \u0026quot; Bourne Again Shell\u0026rdquo; (the name and history around it will be discussed at length in the later article). But there are many other shells: the C Shell, the Korn Shell, Z Shell and Fish, just to name just a few.\nUsers and administrators can configure what shell they like to use. When a terminal opens, it will immediately start the user's preferred shell program. It is possible to change this. Different users will have different preferences, given that shells offer varying features. This can cause complexity when working with systems, as we cannot always expect every user to have the same shell, or even for the same shell to be set up consistently, as they can be extensively customised.\nLet's review the earlier diagram again:\nWe can see the real internals of what is going on in this \u0026ldquo;Terminal -\u0026gt; Shell -\u0026gt; Program\u0026rdquo; chain in the diagram above quite easily.\nTry the command pstree -psa $$ in a shell9:\nThe first systemd process is the primary process for the OS - it is process number 1, which initialises everything else. The second systemd process is the process that is running the interface for my user. We can ignore these for now; they are internals to how the operating system boots and starts processes.\nWhat is interesting is that we can see a terminal (the gnome terminal), which has started my preferred shell (which is zsh), which is running a command (the program pstree). Here we can see the exact chain as shown in the diagram earlier.\nThat's a Wrap! These are the key technologies and concepts that surround a shell.\nIf you are interested in more technical details of working with shells, then my Effective Shell series goes into these topics in depth. The goal of this series is to help teach techniques that making working with shells more efficient.\nTo close the article, below are some examples of different terminals, shells, command prompts and so on.\nExample: iTerm 2 / tmux / zsh In this example, we have:\n A MacOS operating system iTerm2 as the terminal program tmux running as a \u0026lsquo;terminal multiplexer\u0026rsquo; (see Effective Shell: Terminal Multiplexers) zsh (Z Shell) as the shell program, using \u0026lsquo;oh my zsh\u0026rsquo;, which is easily recognised by the % sign in the command prompt. A customised command line, which shows the user and folder on one line, with only the % symbol below, to leave lots of space for the input commands10.  Example: Bash In this example, we have:\n A Linux operating system (Ubuntu 14) The gnome terminal bash as the shell In the second screenshot, the user has \u0026lsquo;root privileges\u0026rsquo;, and to indicate this, bash helpfully changes the default command prompt from a dollar sign to a hash sign  Example: Windows Explorer In this example, we have:\n The Windows 10 operating system No terminal The explorer.exe program showing us a graphical shell  This looks different from previous examples. The program, which shows the familiar Windows interface, explorer.exe, is in fact a shell as well, offering interactive access to the operating system and computer resources. The bulk of the Windows APIs to interact with this interface are in the Shell Library. I also maintain a popular library for building extensions to the graphical Windows shell - sharpshell.\nExample: Windows Command Prompt In this example, we have:\n The Windows 10 operating system The command prompt terminal and shell  In Windows, the terminal and shell are combined into a single cmd.exe program. There's an excellent article on the internals - Microsoft DevBlogs: Windows Command-Line: Inside the Windows Console\nExample: Windows PowerShell In this example, we have:\n The Windows 10 operating system The PowerShell terminal  PowerShell is an improvement on the \u0026lsquo;command prompt\u0026rsquo; program that was originally used in Windows, offering much more functionality for scripting and other modern shell features.\nExample: Windows Subsystem for Linux (WSL) In this example, we have:\n The Windows 10 operating system The Bash.exe program  This screenshot, from MSDN: Frequently Asked Questions about Windows Subsystem for Linux shows Bash running in Windows. This is a relatively new feature at the time of writing, allowing Windows users to use a Linux interface to the PC. This is a feature that may become increasingly valuable, as in general it is challenging to write shell code that can run on Windows and Unix-like systems.\nShare and Discuss If you enjoyed this article, please do share it! Feel free to include suggestions, improvements or corrections in the comments below.\n Useful References\n A simple Linux kernel module, showing how basic kernel programming works in Linux: github.com/dwmkerr/linux-kernel-module How Linux Works - Brian Ward StackExchange: What is the exact difference between a \u0026lsquo;terminal\u0026rsquo;, a \u0026lsquo;shell\u0026rsquo;, a \u0026lsquo;tty\u0026rsquo;, and a console? Microsoft: Inside the Windows Console   Footnotes\n  I'd be fascinated to know if this is at all interesting to less technically inclined people, so please do go ahead and let me know in the comments! \u0026#x21a9;\u0026#xfe0e;\n CPU: central processing unit. This is the chip in the computer that does most of the work (which after many layers of abstraction eventually becomes arithmetic and sending simple instructions to other places). \u0026#x21a9;\u0026#xfe0e;\n Memory is the \u0026lsquo;working space\u0026rsquo; where the state of your system is stored. If you are writing a document, the text lives in memory, until you save it, when it then gets written to a hard drive. Memory is ephemeral - everything is gone when you turn off the power to it. \u0026#x21a9;\u0026#xfe0e;\n This is the part of your computer that knows how to do things like connect to a WiFi network, or has a network socket you might plug a network cable into. \u0026#x21a9;\u0026#xfe0e;\n This is the part of your computer you plug the screen into. \u0026#x21a9;\u0026#xfe0e;\n This is because a mistake in Kernel Mode programs can have disasterous effects. It could access any files, no matter who they belong do, control the hardware, install more software - almost anything. Errors in this code can cause terrible issues (like the infamous Windows \u0026lsquo;blue screen of death\u0026rsquo;), and malicious code in the kernel essentially has full access to not only all your data but also your webcam, network adapter and so on. \u0026#x21a9;\u0026#xfe0e;\n As an aside, if you are curious about the visual style of my setup or customisations that have been made, everything in my setup is available online on my \u0026lsquo;dotfiles\u0026rsquo; repo - github.com/dwmkerr/dotfiles. \u0026#x21a9;\u0026#xfe0e;\n And that's where the \u0026lsquo;TTY\u0026rsquo; acronym you will see sometimes comes from. Enter the ps command, and you'll actually see the TTY interface each process is attached to. This is a topic that will come up later in the series. \u0026#x21a9;\u0026#xfe0e;\n $$ is a Bash internal variable. These will also be covered in a later article in the series. \u0026#x21a9;\u0026#xfe0e;\n Feel free to see my dotfiles to configure a similar setup for yourself. \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':9,'href':'/docs/part-1-transitioning-to-the-shell/6-summary/','title':"Section 0 - Summary",'content':"Summary In this section we learnt:\n That this book is for IT professionals, hobbyists or anyone who wants to learn more about how to work with computers What the shell is, and why we might want to use it How to open the shell programs for Windows, Mac and Linux which are installed by default How to configure the shells for Windows or Mac to behave in a Linux-like way to allow us to follow on with the rest of the book  We introduced the following commands:\n cd - which changes directory pwd - which prints the current working directory ls - which lists the contents of a directory echo - which writes text to the screen open - which will open a file or folder  We also briefly introduced variables, which are special values which start with the dollar symbol, such as $HOME which stores the user's home directory. We saw that each directory contains two special directories - .. which represents the parent directory, and . which represents the current directory.\nWith these tasks complete we can now move onto the next section.\n"});index.add({'id':10,'href':'/docs/0-introduction/','title':"Introduction",'content':"Introduction This book is for anyone who is interested in computing, and wants to learn more about the exciting, but sometimes daunting world of \u0026ldquo;The Shell\u0026rdquo;!\nThe shell is the basic interface for controlling a computer with just a keyboard. People use it for managing computers, writing software, doing data science, or even writing books like I am doing! Here's what the shell looks like:\nIf you are already thinking \u0026ldquo;no, this looks too geeky for me!\u0026rdquo; then think again, for almost anyone who uses a computer, or is interested in computing, this book will introduce what the shell is, how it works, and how to use it effectively.\nIf you are already an experienced user, this book also introduces many advanced topics, tips and tricks, and ways you can increase your productivity in the shell.\nThe goal of this book is to be a collection of small, contained tutorials on how to use the shell more effectively, you can go through it sequentially or just pick and choose the sections which seem the most interesting.\nIf you are already comfortable with running a shell, know what bash is, and know how to run basic commands like ls and cd, are familiar with terms like command and parameter then you can skip through some of the earlier sections and pick up the chapters which sound most interesting to you.\nAll of the content of this book is designed to be suitable to work with Microsoft Windows, Mac OS and Linux. So no matter what system you are running, you should be able to follow along. We will focus primarily on \u0026lsquo;Linux Like\u0026rsquo; environments, which hopefully will give you the skills which you can apply most widely. For Windows, we'll look into how to tweak your system to be able to run all of the samples.\n"});index.add({'id':11,'href':'/docs/section6/reading-list/','title':"Reading List",'content':""});index.add({'id':12,'href':'/docs/section1/2-clipboard-gymnastics/examples/formatting/','title':"Formatting",'content':" Formatting   Apples Oranges Pears Apples    "});index.add({'id':13,'href':'/docs/section1/5-what-is-a-shell/hack-on/','title':"Hack On",'content':"Hack On! See those system calls! I mentioned earlier on that if you make a call like fopen, the Kernel is going to provide access to a file. It's quite easy to see this in action. Check the code below:\n#include \u0026lt;stdio.h\u0026gt; void main() { void* handle = fopen(\u0026#34;/tmp/some-file\u0026#34;); fwrite(handle, \u0026#34;some text\u0026#34;); fclose(handle); } If you compile this program, then run XXX you will see the actual calls made to the Kernel. It can be very useful to use this technique to see what is going on with programs under the hood, particularly when diagnosing issues.\nHack On! Ahah! So that's TTY? Consider a command like:\ndocker -it Consider a command like:\nssh user@remote.com my-script no tty Once you understand the concept of shells and terminals in a bit more detail, more obscure messages like this start to make sense.\nIn the first instance, we are telling Docker we are interactive - i.e. we are going to use an interface to send commands. The second parameter, -t says use a TTY - which is short for teletype terminal, old fashioned lingo for the screen.\nTODO TTY picture\nTODO Summmary; technical For technical readers, there's quite a lot of terms which get thrown about almost interchangeably; shell, command-line, terminal, tty, command-prompt, CLI and so on. But each of these have a very specific meaning. It's important to understand exactly what each of these terms really means, where they came from, and how these different types of system or concept relate to each other.\nSummary; non-tech A computer in a nutshell.\n \u0026ndash; Could link to other layers of abstractions - such as sandboxes in webpages? \u0026ndash; Could link to other layers of abstraction, such as containers?\n"});index.add({'id':14,'href':'/docs/section2/6-job-control/','title':"Index",'content':"Job control is a feature of most shells, which is generally not particularly intuitive to work with. However, knowing the basics can help prevent you from getting yourself into a tangle, and can from time to time make certain tasks a little easier.\nWhat Is Job Control? Let's start with an example. I am building a simple web page. It has one index.html file, one styles.css file, and one code.js file. The index.html file looks like this:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;My New Project\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;styles.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;code.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!--Snip... --\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Opening the file in a browser doesn't quite work, as it won't load the code or the styles. We need a web server to serve styles and code.\nA super-useful one-liner to run a web server on any machine with Python installed is:\npython -m SimpleHTTPServer 3000 In fact, this is so useful that I normally alias this command, so that I can just type serve. We'll see aliases in a later chapter.\nFor now, if we run this command (you can get the three sample files here if you want to try this yourself), then we can open the webpage in a browser, with the styles and code loaded:\nWe can also see that the server has served the HTML, JavaScript, and CSS files:\nAll well and good so far.\nThe Problem Let's say we want to now continue using our shell, maybe to edit the website with a terminal editor like Vim or Emacs, or we want to zip up the site, or just run any shell command1.\nWe have a problem. The python process is still running - it's serving the website. Our shell is essentially useless, until we stop the server. See what happens when I try to edit a file:\nIn the example above, I try to run vi, but nothing is happening. Standard input is not being read by the server and not being interpreted by the shell.\nI have to kill the server by hitting Ctrl+C (which sends a SIGINT2 - we'll see more about signals later), clear my screen to get rid of all of the error messages, then start again.\nThis is obviously not optimal. Let's look at some solutions.\nSolution 1: Start the Server in the Background In most shells, you can run a command and instruct the shell to run it in the background. To do this, you end the line with an ampersand. Here's how the example would look in this case:\nBy ending the command with an \u0026amp; ampersand symbol, we instruct the shell to run the command as a background job. This means that our shell is still functional. The shell has also notified us that this command is running as a background job with a specific job number:\n% python -m SimpleHTTPServer 3000 \u0026amp; [1] 19372 In slightly obtuse language, the shell has informed us that it has started a job in the background, with job number 1 and that this job is currently handling the process with ID 19372.\nThe ampersand solution is a fairly common pattern used in day-to-day work.\nSolution 2: Move the Server to the Background Let's say you forgot to start the command in the background. Most likely in this case you'd kill the server with Ctrl+C and then start it again with the \u0026amp; option. However, what if this was a large file download or a task you didn't want to abort?\nIn the example below, we'll move the job to the background:\nThe process is currently in the foreground, so my shell is inactive. Hitting Ctrl+Z sends a \u0026lsquo;suspend\u0026rsquo; signal to the process3, pausing it and moving it to the background.\nLet's dissect this:\n% python -m SimpleHTTPServer 3000 Serving HTTP on 0.0.0.0 port 3000 ... 127.0.0.1 - - [03/Jun/2019 13:38:45] \u0026#34;GET / HTTP/1.1\u0026#34; 200 - ^Z [1] + 21268 suspended python -m SimpleHTTPServer 3000 The shell echos as I type, so we see ^Z (i.e., the Ctrl+Z chord I entered). The shell responds by moving the process into a background job and suspending it.\nThe key here is that it is suspended. The process is paused. So the web server is no longer serving. If you are following with the sample, reload your browser. The webpage fails to load, as the server process is not able to respond to requests.\nTo continue the job, in the background, we use the bg (\u0026lsquo;background\u0026rsquo;) command, with a job identifier (which always starts with a % symbol - we'll see why soon) to tell the shell to continue the job:\n% bg %1 [1] + 21268 continued python -m SimpleHTTPServer 3000 The shell lets us know the job is being continued, and if we load the webpage again, the content is shown as expected.\nAs a final check, we run the jobs command to see what jobs the shell is running:\n% jobs [1] + running python -m SimpleHTTPServer 3000 And there you have it - our server is running as a background job. This is exactly what we would see if we run jobs after starting the server with an \u0026amp; at the end. In fact, using an \u0026amp; is perhaps an easier way to remember how to continue a suspended job:\n% %1 \u0026amp; [1] + 21268 continued python -m SimpleHTTPServer 3000 In the same way ending a command with \u0026amp; runs it in the background, ending a job identifier with \u0026amp; continues it in the background.\nThere is at least one more way to move a job to the background4, but I have not yet found it useful in any scenarios, and it is overly complex to explain. See the footnote for details if you are interested.\nMoving Background Jobs to the Foreground If you have a job in the background, you can bring it back to the foreground with the fg (\u0026lsquo;foreground\u0026rsquo;) command. Let's show the jobs, with the jobs command:\n% jobs [1] + running python -m SimpleHTTPServer 3000 Here I have a background job running a server. Any one of the following commands will bring it back to the foreground:\nfg %1 # Explicitly bring Job 1 into the foreground %1 # ...or in shorthand, just enter the job id... fg # ...if not given an id, fg and bg assume the most recent job. Now the job is in the foreground, and you can interact with the process again however you like.\nCleaning Up Jobs You might realise you cannot continue what you are doing because an old job is still running. Here's an example:\nI tried to run my web server, but there was still one running as a background job. The server failed to start because the port is in use.\nTo clean it up, I run the jobs command to list the jobs:\n% jobs [1] + suspended python -m SimpleHTTPServer 3000 There's my old web server. Note that even though it is suspended, it'll still be blocking the port it is serving on5. The process is paused, but it is still holding onto all of the resources it is using.\nNow that I know the job identifier (%1 in this case), I can kill the job:\n% kill %1 [1] + 22843 terminated python -m SimpleHTTPServer 3000 This is why job identifiers start with a percentage sign! The kill command I have used is not a special job control command (like bg or fg). It is the normal kill command, which terminates a process. But shells that support job control can normally use a job identifier in place of a process identifier. So rather than working out what the process identifier is that I need to kill, I can just use the job identifier6.\nWhy You Shouldn't Use Jobs Avoid jobs. They are not intuitive to interface with, and they suffer from some serious problems.\nThe most obvious one is that all jobs write to the same output, meaning you can quickly get garbled output like this:\nThis is what happens when I run a job, which just outputs text every second. It's in the background, but it's printing all over my commands. Even running the jobs command to try and find the job to stop it is difficult.\nInput is even more complex. If a job is running in the background, but requires input, it will be silently suspended. This can cause confusion.\nJobs can be used in scripts but must be done so with caution and could easily confuse a consumer of the script if they leave background jobs hanging around, which cannot be easily cleaned up7.\nHandling errors and exit codes for jobs can be problematic, causing confusion, poor error handling, or overly complex code.\nHow to Escape Jobs If there are two things to take away, it would be this:\n If you have started running a command in the foreground, and you don't want to stop it and would rather move it to the background, hit Ctrl+Z. Then Google \u0026ldquo;job control\u0026rdquo;.\n And:\n If you think there is a job running in the background, and it is messing with your screen, type fg to bring it to the front and kill it with Ctrl+C. Repeat as needed!\n In either case, if you need to do something more subtle, you can return to this reference. But the first command should allow you to get your shell back while you work out how to continue the job, and the second should kill a background job that is messing with your screen.\nAlternatives to Jobs If you are using any kind of modern terminal such as iTerm, Terminal or the GNOME Terminal, just open a new tab or split! Much easier.\nThe benefit to this is that each tab gets its own standard input and output, so there's no risk of overwriting. And of course you can hide/reveal/rearrange the tabs however you like.\nThe traditional alternative to a job for an operator who simply wants more than one thing going on at once would be a terminal multiplexer, such as screen or tmux:\nMultiplexers work in a very similar way to a modern graphical terminal - they manage many shell instances. The benefits to a modern terminal, such as iTerm, is that you have a very intuitive GUI and lots of features.\nThe benefits to a multiplexer are that you can run them over SSH sessions to manage complex operations on remote machines and that they run a client-server model, meaning many people can work with many multiplexed processes (and they can persist beyond sessions).\nMy personal preference is both - I use a modern terminal and run everything inside it in tmux. We'll look at both of these options in later chapters.\nQuick Reference You might find that jobs are useful, or you might find that they are not. Either way, here's a quick reference of some common commands:\n   Command Usage     command \u0026amp; Run the command as a background job.   \u0026lt;Ctrl+Z\u0026gt; Move the current process into a background job, suspended.   jobs List all jobs.   fg %1 Move background job number 1 into the foreground.   bg %1 Continue background job number 1.   kill %1 Terminate job number 1.   wait %1 Block until job number 1 exits.    If you want to find out more about the gory details of jobs, the best place to start is the Bash Manual - Job Control Section, or the \u0026lsquo;Job Control\u0026rsquo; section of your preferred shell's manual.\nI hope you found this useful, and, as always, please leave comments, questions or suggestions below!\n Footnotes   If you are not a heavy shell user, this might seem unlikely. But if you do a lot of work in shells, such as sysadmin, devops, or do your coding from a terminal, this happens all the time! \u0026#x21a9;\u0026#xfe0e;\n Signals like SIGINT, SIGKILL, SIGTERM and so on will be covered in a later chapter. \u0026#x21a9;\u0026#xfe0e;\n Technically, SIGTSTP - which is \u0026lsquo;TTY stop\u0026rsquo;. If you have always wondered about the \u0026lsquo;TTY\u0026rsquo; acroynm, check the previous chatper, Interlude: Understanding the Shell. \u0026#x21a9;\u0026#xfe0e;\n The alternative method is to use Ctrl+Y, which will send a delayed interrupt, which will continue to run the process until it tries to read from stdin. At this point, the job is suspended and the control given to the shell. The operator can then use bg or kill or fg to either move to the background, stop the process, or keep in the foreground as preferred. See: https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Job-Control \u0026#x21a9;\u0026#xfe0e;\n Another super-useful snippet: lsof -i -P -n | grep 8000 to find any process that has a given port open. Another one for the aliases chapter! \u0026#x21a9;\u0026#xfe0e;\n There are times this is needed. If a job runs many processes - for example, by running a pipeline - the process identifier will change as the command moves from one stage of the pipeline to the next. The job identifier will remain constant. Remember, a job is a shell command, so could run many processes. \u0026#x21a9;\u0026#xfe0e;\n To see how bad this can be, create a script that starts jobs, then run it. Then run the jobs command to see what is running. The output might surprise you! \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':15,'href':'/docs/section2/7-understanding-commands/','title':"Index",'content':"In this chapter, we'll take a look at the various different types of shell commands that exist and how this can affect your work.\nBy the end of this chapter, you might even be able to make sense of the horrifying and perfectly syntactically valid code below:\nwhich $(where $(what $(whence $(whereis who)))) What Are Commands? This is really important to understand! A command in a shell is something you execute. It might take parameters. Generally it'll have a form like this:\ncommand param1 param2 We've already seen many commands during this series:\nls # Show the contents of the current directory cd ~ # Move to the user\u0026#39;s home cat file.txt # Output the contents of \u0026#39;file.txt\u0026#39; to stdout But to be an effective shell user, you must understand that not all commands are created equal. The differences between the types of commands will affect how you use them.\nThere are four types of commands in most shells:\n Executables \u0026ldquo;Built-Ins\u0026rdquo; (which we'll just call builtins from now on) Functions Aliases  Let's quickly dig in and see a bit more.\nExecutables - Programs Executables are just files with the \u0026lsquo;executable\u0026rsquo; bit set1. If I execute the cat command, the shell will search for an executable named cat in my $PATH. If it finds it, it will run the program.\n$ cat file.txt This is a simple text file What is $PATH? $PATH is the standard environment variable used to define where the shell should search for programs. If we temporarily empty this variable, the shell won't find the command:\n$ PATH=\u0026#34;\u0026#34; cat file.txt bash: cat: No such file or directory Normally your $PATH variable will include the standard locations for Linux programs - folders such as /bin, /sbin, /usr/bin and so on2.\nIf you were to print the variable, you'd see a bunch of paths (they are separated by colons; I've put them on separate lines for readability):\n/usr/local/bin /usr/bin /bin /usr/sbin /sbin The shell will start with the earlier locations and move to the later ones. This allows local flavours of tools to be installed for users, which will take precedence over general versions of tools.\nThere will likely be other locations too - you might see Java folders, package manager folders and so on.\nExecutables - Scripts Imagine we create a text file called dog in the local folder:\n#!/bin/sh echo \u0026#34;🐶 woof 🐶\u0026#34; If we make the file executable, by running chmod +x dog3, then we can run this just like any other program - as long as we tell the shell to look for programs in the current directory:\n$ PATH=\u0026#34;.\u0026#34; dog 🐶 woof 🐶 More common would be to run the program by giving a path:\n$ ./dog 🐶 woof 🐶 Or just move it to a standard location that the shell already checks for programs:\n$ mv dog /usr/local/bin $ dog 🐶 woof 🐶 The point is that executables don't have to be compiled program code. If a file starts with #! (the \u0026lsquo;shebang\u0026rsquo;), then the system will try to run the contents of the file with the program specified in the shebang.\nWe will look at shebangs in greater detail in a later chapter.\nBuiltins OK, so we've seen executables. What about a command like this?\nlocal V=\u0026#34;hello\u0026#34; echo $V You will not find the local executable anywhere on your system. It is a builtin - a special command built directly into the shell program.\nBuiltins are often highly specific to your shell. They might be used for programming (local for example is used to declare a locally scoped variable), or they might be for very shell-specific features.\nThis is where we need to take note. As soon as you are running a builtin, you are potentially using a feature that is specific to your shell, rather than a program that is shared across the system and can be run by any shell.\nTrying to programmatically execute local as a process will fail - there is no executable with that name; it is purely a shell construct.\nSo how do we know if a command is a builtin? The preferred method is to use the type command:\n$ type local local is a shell builtin The type command (which is itself a builtin!) can tell you the exact type of shell command.\nInterestingly, you might be using more builtins than you think. echo is a program, but most of the time you are not executing it when you are in a shell:\n$ type -a echo echo is a shell builtin echo is /bin/echo By using the -a flag on type to show all commands that match the name, we see that echo is actually both a builtin and a program.\nMany simple programs have builtin versions. The shell can execute them much faster.\nSome commands are a builtin so that they can function in a sensible manner. The cd command changes the current directory - if we executed it as a process, it would change only the directory for the cd process itself, not the shell, making it much less useful.\nBuiltins will vary from shell to shell, but many shells are \u0026lsquo;Bash-like\u0026rsquo; - meaning they will have a set very similar to the Bash builtins, which you can see here:\nhttps://www.gnu.org/software/bash/manual/html_node/Bash-Builtins.html\nAs should be familiar from Part 3: Getting Help, you can get help for builtins:\n$ man source # source is a builtin BUILTIN(1) BSD General Commands Manual BUILTIN(1) NAME builtin, !, %, # ...snip... SYNOPSIS builtin [-options] [args ...] However, the manual will not show information on specific builtins, which is a pain. Your shell might have an option to show more details - for example, in Bash you can use help:\n$ help source source: source filename [arguments] Read and execute commands from FILENAME and return. The pathnames in $PATH are used to find the directory containing FILENAME. If any ARGUMENTS are supplied, they become the positional parameters when FILENAME is executed. But remember: help is a builtin; you might not find it in all shells (you won't find it in zsh, for example). This highlights again the challenges of builtins.\nFunctions You can define your own shell functions. We will see a lot more of this later, but let's show a quick example for now:\n$ restart-shell () { exec -l $SHELL } This snippet creates a function that restarts the shell (quite useful if you are messing with shell configuration files or think you might have irreversibly goofed up your current session).\nWe can execute this function just like any command:\n$ restart-shell And running type will show us that this is a function:\n$ type restart-shell restart-shell is a function restart-shell () { exec -l $SHELL } Functions are one of the most powerful shell constructs we will see; they are extremely useful for building sophisticated logic. We're going to see them in a lot more detail later, but for now it is enough to know that they exist, and can run logic, and are run as commands.\nAliases An alias is just a shortcut. Type in a certain set of characters, and the shell will replace them with the value defined in the alias.\nSome common commands are actually already aliases - for example, in my zsh shell, the ls command is an alias:\n% type -a ls ls is an alias for ls -G ls is /bin/ls I make sure that when I use the ls command, the shell always expands it to ls -G, which colours the output.\nWe can quickly define aliases to save on keystrokes. For example:\n$ alias k=\u0026#39;kubectl\u0026#39; From this point on, I can use the k alias as shorthand for the kubectl command.\nAliases are far less sophisticated than functions. Think of them as keystroke savers and nothing more, and you won't go far wrong.\nSo What? So we now hopefully have a greater understanding of the variety of shell commands. Not all commands are executables, not all of the commands we think are executables necessarily are, and some commands might be more sophisticated.\nAs a shell user, the key things to remember are:\n Executables are \u0026lsquo;safe\u0026rsquo; - they are programs your system can use; your shell just calls out to them. Builtins are very shell-specific and usually control the shell itself Functions are powerful ways to write logic but will normally be shell-specific. Aliases are conveniences for human operators, but only in the context of an interactive shell.  To find out how a command is implemented, just use the type -a command:\n$ type -a cat cat is /bin/cat More than You Need to Know OK, for the masochistic few, you might be wondering about all of the other commands and utilities you may have seen that can tell you about programs and commands:\n what whatis which whence where whereis command type  A lot of these are legacy and should be avoided, but for completeness sake, we'll go through them.\nwhat what reads out special metadata embedded in a program, generally used to identify the version of source code it was built from:\n$ what /bin/ls /bin/ls Copyright (c) 1989, 1993, 1994 PROGRAM:ls PROJECT:file_cmds-272.220.1 There should be almost no circumstance in which you need to use it in your day-to-day work, but you might come across it if you meant to type whatis.\nwhatis whatis searches a local help database for text. This can be useful in tracking down manual pages:\n$ whatis bash bash(1) - GNU Bourne-Again SHell bashbug(1) - report a bug in bash But I can't imagine it will be a regularly used tool by most users.\nwhich which will search your $PATH to see whether an executable can be found. With the -a flag, it will show all results.\n$ which -a vi /usr/local/bin/vi /usr/bin/vi which originated in csh. It remains on many systems for compatibility but in general should be avoided due to potentially odd behaviour4.\nwhence whence was added to the Korn shell. You are unlikely to use it unless you are on systems using ksh. zsh also has this command, but it should be avoided and considered non-standard.\n% whence brew /usr/local/bin/brew where This is a shell builtin that can provide information on commands, similar to type:\n% where ls ls: aliased to ls -G /bin/ls However, type should be preferred, as it is more standard.\nwhereis whereis is available on some systems and generally operates the same as which, searching paths for an executable:\n% whereis ls /bin/ls Again, type should be preferred for compatability.\ncommand command is defined in the POSIX standard, so should be expected to be present on most modern systems. Without arguments, it simply executes a command. With the -v argument, you get a fairly machine-readable or processable response; with the -V argument, you get a more human readable response:\n% command -v ls alias ls=\u0026#39;ls -G\u0026#39; % command -V ls ls is an alias for ls -G command can be useful in scripts, as we will see in later chapters.\ntype type is part of the Unix standard and will be present in most modern systems. As we've already seen, it will identify the type of command as well as the location for an executable:\n% type -a ls ls is an alias for ls -G ls is /bin/ls This command can also be used to only search for paths:\n% type -p ls ls is /bin/ls Summary\nIn summary, avoid anything that starts with \u0026lsquo;w\u0026rsquo;! These are legacy commands, generally needed only when working on older Unix machines. type or command should be used instead.\n Footnotes\n  We will cover permissions and modes in later chapters. \u0026#x21a9;\u0026#xfe0e;\n Why these names and locations? It's a long story. The best place to start if you are intersted is the Filesystem Hierarchy Standard. \u0026#x21a9;\u0026#xfe0e;\n chmod changes the mode of a file; +x means \u0026lsquo;add the executable bit\u0026rsquo;. This tells the operating system the file can be executed. \u0026#x21a9;\u0026#xfe0e;\n Stack Exchange: Why not use “which”? What to use then? \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':16,'href':'/docs/','title':"Docs",'content':""});index.add({'id':17,'href':'/','title':"Effective Shell",'content':"Effective Shell This book is for anyone who is interested in computing, and wants to learn more about the exciting, but sometimes daunting world of \u0026ldquo;The Shell\u0026rdquo;!\nFor the newcomer, you'll learn what a shell is, how to use it on your system, and then how to become more effective everyday by integrating the shell into your work.\nFor the experienced professional, there are chapters which go into advanced topics and introduce real-world ways to be more effective with your usage.\nTo get started, jump over to the Introduction page from the menu or the left, whichever chapter sounds the most appealing!\nTo setup your computer to follow along with the chapters, check the Getting Started guide.\nIf you would like to get email updates when new chapters are published, please do provide your email below. I won't be using it for anything beyond updates to the book.\n#mc_embed_signup{background:#fff; clear:left; font:14px Helvetica,Arial,sans-serif; width:100%;} /* Add your own Mailchimp form style overrides in your site stylesheet or in this style block. We recommend moving this block and the preceding CSS link to the HEAD of your HTML file. */  Subscribe for Updates      This book is also open source! The code is on github.com/dwmkerr/effective-shell. Feel free to use the \u0026lsquo;Comments\u0026rsquo; section at the bottom of each page to discuss the content, or even open a pull request to propose changes.\n"});index.add({'id':18,'href':'/docs/part-1-transitioning-to-the-shell/','title':"Part 1 - Transitioning to the Shell",'content':"Part 1 - Transitioning to the Shell These are the key skills which everyone should know. Without them, you might struggle to perform certain tasks at all. Experienced users can probably skip this section, or just review the summary. But if you are new to the shell, this is the best place to start! This section focuses on helping you quickly get up to speed with how to perform the same kind of tasks you might have performed in a GUI (Graphical User Interface) with the shell.\n"});})();