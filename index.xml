<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Effective Shell</title><link>https://effective-shell.com/</link><description>Recent content on Effective Shell</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://effective-shell.com/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://effective-shell.com/docs/part-1-transitioning-to-the-shell/clipboard-gymnastics/examples/formatting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://effective-shell.com/docs/part-1-transitioning-to-the-shell/clipboard-gymnastics/examples/formatting/</guid><description> Formatting Apples Oranges Pears Apples</description></item><item><title/><link>https://effective-shell.com/docs/part-2-core-skills/what-is-a-shell/hack-on/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://effective-shell.com/docs/part-2-core-skills/what-is-a-shell/hack-on/</guid><description>Hack On! See those system calls! I mentioned earlier on that if you make a call like fopen, the Kernel is going to provide access to a file. It's quite easy to see this in action. Check the code below:
#include &amp;lt;stdio.h&amp;gt; void main() { void* handle = fopen(&amp;#34;/tmp/some-file&amp;#34;); fwrite(handle, &amp;#34;some text&amp;#34;); fclose(handle); } If you compile this program, then run XXX you will see the actual calls made to the Kernel.</description></item><item><title/><link>https://effective-shell.com/docs/part-x-appendices/essential-manpages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://effective-shell.com/docs/part-x-appendices/essential-manpages/</guid><description>The Most Important Manpages As an appendix, or printed reference, list of the top ten manpages?
man re_pattern - basic and extended regex patterns man test is an excellent way to quickly check common tests (existence of a file etc) man set is super useful when checking options like set -ex in scripts man re_format man getopt man XXX show signal commands (Ctrl+V etc) man bash search for ARITHMETIC\ EVALUATION to find how arithmetic operators work in bash man bash search GRAMMAR for pipelines, if statements, conditionals, loops, lists and so on man bash search for ^EXPANSION to see all shell expansion operators man bash search for ^INVOCATION to find details on startup and the startup files that are read man bash search for ^[ ]+shopt to find descriptions of shell options Essential Bash Manpages</description></item><item><title/><link>https://effective-shell.com/docs/part-x-appendices/index-of-commands/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://effective-shell.com/docs/part-x-appendices/index-of-commands/</guid><description>Command Description cd ls pwd mkdir rm rmdir cd cd pstree -p $$ Show the process tree for the current shell process. User Management useradd -m name Add user with the name name. -m creates a home directory name.</description></item><item><title/><link>https://effective-shell.com/docs/part-x-appendices/setting-up-a-linux-virtual-machine/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://effective-shell.com/docs/part-x-appendices/setting-up-a-linux-virtual-machine/</guid><description>Setting up a Linux Virtual Machine Todo: how to set up any of the three main distros (Debian, SUSE, Centos)
Note different:
Package managers Startup Managers Desktop Managers</description></item><item><title/><link>https://effective-shell.com/docs/part-x-appendices/shell-parameter-expansion/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://effective-shell.com/docs/part-x-appendices/shell-parameter-expansion/</guid><description>Variable Description $$ This is the process ID of the script itself. $0 The first parameter to the shell, which is typically the path of the shell itself. If this parameter starts with - then the shell is assumed to be a Login Shell. $- The flags that were set for the shell, such as i for &amp;lsquo;interactive&amp;rsquo;. $0 The first parameter to the shell, which is typically the path of the shell itself.</description></item><item><title/><link>https://effective-shell.com/docs/work-in-progress/_how-to-avoid-scripting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://effective-shell.com/docs/work-in-progress/_how-to-avoid-scripting/</guid><description>Scripts we need to show how to avoid:
# Save the current value of IFS - so we can restore it later. Split on newlines. old_ifs=$IFS IFS=$'\n' # Find all symlinks and print each one. links=$(find ~ -type l) for link in $links do echo &amp;quot;Found Link: $link&amp;quot; done # Restore the original value of IFS. IFS=$old_ifs The while loop over file contents:
while IFS=&amp;quot;&amp;quot; read -r line || [ -n &amp;quot;$line&amp;quot; ]; do echo &amp;quot;Read: $line&amp;quot; done &amp;lt; ~/effective-shell/data/top100.</description></item><item><title/><link>https://effective-shell.com/docs/work-in-progress/_posix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://effective-shell.com/docs/work-in-progress/_posix/</guid><description>Posix Posix Shells Really good reading here:
https://stackoverflow.com/questions/5725296/difference-between-sh-and-bash
Note that on modern Distros you are often using dash:
$ file -h /bin/sh /bin/sh: symbolic link to dash</description></item></channel></rss>